// src/lookback.ts
import { removeStartEndChars } from "@llm-ui/shared";

// src/jsonPathSet.ts
import { JSONPath } from "jsonpath-plus";
var setJsonPath = (object, path, value) => {
  const result = JSONPath({ path, json: object, resultType: "pointer" });
  if (result.length === 0) {
    throw new Error("Path not found in the object.");
  }
  result.forEach((resultPath) => {
    let parts = resultPath.slice(1).split("/");
    let lastPart = parts.pop();
    let currentObject = object;
    parts.forEach((part) => {
      part = decodeURIComponent(part.replace(/~1/g, "/").replace(/~0/g, "~"));
      if (!(part in currentObject)) {
        throw new Error("Intermediate path not found in the object.");
      }
      currentObject = currentObject[part];
    });
    lastPart = decodeURIComponent(
      lastPart.replace(/~1/g, "/").replace(/~0/g, "~")
    );
    currentObject[lastPart] = value;
  });
};

// src/jsonPathTraverse.ts
import { JSONPath as JSONPath2 } from "jsonpath-plus";
var traverseLeafNodes = (jsonObject, isPathAllowed, callback) => {
  const traverse = (currentObject, currentPath) => {
    if (currentObject !== null && typeof currentObject === "object") {
      if (!Array.isArray(currentObject) && Object.keys(currentObject).length === 0 || Array.isArray(currentObject) && currentObject.length === 0) {
        if (shouldTraverse(currentPath, true)) {
          callback(currentObject, currentPath);
        }
      } else {
        if (!shouldTraverse(currentPath, false)) {
          return;
        }
        Object.entries(currentObject).forEach(([key, value]) => {
          traverse(
            value,
            `${currentPath}${Array.isArray(currentObject) ? `[${key}]` : `.${key}`}`
          );
        });
      }
    } else {
      if (shouldTraverse(currentPath, true)) {
        callback(currentObject, currentPath);
      }
    }
  };
  const shouldTraverse = (path, isLeaf) => {
    const pathPointer = JSONPath2({
      path,
      json: jsonObject,
      resultType: "pointer"
    });
    return isPathAllowed(pathPointer, jsonObject, isLeaf);
  };
  traverse(jsonObject, "$");
};
var isAllowed = (allowPaths) => (pathPointers, jsonObject, isLeaf) => {
  return !isLeaf || allowPaths.some((allowPath) => {
    const allowPathPointers = JSONPath2({
      path: allowPath,
      json: jsonObject,
      resultType: "pointer"
    });
    return allowPathPointers.some(
      (app) => pathPointers.some((p) => p === app)
    );
  });
};
var isIgnored = (ignorePaths) => (pathPointers, jsonObject) => {
  return !ignorePaths.some((ignorePath) => {
    const ignorePathPointers = JSONPath2({
      path: ignorePath,
      json: jsonObject,
      resultType: "pointer"
    });
    return ignorePathPointers.some(
      (app) => pathPointers.some((p) => p === app)
    );
  });
};

// src/options.ts
var defaultOptions = {
  startChar: "\u3010",
  endChar: "\u3011",
  defaultVisible: false,
  visibleKeyPaths: [],
  invisibleKeyPaths: [],
  typeKey: "type"
};
var getOptions = (userOptions) => {
  if (!userOptions.type) {
    throw new Error("type option is required");
  }
  return { ...defaultOptions, ...userOptions };
};

// src/parseJson5.ts
import { jsonrepair } from "jsonrepair";
var parseJson5 = (json5) => {
  try {
    return JSON.parse(jsonrepair(json5));
  } catch (e) {
    return void 0;
  }
};

// src/lookback.ts
var jsonBlockLookBack = (userOptions) => {
  const options = getOptions(userOptions);
  const { type, typeKey, defaultVisible, visibleKeyPaths, invisibleKeyPaths } = options;
  return ({ output, visibleTextLengthTarget, isComplete }) => {
    const object = parseJson5(removeStartEndChars(output, options));
    if (!object || object[typeKey] !== type) {
      return { output: "", visibleText: "" };
    }
    let remainingChars = visibleTextLengthTarget;
    let visibleText = "";
    const shouldTraverse = defaultVisible ? isIgnored([`$.${typeKey}`, ...invisibleKeyPaths]) : isAllowed(visibleKeyPaths);
    traverseLeafNodes(object, shouldTraverse, (value, path) => {
      if (typeof value === "string") {
        const valueString = `${value}`;
        const chars = Math.min(remainingChars, valueString.length);
        const valueVisible = valueString.slice(0, chars);
        visibleText += valueVisible;
        setJsonPath(object, path, valueVisible);
        remainingChars -= chars;
      }
    });
    const isStreamingKeys = defaultVisible || visibleKeyPaths.length > 0;
    return {
      output: JSON.stringify(object, null, 2),
      visibleText: isStreamingKeys ? visibleText : isComplete && visibleTextLengthTarget > 0 ? " " : ""
    };
  };
};

// src/matchers.ts
import { regexMatcherGlobal, removeStartEndChars as removeStartEndChars2 } from "@llm-ui/shared";
var findJsonBlock = (regex, options) => {
  const { type } = options;
  const matcher = regexMatcherGlobal(regex);
  return (llmOutput) => {
    const matches = matcher(llmOutput);
    if (matches.length === 0) {
      return void 0;
    }
    return matches.find((match) => {
      const block = parseJson5(removeStartEndChars2(match.outputRaw, options));
      if (!block || block[options.typeKey] !== type) {
        return void 0;
      }
      return match;
    });
  };
};
var findCompleteJsonBlock = (userOptions) => {
  const options = getOptions(userOptions);
  const { startChar, endChar } = options;
  const regex = new RegExp(`${startChar}([\\s\\S]*?)${endChar}`, "g");
  return findJsonBlock(regex, options);
};
var findPartialJsonBlock = (userOptions) => {
  const options = getOptions(userOptions);
  const { startChar } = options;
  const regex = new RegExp(`${startChar}([\\s\\S]*)`, "g");
  return findJsonBlock(regex, options);
};

// src/block.tsx
import { jsx, jsxs } from "react/jsx-runtime";
var jsonBlock = (options) => {
  return {
    findCompleteMatch: findCompleteJsonBlock(options),
    findPartialMatch: findPartialJsonBlock(options),
    lookBack: jsonBlockLookBack(options),
    component: ({ blockMatch }) => /* @__PURE__ */ jsxs("div", { children: [
      /* @__PURE__ */ jsx("a", { href: "https://llm-ui.com/docs/blocks/json", children: "Docs to setup your own component" }),
      /* @__PURE__ */ jsx("pre", { children: blockMatch.output })
    ] })
  };
};

// src/jsonBlockExample.ts
var jsonBlockExample = ({
  schema,
  example,
  options
}) => {
  const parsed = schema.parse(example);
  const { startChar, endChar } = getOptions(options);
  return `${startChar}${JSON.stringify(parsed)}${endChar}`;
};

// src/jsonBlockSchema.ts
import { omit } from "remeda";
import { zodToJsonSchema } from "zod-to-json-schema";
var jsonBlockSchema = (zodSchema) => {
  return JSON.stringify(
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    omit(zodToJsonSchema(zodSchema), ["$schema", "additionalProperties"])
  );
};

// src/jsonBlockPrompt.ts
var jsonBlockPrompt = ({
  name,
  schema,
  examples,
  options
}) => {
  const { startChar, endChar } = getOptions(options);
  const schemaPrompt = jsonBlockSchema(schema);
  const examplePrompts = examples.map(
    (example) => jsonBlockExample({ schema, example, options })
  );
  return `You can respond with a ${name} component by wrapping JSON in ${startChar}${endChar}.
The JSON schema is:
${schemaPrompt}

Examples: 
${examplePrompts.join(`
`)}`;
};
export {
  findCompleteJsonBlock,
  findPartialJsonBlock,
  jsonBlock,
  jsonBlockExample,
  jsonBlockLookBack,
  jsonBlockPrompt,
  jsonBlockSchema,
  parseJson5
};
//# sourceMappingURL=index.js.map