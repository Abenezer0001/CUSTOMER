"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  findCompleteJsonBlock: () => findCompleteJsonBlock,
  findPartialJsonBlock: () => findPartialJsonBlock,
  jsonBlock: () => jsonBlock,
  jsonBlockExample: () => jsonBlockExample,
  jsonBlockLookBack: () => jsonBlockLookBack,
  jsonBlockPrompt: () => jsonBlockPrompt,
  jsonBlockSchema: () => jsonBlockSchema,
  parseJson5: () => parseJson5
});
module.exports = __toCommonJS(src_exports);

// src/lookback.ts
var import_shared = require("@llm-ui/shared");

// src/jsonPathSet.ts
var import_jsonpath_plus = require("jsonpath-plus");
var setJsonPath = (object, path, value) => {
  const result = (0, import_jsonpath_plus.JSONPath)({ path, json: object, resultType: "pointer" });
  if (result.length === 0) {
    throw new Error("Path not found in the object.");
  }
  result.forEach((resultPath) => {
    let parts = resultPath.slice(1).split("/");
    let lastPart = parts.pop();
    let currentObject = object;
    parts.forEach((part) => {
      part = decodeURIComponent(part.replace(/~1/g, "/").replace(/~0/g, "~"));
      if (!(part in currentObject)) {
        throw new Error("Intermediate path not found in the object.");
      }
      currentObject = currentObject[part];
    });
    lastPart = decodeURIComponent(
      lastPart.replace(/~1/g, "/").replace(/~0/g, "~")
    );
    currentObject[lastPart] = value;
  });
};

// src/jsonPathTraverse.ts
var import_jsonpath_plus2 = require("jsonpath-plus");
var traverseLeafNodes = (jsonObject, isPathAllowed, callback) => {
  const traverse = (currentObject, currentPath) => {
    if (currentObject !== null && typeof currentObject === "object") {
      if (!Array.isArray(currentObject) && Object.keys(currentObject).length === 0 || Array.isArray(currentObject) && currentObject.length === 0) {
        if (shouldTraverse(currentPath, true)) {
          callback(currentObject, currentPath);
        }
      } else {
        if (!shouldTraverse(currentPath, false)) {
          return;
        }
        Object.entries(currentObject).forEach(([key, value]) => {
          traverse(
            value,
            `${currentPath}${Array.isArray(currentObject) ? `[${key}]` : `.${key}`}`
          );
        });
      }
    } else {
      if (shouldTraverse(currentPath, true)) {
        callback(currentObject, currentPath);
      }
    }
  };
  const shouldTraverse = (path, isLeaf) => {
    const pathPointer = (0, import_jsonpath_plus2.JSONPath)({
      path,
      json: jsonObject,
      resultType: "pointer"
    });
    return isPathAllowed(pathPointer, jsonObject, isLeaf);
  };
  traverse(jsonObject, "$");
};
var isAllowed = (allowPaths) => (pathPointers, jsonObject, isLeaf) => {
  return !isLeaf || allowPaths.some((allowPath) => {
    const allowPathPointers = (0, import_jsonpath_plus2.JSONPath)({
      path: allowPath,
      json: jsonObject,
      resultType: "pointer"
    });
    return allowPathPointers.some(
      (app) => pathPointers.some((p) => p === app)
    );
  });
};
var isIgnored = (ignorePaths) => (pathPointers, jsonObject) => {
  return !ignorePaths.some((ignorePath) => {
    const ignorePathPointers = (0, import_jsonpath_plus2.JSONPath)({
      path: ignorePath,
      json: jsonObject,
      resultType: "pointer"
    });
    return ignorePathPointers.some(
      (app) => pathPointers.some((p) => p === app)
    );
  });
};

// src/options.ts
var defaultOptions = {
  startChar: "\u3010",
  endChar: "\u3011",
  defaultVisible: false,
  visibleKeyPaths: [],
  invisibleKeyPaths: [],
  typeKey: "type"
};
var getOptions = (userOptions) => {
  if (!userOptions.type) {
    throw new Error("type option is required");
  }
  return { ...defaultOptions, ...userOptions };
};

// src/parseJson5.ts
var import_jsonrepair = require("jsonrepair");
var parseJson5 = (json5) => {
  try {
    return JSON.parse((0, import_jsonrepair.jsonrepair)(json5));
  } catch (e) {
    return void 0;
  }
};

// src/lookback.ts
var jsonBlockLookBack = (userOptions) => {
  const options = getOptions(userOptions);
  const { type, typeKey, defaultVisible, visibleKeyPaths, invisibleKeyPaths } = options;
  return ({ output, visibleTextLengthTarget, isComplete }) => {
    const object = parseJson5((0, import_shared.removeStartEndChars)(output, options));
    if (!object || object[typeKey] !== type) {
      return { output: "", visibleText: "" };
    }
    let remainingChars = visibleTextLengthTarget;
    let visibleText = "";
    const shouldTraverse = defaultVisible ? isIgnored([`$.${typeKey}`, ...invisibleKeyPaths]) : isAllowed(visibleKeyPaths);
    traverseLeafNodes(object, shouldTraverse, (value, path) => {
      if (typeof value === "string") {
        const valueString = `${value}`;
        const chars = Math.min(remainingChars, valueString.length);
        const valueVisible = valueString.slice(0, chars);
        visibleText += valueVisible;
        setJsonPath(object, path, valueVisible);
        remainingChars -= chars;
      }
    });
    const isStreamingKeys = defaultVisible || visibleKeyPaths.length > 0;
    return {
      output: JSON.stringify(object, null, 2),
      visibleText: isStreamingKeys ? visibleText : isComplete && visibleTextLengthTarget > 0 ? " " : ""
    };
  };
};

// src/matchers.ts
var import_shared2 = require("@llm-ui/shared");
var findJsonBlock = (regex, options) => {
  const { type } = options;
  const matcher = (0, import_shared2.regexMatcherGlobal)(regex);
  return (llmOutput) => {
    const matches = matcher(llmOutput);
    if (matches.length === 0) {
      return void 0;
    }
    return matches.find((match) => {
      const block = parseJson5((0, import_shared2.removeStartEndChars)(match.outputRaw, options));
      if (!block || block[options.typeKey] !== type) {
        return void 0;
      }
      return match;
    });
  };
};
var findCompleteJsonBlock = (userOptions) => {
  const options = getOptions(userOptions);
  const { startChar, endChar } = options;
  const regex = new RegExp(`${startChar}([\\s\\S]*?)${endChar}`, "g");
  return findJsonBlock(regex, options);
};
var findPartialJsonBlock = (userOptions) => {
  const options = getOptions(userOptions);
  const { startChar } = options;
  const regex = new RegExp(`${startChar}([\\s\\S]*)`, "g");
  return findJsonBlock(regex, options);
};

// src/block.tsx
var import_jsx_runtime = require("react/jsx-runtime");
var jsonBlock = (options) => {
  return {
    findCompleteMatch: findCompleteJsonBlock(options),
    findPartialMatch: findPartialJsonBlock(options),
    lookBack: jsonBlockLookBack(options),
    component: ({ blockMatch }) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", { href: "https://llm-ui.com/docs/blocks/json", children: "Docs to setup your own component" }),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("pre", { children: blockMatch.output })
    ] })
  };
};

// src/jsonBlockExample.ts
var jsonBlockExample = ({
  schema,
  example,
  options
}) => {
  const parsed = schema.parse(example);
  const { startChar, endChar } = getOptions(options);
  return `${startChar}${JSON.stringify(parsed)}${endChar}`;
};

// src/jsonBlockSchema.ts
var import_remeda = require("remeda");
var import_zod_to_json_schema = require("zod-to-json-schema");
var jsonBlockSchema = (zodSchema) => {
  return JSON.stringify(
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    (0, import_remeda.omit)((0, import_zod_to_json_schema.zodToJsonSchema)(zodSchema), ["$schema", "additionalProperties"])
  );
};

// src/jsonBlockPrompt.ts
var jsonBlockPrompt = ({
  name,
  schema,
  examples,
  options
}) => {
  const { startChar, endChar } = getOptions(options);
  const schemaPrompt = jsonBlockSchema(schema);
  const examplePrompts = examples.map(
    (example) => jsonBlockExample({ schema, example, options })
  );
  return `You can respond with a ${name} component by wrapping JSON in ${startChar}${endChar}.
The JSON schema is:
${schemaPrompt}

Examples: 
${examplePrompts.join(`
`)}`;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  findCompleteJsonBlock,
  findPartialJsonBlock,
  jsonBlock,
  jsonBlockExample,
  jsonBlockLookBack,
  jsonBlockPrompt,
  jsonBlockSchema,
  parseJson5
});
//# sourceMappingURL=index.cjs.map