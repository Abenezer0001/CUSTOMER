{"version":3,"sources":["../src/lookback.ts","../src/jsonPathSet.ts","../src/jsonPathTraverse.ts","../src/options.ts","../src/parseJson5.ts","../src/matchers.ts","../src/block.tsx","../src/jsonBlockExample.ts","../src/jsonBlockSchema.ts","../src/jsonBlockPrompt.ts"],"sourcesContent":["import { LookBackFunction } from \"@llm-ui/react\";\nimport { removeStartEndChars } from \"@llm-ui/shared\";\nimport { setJsonPath } from \"./jsonPathSet\";\nimport { isAllowed, isIgnored, traverseLeafNodes } from \"./jsonPathTraverse\";\nimport { JsonBlockOptions, getOptions } from \"./options\";\nimport { parseJson5 } from \"./parseJson5\";\n\nexport const jsonBlockLookBack = (\n  userOptions: JsonBlockOptions,\n): LookBackFunction => {\n  const options = getOptions(userOptions);\n  const { type, typeKey, defaultVisible, visibleKeyPaths, invisibleKeyPaths } =\n    options;\n  return ({ output, visibleTextLengthTarget, isComplete }) => {\n    const object = parseJson5(removeStartEndChars(output, options));\n    if (!object || object[typeKey] !== type) {\n      return { output: \"\", visibleText: \"\" };\n    }\n    let remainingChars = visibleTextLengthTarget;\n\n    let visibleText = \"\";\n    const shouldTraverse = defaultVisible\n      ? isIgnored([`$.${typeKey}`, ...invisibleKeyPaths])\n      : isAllowed(visibleKeyPaths);\n\n    traverseLeafNodes(object, shouldTraverse, (value, path) => {\n      if (typeof value === \"string\") {\n        const valueString = `${value}`;\n        const chars = Math.min(remainingChars, valueString.length);\n        const valueVisible = valueString.slice(0, chars);\n        visibleText += valueVisible;\n        setJsonPath(object, path, valueVisible);\n        remainingChars -= chars;\n      }\n    });\n\n    const isStreamingKeys = defaultVisible || visibleKeyPaths.length > 0;\n\n    return {\n      output: JSON.stringify(object, null, 2),\n      visibleText: isStreamingKeys\n        ? visibleText\n        : isComplete && visibleTextLengthTarget > 0\n          ? \" \" // Show a space if the block is complete and there is no visible text\n          : \"\",\n    };\n  };\n};\n","import { JSONPath } from \"jsonpath-plus\";\nimport { JsonAny } from \"./types\";\n\n/**\n * Sets the value at a specified JSONPath within a JSON object, assuming the path is to a primitive value.\n *\n * @param object The JSON object to modify.\n * @param path The JSONPath string specifying the leaf path where the value should be set.\n * @param value The value to set at the specified path.\n */\nexport const setJsonPath = (\n  object: JsonAny,\n  path: string,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n): void => {\n  const result = JSONPath({ path: path, json: object, resultType: \"pointer\" });\n\n  if (result.length === 0) {\n    throw new Error(\"Path not found in the object.\");\n  }\n\n  result.forEach((resultPath: string) => {\n    let parts = resultPath.slice(1).split(\"/\");\n    let lastPart = parts.pop()!;\n    let currentObject: JsonAny = object;\n\n    // Traverse to the last object holding the target property\n    parts.forEach((part) => {\n      part = decodeURIComponent(part.replace(/~1/g, \"/\").replace(/~0/g, \"~\")); // Decode JSON Pointer parts\n      if (!(part in currentObject)) {\n        throw new Error(\"Intermediate path not found in the object.\");\n      }\n      currentObject = currentObject[part];\n    });\n\n    lastPart = decodeURIComponent(\n      lastPart.replace(/~1/g, \"/\").replace(/~0/g, \"~\"),\n    ); // Decode JSON Pointer last part\n    currentObject[lastPart] = value;\n  });\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { JSONPath } from \"jsonpath-plus\";\nimport { JsonAny } from \"./types\";\n\nexport type IsPathAllowedFunction = (\n  pathPointers: string[],\n  jsonObject: JsonAny,\n  isLeaf: boolean,\n) => boolean;\n\nexport const traverseLeafNodes = (\n  jsonObject: JsonAny,\n  isPathAllowed: IsPathAllowedFunction,\n  callback: (node: any, path: string) => void,\n): void => {\n  const traverse = (currentObject: JsonAny, currentPath: string) => {\n    if (currentObject !== null && typeof currentObject === \"object\") {\n      // If it's an object or array, continue traversing\n      if (\n        (!Array.isArray(currentObject) &&\n          Object.keys(currentObject).length === 0) ||\n        (Array.isArray(currentObject) && currentObject.length === 0)\n      ) {\n        // Empty object or array, treat as a leaf\n        if (shouldTraverse(currentPath, true)) {\n          callback(currentObject, currentPath);\n        }\n      } else {\n        if (!shouldTraverse(currentPath, false)) {\n          return; // Skip this path if it's meant to be ignored\n        }\n        Object.entries(currentObject).forEach(([key, value]) => {\n          traverse(\n            value,\n            `${currentPath}${Array.isArray(currentObject) ? `[${key}]` : `.${key}`}`,\n          );\n        });\n      }\n    } else {\n      // Current object is a leaf (primitive or null)\n      if (shouldTraverse(currentPath, true)) {\n        callback(currentObject, currentPath);\n      }\n    }\n  };\n\n  const shouldTraverse = (path: string, isLeaf: boolean) => {\n    const pathPointer: string[] = JSONPath({\n      path: path,\n      json: jsonObject,\n      resultType: \"pointer\",\n    });\n    return isPathAllowed(pathPointer, jsonObject, isLeaf);\n  };\n\n  traverse(jsonObject, \"$\"); // Start from the root\n};\n\nexport const isAllowed =\n  (allowPaths: string[]) =>\n  (pathPointers: string[], jsonObject: JsonAny, isLeaf: boolean) => {\n    return (\n      !isLeaf ||\n      allowPaths.some((allowPath) => {\n        const allowPathPointers = JSONPath({\n          path: allowPath,\n          json: jsonObject,\n          resultType: \"pointer\",\n        });\n        return allowPathPointers.some((app: any) =>\n          pathPointers.some((p) => p === app),\n        );\n      })\n    );\n  };\n\nexport const isIgnored =\n  (ignorePaths: string[]) => (pathPointers: string[], jsonObject: JsonAny) => {\n    return !ignorePaths.some((ignorePath) => {\n      const ignorePathPointers = JSONPath({\n        path: ignorePath,\n        json: jsonObject,\n        resultType: \"pointer\",\n      });\n      return ignorePathPointers.some((app: any) =>\n        pathPointers.some((p) => p === app),\n      );\n    });\n  };\n","export type JsonBlockOptionsComplete = {\n  type: string;\n  startChar: string;\n  endChar: string;\n  defaultVisible: boolean;\n  visibleKeyPaths: string[];\n  invisibleKeyPaths: string[];\n  typeKey: string;\n};\n\nexport const defaultOptions: Omit<JsonBlockOptionsComplete, \"type\"> = {\n  startChar: \"【\",\n  endChar: \"】\",\n  defaultVisible: false,\n  visibleKeyPaths: [],\n  invisibleKeyPaths: [],\n  typeKey: \"type\",\n};\n\nexport type JsonBlockOptions = Partial<Omit<JsonBlockOptionsComplete, \"type\">> &\n  Pick<JsonBlockOptionsComplete, \"type\">;\n\nexport const getOptions = (\n  userOptions: JsonBlockOptions,\n): JsonBlockOptionsComplete => {\n  if (!userOptions.type) {\n    throw new Error(\"type option is required\");\n  }\n  return { ...defaultOptions, ...userOptions };\n};\n","import { jsonrepair } from \"jsonrepair\";\n\nexport const parseJson5 = (json5: string) => {\n  try {\n    return JSON.parse(jsonrepair(json5));\n  } catch (e) {\n    return undefined;\n  }\n};\n","import { LLMOutputMatcher } from \"@llm-ui/react\";\nimport { regexMatcherGlobal, removeStartEndChars } from \"@llm-ui/shared\";\nimport {\n  JsonBlockOptions,\n  JsonBlockOptionsComplete,\n  getOptions,\n} from \"./options\";\nimport { parseJson5 } from \"./parseJson5\";\n\nconst findJsonBlock = (\n  regex: RegExp,\n  options: JsonBlockOptionsComplete,\n): LLMOutputMatcher => {\n  const { type } = options;\n  const matcher = regexMatcherGlobal(regex);\n  return (llmOutput: string) => {\n    const matches = matcher(llmOutput);\n    if (matches.length === 0) {\n      return undefined;\n    }\n    return matches.find((match) => {\n      const block = parseJson5(removeStartEndChars(match.outputRaw, options));\n\n      if (!block || block[options.typeKey] !== type) {\n        return undefined;\n      }\n      return match;\n    });\n  };\n};\n\nexport const findCompleteJsonBlock = (\n  userOptions: JsonBlockOptions,\n): LLMOutputMatcher => {\n  const options = getOptions(userOptions);\n  const { startChar, endChar } = options;\n  const regex = new RegExp(`${startChar}([\\\\s\\\\S]*?)${endChar}`, \"g\");\n  return findJsonBlock(regex, options);\n};\n\nexport const findPartialJsonBlock = (\n  userOptions: JsonBlockOptions,\n): LLMOutputMatcher => {\n  const options = getOptions(userOptions);\n  const { startChar } = options;\n  const regex = new RegExp(`${startChar}([\\\\s\\\\S]*)`, \"g\");\n  return findJsonBlock(regex, options);\n};\n","import { LLMOutputBlock } from \"@llm-ui/react\";\nimport { jsonBlockLookBack } from \"./lookback\";\nimport { findCompleteJsonBlock, findPartialJsonBlock } from \"./matchers\";\nimport { JsonBlockOptions } from \"./options\";\n\nexport const jsonBlock = (options: JsonBlockOptions): LLMOutputBlock => {\n  return {\n    findCompleteMatch: findCompleteJsonBlock(options),\n    findPartialMatch: findPartialJsonBlock(options),\n    lookBack: jsonBlockLookBack(options),\n    component: ({ blockMatch }) => (\n      <div>\n        <a href=\"https://llm-ui.com/docs/blocks/json\">\n          Docs to setup your own component\n        </a>\n        <pre>{blockMatch.output}</pre>\n      </div>\n    ),\n  };\n};\n","import z, { ZodSchema, ZodTypeAny } from \"zod\";\nimport { JsonBlockOptions, getOptions } from \"./options\";\n\nexport const jsonBlockExample = <\n  Schema extends ZodTypeAny = ZodSchema<undefined>,\n>({\n  schema,\n  example,\n  options,\n}: {\n  schema: Schema;\n  example: z.infer<Schema>;\n  options: JsonBlockOptions;\n}): string => {\n  // throw if example does not match schema\n  const parsed = schema.parse(example);\n  const { startChar, endChar } = getOptions(options);\n  return `${startChar}${JSON.stringify(parsed)}${endChar}`;\n};\n","import { omit } from \"remeda\";\nimport { ZodSchema } from \"zod\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\n\nexport const jsonBlockSchema = (zodSchema: ZodSchema): string => {\n  return JSON.stringify(\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-expect-error\n    omit(zodToJsonSchema(zodSchema), [\"$schema\", \"additionalProperties\"]),\n  );\n};\n","import z, { ZodSchema, ZodTypeAny } from \"zod\";\nimport { jsonBlockExample } from \"./jsonBlockExample\";\nimport { jsonBlockSchema } from \"./jsonBlockSchema\";\nimport { JsonBlockOptions, getOptions } from \"./options\";\n\nexport const jsonBlockPrompt = <\n  Schema extends ZodTypeAny = ZodSchema<undefined>,\n>({\n  name,\n  schema,\n  examples,\n  options,\n}: {\n  name: string;\n  schema: Schema;\n  examples: z.infer<Schema>[];\n  options: JsonBlockOptions;\n}): string => {\n  const { startChar, endChar } = getOptions(options);\n  const schemaPrompt = jsonBlockSchema(schema);\n  const examplePrompts = examples.map((example) =>\n    jsonBlockExample({ schema, example, options }),\n  );\n  return `You can respond with a ${name} component by wrapping JSON in ${startChar}${endChar}.\\nThe JSON schema is:\\n${schemaPrompt}\\n\\nExamples: \\n${examplePrompts.join(`\\n`)}`;\n};\n"],"mappings":"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","names":["JSONPath","removeStartEndChars","removeStartEndChars"]}