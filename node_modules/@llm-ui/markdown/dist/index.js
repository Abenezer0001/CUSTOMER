// src/markdownParser.ts
import { fromMarkdown } from "mdast-util-from-markdown";
import { gfmFromMarkdown, gfmToMarkdown } from "mdast-util-gfm";
import { toMarkdown } from "mdast-util-to-markdown";
import { gfm } from "micromark-extension-gfm";
import { isDeepEqual } from "remeda";
import { visit } from "unist-util-visit";
var ZERO_WIDTH_SPACE = "\u200B";
var ENCLOSING_START_REGEX = /(\*{1,3}|(^|\s|\n)_{1,3}|~{1,3})(\S|$)/;
var LINK_REGEX = /(\[$|\[[^\]]+$|\[[^\]]+\]$|\[[^\]]+\]\(.*$)/;
var isEmptyList = (list) => {
  return list.children.length === 1 && list.children[0].type === "listItem" && list.children[0].children.length === 0;
};
var isListCharacterLength = (list, length) => {
  return Boolean(
    list.position && list.position.start.line === list.position.end.line && list.position.end.column && list.position.start.column && list.position.end.column - list.position.start.column === length
  );
};
var markdownToAst = (markdown) => {
  return fromMarkdown(markdown, {
    extensions: [gfm()],
    mdastExtensions: [gfmFromMarkdown()]
  });
};
var astToMarkdown = (markdownAst) => {
  preserveWhitespaceInAst(markdownAst);
  return toMarkdown(markdownAst, { extensions: [gfmToMarkdown()] });
};
var afterLastNewline = (markdown) => {
  const lastNewlineIndex = markdown.lastIndexOf("\n");
  return markdown.slice(lastNewlineIndex + 1);
};
var addZeroWidthSpaceAfterTrailingWhitespace = (text) => {
  return text.replace(/ $/, ` ${ZERO_WIDTH_SPACE}`);
};
var removeZeroWidthSpaces = (text) => {
  return text.replaceAll(ZERO_WIDTH_SPACE, "");
};
var preserveWhitespaceInAst = (root) => {
  visit(root, "text", (node, index, parent) => {
    if (parent && ["emphasis", "strong", "delete"].includes(parent.type)) {
      const indexWithinParent = parent.children.findIndex((n) => {
        return isDeepEqual(n.position, node.position);
      });
      const isLastChild = indexWithinParent === parent.children.length - 1;
      if (isLastChild) {
        node.value = addZeroWidthSpaceAfterTrailingWhitespace(node.value);
      }
    }
  });
  return root;
};
var removeRegexesFromParagraph = (root, paragraph, regexes) => {
  regexes.forEach((regex) => {
    if (removeRegexFromParagraph(root, paragraph, regex)) {
      return;
    }
  });
};
var removeRegexFromParagraph = (root, paragraph, regex) => {
  const partialAmbiguousEnclosingSymbolsIndex = paragraph.children.findIndex(
    (child) => {
      return child.type === "text" && regex.test(afterLastNewline(child.value));
    }
  );
  if (partialAmbiguousEnclosingSymbolsIndex !== -1) {
    const match = paragraph.children[partialAmbiguousEnclosingSymbolsIndex];
    const matchText = match.value;
    const matchIndex = regex.exec(matchText).index;
    if (matchIndex > 0) {
      paragraph.children[partialAmbiguousEnclosingSymbolsIndex] = {
        type: "text",
        value: matchText.slice(0, matchIndex)
      };
      paragraph.children.splice(partialAmbiguousEnclosingSymbolsIndex + 1);
    } else {
      paragraph.children.splice(partialAmbiguousEnclosingSymbolsIndex);
    }
    if (paragraph.children.length === 0) {
      root.children.splice(-1);
    }
  }
  return partialAmbiguousEnclosingSymbolsIndex !== -1;
};
var removePartialAmbiguousMarkdownFromAst = (root) => {
  if (root.children.length === 0) {
    return;
  }
  const lastChild = root.children[root.children.length - 1];
  if (lastChild.type === "paragraph") {
    removeRegexesFromParagraph(root, lastChild, [
      ENCLOSING_START_REGEX,
      LINK_REGEX
    ]);
  } else if (
    // if there is an empty list item at the end, remove it
    lastChild.type === "list" && isEmptyList(lastChild) && isListCharacterLength(lastChild, 1)
  ) {
    root.children.splice(-1);
  } else if (lastChild.type === "thematicBreak") {
    root.children.splice(-1);
  }
};
var THEMATIC_BREAK_VISIBLE = "_";
var LIST_ITEM_VISIBLE = "*";
var markdownAstToVisibleTextHelper = (markdownAst) => {
  return markdownAst.children.map((child) => {
    if (child.type === "text") {
      return child.value;
    }
    if (child.type === "inlineCode") {
      return child.value;
    }
    if (child.type === "thematicBreak") {
      return THEMATIC_BREAK_VISIBLE;
    }
    if (child.type === "heading") {
      return markdownAstToVisibleTextHelper(child);
    }
    if (child.type === "paragraph") {
      return markdownAstToVisibleTextHelper(child);
    }
    if (child.type === "listItem") {
      return LIST_ITEM_VISIBLE + markdownAstToVisibleTextHelper(child);
    }
    if ("children" in child) {
      return markdownAstToVisibleTextHelper(child);
    }
    return "";
  }).join("");
};
var markdownAstToVisibleText = (markdownAst, isFinished) => {
  if (!isFinished) {
    removePartialAmbiguousMarkdownFromAst(markdownAst);
  }
  return removeZeroWidthSpaces(
    markdownAstToVisibleTextHelper(markdownAst)
  ).replaceAll("\n", "");
};
var markdownToVisibleText = (markdown, isFinished) => {
  const markdownAst = markdownToAst(markdown);
  return markdownAstToVisibleText(markdownAst, isFinished);
};
var removeVisibleCharsFromAstHelper = (node, visibleCharsToRemove) => {
  if (node.type === "text" || node.type === "inlineCode") {
    if (node.value.length <= visibleCharsToRemove) {
      return { charsRemoved: node.value.length, toDelete: true };
    } else {
      node.value = node.value.slice(0, -1 * visibleCharsToRemove);
      return { charsRemoved: visibleCharsToRemove, toDelete: false };
    }
  }
  if (node.type === "thematicBreak") {
    return { charsRemoved: THEMATIC_BREAK_VISIBLE.length, toDelete: true };
  }
  let removedCharsCount = 0;
  if ("children" in node) {
    let index = node.children.length - 1;
    while (index >= 0 && removedCharsCount < visibleCharsToRemove) {
      const child = node.children[index];
      const { charsRemoved, toDelete } = removeVisibleCharsFromAstHelper(
        child,
        visibleCharsToRemove - removedCharsCount
      );
      removedCharsCount += charsRemoved;
      if (toDelete) {
        node.children.splice(index, 1);
      }
      index--;
    }
    if (node.type === "listItem") {
      const shouldDeleteListItem = node.children.length === 0 && visibleCharsToRemove - removedCharsCount > 0;
      return {
        charsRemoved: removedCharsCount + (shouldDeleteListItem ? LIST_ITEM_VISIBLE.length : 0),
        toDelete: shouldDeleteListItem
      };
    }
    return {
      charsRemoved: removedCharsCount,
      toDelete: node.children.length === 0
    };
  }
  return { charsRemoved: 0, toDelete: false };
};
var removeVisibleCharsFromAst = (node, visibleCharsToRemove) => {
  const { toDelete } = removeVisibleCharsFromAstHelper(
    node,
    visibleCharsToRemove
  );
  if (toDelete) {
    node.children = [];
  }
};
var markdownWithVisibleChars = (markdown, visibleChars, isFinished) => {
  const markdownAst = markdownToAst(markdown);
  if (!isFinished) {
    removePartialAmbiguousMarkdownFromAst(markdownAst);
  }
  const visibleText = markdownAstToVisibleText(markdownAst, isFinished);
  const charsToRemove = visibleText.length - visibleChars;
  removeVisibleCharsFromAst(markdownAst, charsToRemove);
  return astToMarkdown(markdownAst);
};

// src/lookBack.ts
var markdownLookBack = () => ({
  output: completeLlmOutput,
  visibleTextLengthTarget,
  isStreamFinished
}) => {
  const output = markdownWithVisibleChars(
    completeLlmOutput,
    visibleTextLengthTarget,
    isStreamFinished
  );
  const visibleText = markdownToVisibleText(output, isStreamFinished);
  return {
    output,
    visibleText
  };
};
export {
  markdownLookBack
};
//# sourceMappingURL=index.js.map