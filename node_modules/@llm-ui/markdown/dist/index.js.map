{"version":3,"sources":["../src/markdownParser.ts","../src/lookBack.ts"],"sourcesContent":["import { List, Paragraph, Parent, Root, RootContent, Text } from \"mdast\";\nimport { fromMarkdown } from \"mdast-util-from-markdown\";\nimport { gfmFromMarkdown, gfmToMarkdown } from \"mdast-util-gfm\";\nimport { toMarkdown } from \"mdast-util-to-markdown\";\nimport { gfm } from \"micromark-extension-gfm\";\nimport { isDeepEqual } from \"remeda\";\nimport { visit } from \"unist-util-visit\";\n\nexport const ZERO_WIDTH_SPACE = \"\\u200b\";\n\n// enclosing symbols: _a_ __a__ *a* **a** ~a~ ~~a~~\n// _'s behave differently to * and ~.\nconst ENCLOSING_START_REGEX = /(\\*{1,3}|(^|\\s|\\n)_{1,3}|~{1,3})(\\S|$)/;\n\n// Matches:\n// [\n// [a\n// [ab]\n// [ab](\n// [abc](ht\n// [abc](https://\n// [abc](https://a.com\n// [abc](https://a.com)\nconst LINK_REGEX = /(\\[$|\\[[^\\]]+$|\\[[^\\]]+\\]$|\\[[^\\]]+\\]\\(.*$)/;\n\nconst isEmptyList = (list: List): boolean => {\n  return (\n    list.children.length === 1 &&\n    list.children[0].type === \"listItem\" &&\n    list.children[0].children.length === 0\n  );\n};\n\nconst isListCharacterLength = (list: List, length: number): boolean => {\n  return Boolean(\n    list.position &&\n      list.position.start.line === list.position.end.line &&\n      list.position.end.column &&\n      list.position.start.column &&\n      list.position.end.column - list.position.start.column === length,\n  );\n};\n\nconst markdownToAst = (markdown: string): Root => {\n  return fromMarkdown(markdown, {\n    extensions: [gfm()],\n    mdastExtensions: [gfmFromMarkdown()],\n  });\n};\n\nconst astToMarkdown = (markdownAst: Root): string => {\n  preserveWhitespaceInAst(markdownAst);\n  return toMarkdown(markdownAst, { extensions: [gfmToMarkdown()] });\n};\n\nconst afterLastNewline = (markdown: string): string => {\n  const lastNewlineIndex = markdown.lastIndexOf(\"\\n\");\n  return markdown.slice(lastNewlineIndex + 1);\n};\n\nconst addZeroWidthSpaceAfterTrailingWhitespace = (text: string): string => {\n  return text.replace(/ $/, ` ${ZERO_WIDTH_SPACE}`);\n};\n\nconst removeZeroWidthSpaces = (text: string): string => {\n  return text.replaceAll(ZERO_WIDTH_SPACE, \"\");\n};\n\nconst preserveWhitespaceInAst = (root: Root): Root => {\n  visit(root, \"text\", (node, index, parent) => {\n    if (parent && [\"emphasis\", \"strong\", \"delete\"].includes(parent.type)) {\n      const indexWithinParent = parent.children.findIndex((n) => {\n        return isDeepEqual(n.position, node.position);\n      });\n      const isLastChild = indexWithinParent === parent.children.length - 1;\n      if (isLastChild) {\n        node.value = addZeroWidthSpaceAfterTrailingWhitespace(node.value);\n      }\n    }\n  });\n  return root;\n};\n\nconst removeRegexesFromParagraph = (\n  root: Root,\n  paragraph: Paragraph,\n  regexes: RegExp[],\n) => {\n  regexes.forEach((regex) => {\n    if (removeRegexFromParagraph(root, paragraph, regex)) {\n      return;\n    }\n  });\n};\n\nconst removeRegexFromParagraph = (\n  root: Root,\n  paragraph: Paragraph,\n  regex: RegExp,\n): boolean => {\n  const partialAmbiguousEnclosingSymbolsIndex = paragraph.children.findIndex(\n    (child) => {\n      return child.type === \"text\" && regex.test(afterLastNewline(child.value));\n    },\n  );\n  if (partialAmbiguousEnclosingSymbolsIndex !== -1) {\n    const match = paragraph.children[\n      partialAmbiguousEnclosingSymbolsIndex\n    ] as Text;\n    const matchText = match.value;\n    const matchIndex = regex.exec(matchText)!.index;\n\n    if (matchIndex > 0) {\n      paragraph.children[partialAmbiguousEnclosingSymbolsIndex] = {\n        type: \"text\",\n        value: matchText.slice(0, matchIndex),\n      };\n      paragraph.children.splice(partialAmbiguousEnclosingSymbolsIndex + 1); // keep the updated text node, remove the rest\n    } else {\n      paragraph.children.splice(partialAmbiguousEnclosingSymbolsIndex); // delete the text node and the rest\n    }\n    // remove the 'lastChild' if it no longer has any children\n    if (paragraph.children.length === 0) {\n      root.children.splice(-1);\n    }\n  }\n  return partialAmbiguousEnclosingSymbolsIndex !== -1;\n};\n\n// mutates the ast\nconst removePartialAmbiguousMarkdownFromAst = (root: Root): void => {\n  if (root.children.length === 0) {\n    return;\n  }\n  const lastChild = root.children[root.children.length - 1];\n  if (lastChild.type === \"paragraph\") {\n    removeRegexesFromParagraph(root, lastChild, [\n      ENCLOSING_START_REGEX,\n      LINK_REGEX,\n    ]);\n  } else if (\n    // if there is an empty list item at the end, remove it\n    lastChild.type === \"list\" &&\n    isEmptyList(lastChild) &&\n    isListCharacterLength(lastChild, 1) // '*' is deleted, '* ' is not deleted.\n  ) {\n    root.children.splice(-1);\n  } else if (lastChild.type === \"thematicBreak\") {\n    root.children.splice(-1);\n  }\n};\n\nexport const removePartialAmbiguousMarkdown = (markdown: string): string => {\n  const markdownAst = markdownToAst(markdown);\n  removePartialAmbiguousMarkdownFromAst(markdownAst);\n  return astToMarkdown(markdownAst);\n};\n\ntype WithChildren<T> = T extends Parent ? T : never;\n\ntype RootContentWithChildren = WithChildren<RootContent> | Root;\n\nconst THEMATIC_BREAK_VISIBLE = \"_\";\nconst LIST_ITEM_VISIBLE = \"*\";\n\nconst markdownAstToVisibleTextHelper = (\n  markdownAst: RootContentWithChildren,\n): string => {\n  return markdownAst.children\n    .map((child) => {\n      if (child.type === \"text\") {\n        return child.value;\n      }\n      if (child.type === \"inlineCode\") {\n        return child.value;\n      }\n      if (child.type === \"thematicBreak\") {\n        return THEMATIC_BREAK_VISIBLE;\n      }\n      if (child.type === \"heading\") {\n        return markdownAstToVisibleTextHelper(child);\n      }\n\n      if (child.type === \"paragraph\") {\n        return markdownAstToVisibleTextHelper(child);\n      }\n\n      if (child.type === \"listItem\") {\n        return LIST_ITEM_VISIBLE + markdownAstToVisibleTextHelper(child);\n      }\n      if (\"children\" in child) {\n        return markdownAstToVisibleTextHelper(child);\n      }\n      return \"\";\n    })\n    .join(\"\");\n};\n\nconst markdownAstToVisibleText = (markdownAst: Root, isFinished: boolean) => {\n  if (!isFinished) {\n    removePartialAmbiguousMarkdownFromAst(markdownAst);\n  }\n  return removeZeroWidthSpaces(\n    markdownAstToVisibleTextHelper(markdownAst),\n  ).replaceAll(\"\\n\", \"\");\n  // mdast is not reliable with \\n so we remove them all\n};\n\nexport const markdownToVisibleText = (\n  markdown: string,\n  isFinished: boolean,\n): string => {\n  const markdownAst = markdownToAst(markdown);\n  return markdownAstToVisibleText(markdownAst, isFinished);\n};\n\nconst removeVisibleCharsFromAstHelper = (\n  node: RootContent | Root,\n  visibleCharsToRemove: number,\n): { charsRemoved: number; toDelete: boolean } => {\n  if (node.type === \"text\" || node.type === \"inlineCode\") {\n    if (node.value.length <= visibleCharsToRemove) {\n      return { charsRemoved: node.value.length, toDelete: true };\n    } else {\n      node.value = node.value.slice(0, -1 * visibleCharsToRemove);\n      return { charsRemoved: visibleCharsToRemove, toDelete: false };\n    }\n  }\n  if (node.type === \"thematicBreak\") {\n    return { charsRemoved: THEMATIC_BREAK_VISIBLE.length, toDelete: true };\n  }\n\n  let removedCharsCount = 0;\n  if (\"children\" in node) {\n    // traverse children right to left\n    let index = node.children.length - 1;\n    while (index >= 0 && removedCharsCount < visibleCharsToRemove) {\n      const child = node.children[index];\n\n      const { charsRemoved, toDelete } = removeVisibleCharsFromAstHelper(\n        child,\n        visibleCharsToRemove - removedCharsCount,\n      );\n      removedCharsCount += charsRemoved;\n      if (toDelete) {\n        node.children.splice(index, 1); // delete the child\n      }\n      index--;\n    }\n\n    if (node.type === \"listItem\") {\n      const shouldDeleteListItem =\n        node.children.length === 0 &&\n        visibleCharsToRemove - removedCharsCount > 0;\n      return {\n        charsRemoved:\n          removedCharsCount +\n          (shouldDeleteListItem ? LIST_ITEM_VISIBLE.length : 0),\n        toDelete: shouldDeleteListItem,\n      };\n    }\n\n    return {\n      charsRemoved: removedCharsCount,\n      toDelete: node.children.length === 0,\n    };\n  }\n\n  return { charsRemoved: 0, toDelete: false };\n};\n\nconst removeVisibleCharsFromAst = (\n  node: Root,\n  visibleCharsToRemove: number,\n): void => {\n  const { toDelete } = removeVisibleCharsFromAstHelper(\n    node,\n    visibleCharsToRemove,\n  );\n\n  if (toDelete) {\n    node.children = [];\n  }\n};\n\nexport const markdownWithVisibleChars = (\n  markdown: string,\n  visibleChars: number,\n  isFinished: boolean,\n): string => {\n  const markdownAst = markdownToAst(markdown);\n  if (!isFinished) {\n    removePartialAmbiguousMarkdownFromAst(markdownAst);\n  }\n  const visibleText = markdownAstToVisibleText(markdownAst, isFinished);\n  const charsToRemove = visibleText.length - visibleChars;\n  removeVisibleCharsFromAst(markdownAst, charsToRemove);\n  return astToMarkdown(markdownAst);\n};\n","import { LookBackFunction } from \"@llm-ui/react\";\nimport {\n  markdownToVisibleText,\n  markdownWithVisibleChars,\n} from \"./markdownParser\";\n\nexport const markdownLookBack: () => LookBackFunction =\n  () =>\n  ({\n    output: completeLlmOutput,\n    visibleTextLengthTarget,\n    isStreamFinished,\n  }) => {\n    const output = markdownWithVisibleChars(\n      completeLlmOutput,\n      visibleTextLengthTarget,\n      isStreamFinished,\n    );\n    const visibleText = markdownToVisibleText(output, isStreamFinished);\n    return {\n      output,\n      visibleText,\n    };\n  };\n"],"mappings":"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","names":[]}