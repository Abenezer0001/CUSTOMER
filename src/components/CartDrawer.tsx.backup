import React, { useState, useEffect } from 'react';
import { API_BASE_URL } from '@/constants';
import { useCart } from '@/context/CartContext';
import { useOrders } from '@/context/OrdersContext';
import { useAuth } from '@/hooks/useAuth';
import authService from '@/api/authService';
import apiClient from '@/api/apiClient';
import { useTableInfo } from '@/context/TableContext';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { 
  Trash2, Plus, Minus, X, ArrowRight, 
  Loader2, CreditCard, AlertCircle, Info 
} from 'lucide-react';
import { toast } from 'sonner';
import { cn } from '@/lib/utils';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Sheet, SheetContent, SheetHeader, SheetTitle } from '@/components/ui/sheet';
import { createOrder, OrderResponseData } from '@/api/orderService'; 
import { createStripeCheckoutSession } from '@/api/paymentService';
import { useNavigate } from 'react-router-dom';
import type { Order } from '@/types'; 

// Order type enum to match API
enum OrderType {
  DINE_IN = 'DINE_IN',
  TAKEOUT = 'TAKEOUT'
}

// Order status enum to match API
enum OrderStatus {
  PENDING = 'PENDING',
  PREPARING = 'PREPARING',
  READY = 'READY',
  DELIVERED = 'DELIVERED',
  COMPLETED = 'COMPLETED',
  CANCELLED = 'CANCELLED'
}

// Payment status enum to match API
enum PaymentStatus {
  PENDING = 'PENDING',
  PROCESSING = 'PROCESSING',
  PAID = 'PAID',
  FAILED = 'FAILED',
  REFUNDED = 'REFUNDED'
}

interface CartItem {
  id: string;
  menuItemId?: string; // Make it optional since it might not always be present
  name: string;
  price: number;
  quantity: number;
  specialInstructions?: string;
  modifiers?: Array<{ id: string, name: string, price: number }>;
  image?: string;
}

interface OrderData {
  restaurantId: string;
  tableId: string;
  items: Array<{
    menuItem: string;
    name: string;
    quantity: number;
    price: number;
    subtotal: number;
    specialInstructions: string;
    modifiers?: Array<{ name: string, price: number }>; 
  }>;
  subtotal: number;
  tax: number;
  tip: number;
  total: number;
  orderType: OrderType;
  specialInstructions: string;
  serviceFee: number;
  status: OrderStatus;
  paymentStatus: PaymentStatus;
  orderNumber: string;
}

interface CartDrawerProps {
  isOpen: boolean;
  onClose: () => void;
}

const CartDrawer: React.FC<CartDrawerProps> = ({ isOpen, onClose }) => {
  const { cartItems, removeFromCart: removeItem, updateQuantity, clearCart, cartTotal: subtotal } = useCart();
  const { tableId, restaurantName } = useTableInfo();
  const { isAuthenticated, token } = useAuth();
  const { addOrder } = useOrders();
  const navigate = useNavigate();
  
  // Handle guest login
  const handleGuestLogin = React.useCallback(async (tableId: string) => {
  try {
    // Use XMLHttpRequest which might handle CORS differently than fetch
    console.log('Using XMLHttpRequest for order creation...');
    
    const result = await new Promise<OrderResponseData>((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      const orderApiUrl = import.meta.env.VITE_ORDER_API_URL || 'https://api.inseat.achievengine.com/api/orders';
      xhr.open('POST', orderApiUrl, true);
      xhr.withCredentials = true;
      xhr.setRequestHeader('Content-Type', 'application/json');
      
      if (token) {
        xhr.setRequestHeader('Authorization', `Bearer ${token}`);
        console.log('Added Authorization header with token');
      }
      
      xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 300) {
          const parsedResponse = JSON.parse(xhr.responseText);
          if (parsedResponse._id) {
            resolve(parsedResponse);
          } else if (parsedResponse.success) {
            resolve(parsedResponse.data);
          } else {
            reject(new Error(parsedResponse.error?.message || 'Order creation failed'));
          }
        } else {
          reject(new Error(`Order creation failed with status: ${xhr.status}`));
        }
      };
      
      xhr.onerror = () => reject(new Error('Network error occurred'));
      xhr.send(JSON.stringify(constructedOrderData));
    });
    
    console.log('Order created successfully:', result);
    
    const orderForContext: Order = {
      id: result._id,
      orderNumber: result.orderNumber,
      items: result.items.map(apiItem => ({
        id: apiItem.menuItem,
        menuItemId: apiItem.menuItem,
        name: apiItem.name,
        price: apiItem.price,
        quantity: apiItem.quantity,
        specialInstructions: apiItem.specialInstructions,
        modifiers: apiItem.modifiers?.map(mod => ({ id: mod.name, name: mod.name, price: mod.price })) || []
      })),
      subtotal: result.subtotal,
      tax: result.tax,
      serviceFee: result.serviceFee,
      tip: result.tip,
      total: result.total,
      status: result.status,
      paymentStatus: result.paymentStatus,
      timestamp: new Date(result.createdAt),
      tableId: result.tableId,
      specialInstructions: result.specialInstructions
    };
    
    addOrder(orderForContext);
    localStorage.setItem('pending_order_id', result._id);
    clearCart();
    onClose();
    
    toast.success('Order placed successfully!');
    
    setTimeout(() => {
      navigate(`/my-orders?table=${tableId}`);
    }, 1000);
  } catch (error) {
    console.error('Error in order creation process:', error);
    toast.error(error instanceof Error ? error.message : 'Failed to create your order');
    setIsProcessing(false);
    setError(error instanceof Error ? error.message : 'Failed to create your order');
    throw error;
  }
      console.error('Error in order creation process:', orderError);
      toast.error(orderError instanceof Error ? orderError.message : 'Failed to create your order');
      setIsProcessing(false);
      setError(orderError instanceof Error ? orderError.message : 'Failed to create your order');
      throw orderError; // Re-throw to be caught by the caller
    }
  };

  // Handle guest login
  const handleGuestLogin = React.useCallback(async (tableId: string) => {
