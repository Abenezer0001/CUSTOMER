This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
attached_assets/
  Pasted-Okay-here-s-the-refined-prompt-taking-into-account-your-feedback-and-the-backend-details-Promp-1743595660300.txt
docs/
  backend-enhancements.md
  menu-integration-summary.md
  order-api-tests.md
  order-endpoints.md
  table-menu-integration-guide.md
public/
  data/
  placeholder.svg
scripts/
  migrateMenuData.ts
src/
  api/
    __tests__/
      menuService.test.ts
    services/
    apiClient.ts
    authService.ts
    customerAuthService.ts
    db.js
    menuService.ts
    orderService.ts
    paymentService.ts
    README.md
    stripeService.ts
    tableService.ts
    test-order-auth.js
  assets/
  components/
    home/
      HeroSlider.tsx
    menu/
      MenuGrid.tsx
      MenuItemCard.tsx
      MenuItemCardSkeleton.tsx
    MenuContainer/
    shared/
      SharedImage.tsx
    ui/
      accordion.tsx
      alert-dialog.tsx
      alert.tsx
      aspect-ratio.tsx
      avatar.tsx
      badge.tsx
      breadcrumb.tsx
      button.tsx
      calendar.tsx
      card.tsx
      carousel.tsx
      chart.tsx
      checkbox.tsx
      collapsible.tsx
      command.tsx
      context-menu.tsx
      dialog.tsx
      dock.tsx
      drawer.tsx
      dropdown-menu.tsx
      form.tsx
      hover-card.tsx
      input-otp.tsx
      input.tsx
      label.tsx
      loader.tsx
      menubar.tsx
      navigation-menu.tsx
      pagination.tsx
      popover.tsx
      progress.tsx
      radio-group.tsx
      resizable.tsx
      scroll-area.tsx
      Section.tsx
      select.tsx
      separator.tsx
      sheet.tsx
      sidebar.tsx
      skeleton.tsx
      slider.tsx
      sonner.tsx
      spinner.tsx
      switch.tsx
      table.tsx
      tabs.tsx
      textarea.tsx
      toast.tsx
      toaster.tsx
      toggle-group.tsx
      toggle.tsx
      tooltip.tsx
      use-toast.ts
    AIChatDrawer.tsx
    BottomNav.tsx
    CartDrawer.tsx
    CartDrawer.tsx.backup
    CartDrawer.tsx.temp
    CartDrawer.tsx.tmp
    CartDrawer.tsx.tmp2
    CartDrawer.tsx.tmp3
    CartDrawer.tsx.ui-part
    CategoryFilter.tsx
    CategoryGrid.tsx
    DemoNotification.tsx
    Footer.tsx
    ItemDetailDialog.tsx.backup
    ItemDetailDrawer.tsx
    MenuCategoryList.tsx
    MenuItemCard.tsx
    MenuItemComponent.tsx
    MenuItemComponent.tsx.backup
    MenuItemList.tsx
    MenuSubcategoryList.tsx
    Navbar.tsx
    ProtectedRoute.tsx
    QRScanner.tsx
    SplashScreen.tsx
    TableHeader.tsx
    TableHeader.tsx.backup
    ThemeToggler.tsx
  config/
    api.ts
    constants.ts
  constants/
    index.ts
  context/
    AuthContext.tsx
    CartContext.tsx
    FavoritesContext.tsx
    OrderContext.tsx
    OrdersContext.tsx
    TableContext.tsx
  data/
    orders/
      .gitkeep
    restaurants/
      .gitkeep
    users/
      .gitkeep
      users.json
    categories-data.json
    combined-menu-items-fixed.json
    combined-menu-items.json
    menu-data.json
    menu-items-complete-final.json
    menu-items-complete-part2.json
    menu-items-complete-part3.json
    menu-items-complete.json
    menu-items.json
    new-menu-items-part2.json
    new-menu-items.json
    slider-data.json
  hooks/
    use-mobile.tsx
    use-toast.ts
    useAuth.ts
    useMenuItems.ts
    useOrderActions.ts
    useQRScanner.ts
  lib/
    theme-config.ts
    utils.ts
  mock/
  pages/
    Account.tsx
    Bill.tsx
    CallWaiter.tsx
    Cart.tsx
    CartPage.tsx
    CategoryDetail.tsx
    Checkout.tsx
    Favorites.tsx
    Index.tsx
    Layout.tsx
    Layout.tsx.backup
    Login.tsx
    LoginSuccess.tsx
    Menu.tsx
    MenuItemDetail.tsx
    MenuPage.tsx
    MyOrders.tsx
    NotFound.tsx
    OrderConfirmation.tsx
    PaymentCancel.tsx
    PaymentSuccess.tsx
    ScanTable.tsx
    Signup.tsx
    Splash.tsx
  services/
    api.ts
    AuthService.ts
    DemoService.ts
    menuDataAdapter.ts
    OrderService.ts
    qrService.ts
    test-order-service.ts
    WebSocketService.ts
  types/
    index.ts
    menu.ts
    Order.ts
  utils/
    __tests__/
      dataTransformers.test.ts
    dataFetcher.ts
    dataTransformers.ts
  App.css
  App.tsx
  constants.ts
  index.css
  main.tsx
  main.tsx.backup
  main.tsx.new
  README-API-INTEGRATION.md
  seed.js
  vite-env.d.ts
.gitignore
.replit
components.json
cookies.txt
deploy-customer.sh
deploy.sh
deployment.md
docker-compose.yml
eslint.config.js
index.html
INSEAT-MENU-INTEGRATION.md
package.json
package.json.backup
postcss.config.js
README-menu-integration.md
README.md
tailwind.config.ts
test-orders.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="attached_assets/Pasted-Okay-here-s-the-refined-prompt-taking-into-account-your-feedback-and-the-backend-details-Promp-1743595660300.txt">
Okay, here's the refined prompt, taking into account your feedback and the backend details.

**Prompt: Build a Customer-Facing Ordering Site with UI Improvements, Dynamic Table Number, Real JSON Data, API Fallback, and Full Authentication**

**Overall Goal:** Build a *new and independent* customer-facing online ordering platform, drawing *inspiration and reusable components* 
The platform should:

1.  Provide a visually appealing menu browsing experience.
2.  Allow users to browse menus, add items to a cart, and place orders.
3.  Implement full user authentication (email/password and Google Auth).
4.  Have a loyalty system.
5.  Gracefully handle backend API unavailability by falling back to local JSON files served by JSON Server.
6.  Implement a dynamic table number display.
**I. Core Functionality Requirements:**

1.  **Dynamic Table Number:**
    *   **Functionality:** The application should retrieve the table number from the URL path.  For example, if the URL is `http://localhost:5173/?table=L01`, the table number "L01" should be extracted. If no `table` query parameter is present, generate a random alphanumeric string of length 4 (e.g., "A4B2").
    *   **Display:** Display the table number prominently in the navbar, as shown in the provided screenshot ("TABLE L01").  Use the `localStorage` to persit the table number.
    *   **Re-randomization:** When the user refreshes the page, the URL should be checked again to see if the `table` parameter is added, if not regenerate a new random alphanumeric string of length 4
    *   **Component:** Modify the `Layout.tsx` component to accommodate this dynamic table number.

2.  **Hero Section/Slider (Improved):**
    *   **Functionality:** Implement a functional hero section slider at the top of the menu page.
    *   **Content:** The slider should display promotional content related to the restaurant, such as:
        *   Special offers (e.g., "10% off your first order").
        *   Featured menu items.
        *   Seasonal promotions.
        *   Restaurant information (e.g., new location, hours of operation).
    *   **Data Source:** The slider content should be loaded from a JSON file: `src/data/slider-data.json`.
        *   **Data Structure (slider-data.json):**
            ```json
            [
              {
                "id": "slide1",
                "imageUrl": "url to a promotional image",
                "title": "Welcome Offer!",
                "description": "Get 10% off your first order with code WELCOME10",
                "link": "/menu" // Optional link to a specific page
              },
              {
                "id": "slide2",
                "imageUrl": "url to a featured item image",
                "title": "Featured Item: Spicy Chicken Burger",
                "description": "Try our new Spicy Chicken Burger â€“ guaranteed to ignite your taste buds!",
                "link": "/menu/item23" //Optional link
              }
            ]
            ```
    *   **UI:** The slider should have:
        *   Automatic sliding with a smooth transition effect.
        *   Navigation indicators (dots or arrows) to allow users to manually navigate the slides.
        *   Clear and legible text.
        *   Optimized images for fast loading.
    *   **Component:** Create a new component `src/components/home/HeroSlider.tsx` to handle the slider functionality.
    *   **Responsiveness:** Make the slider responsive and adapt to different screen sizes.

3.  **Menu Browsing:**
    *   **UI:** Design a visually appealing menu browsing experience, drawing inspiration from the provided screenshot.
        *   Implement the category selection as a horizontal scrollable list of icon buttons.
        *   Display menu items in a grid format, with clear images, names, descriptions, and prices.
        *   Add a "+" button (as in the screenshot) to allow users to quickly add items to the cart.
    *   **Data Source:**
        *   **Primary:** Attempt to fetch menu categories and items from `localhost:3000/api/categories` and `localhost:3000/api/menu-items`. Use `axiosConfig.ts` to make the API requests.
        *   **Fallback:** If the API requests fail, load mock data from JSON files located in a new folder: `src/data/menu-data.json` (containing categories) and `src/data/menu-items.json` (containing menu items).  The application *must not crash*.  Display an appropriate message to the user indicating the data source.
        *   **Filtering:** Display only categories and menu items that belong to the currently selected restaurant (store restaurant ID in `localStorage`). Add a `restaurantId` property to the JSON data structures (see the previous prompt) and use it to filter the displayed items and categories.
    *   **Modifier Groups:** Implement support for displaying and selecting modifiers. Use real data fetch for modifiers and modifier groups with json fallback.
    * **Real JSON Data**: The application should attempt to load data from the `src/data` json files using `fetch` api.
4.  **Shopping Cart:**
    *   **Functionality:** Implement a shopping cart.
    *   **Display:**  Display the cart with item names, quantities, prices, and a running total. Implement a badge icon for the cart.
    *   **Floating Cart:**  Display the cart as a floating icon (as shown in the screenshot) on the right corner of the screen, with the number of items in the cart.
    *   **Quantity Adjustment:** Allow users to easily adjust the quantity of items in the cart.

5.  **Order Placement:**
    *   **UI:** Design a clear and concise order placement form.
    *   **Data:** Collect necessary information:
        *   Customer Name
        *   Contact Information (Phone/Email)
        *   Delivery Address / Table Number (automatically populated from the URL parameter).
        *   Order Type (Delivery/Dine-in - implement a radio button).
        *   Special Instructions (optional)
    *   **Order Submission:**
        *   **API Interaction:** Attempt to POST the order data to `localhost:3000/api/orders`.
        *   **JSON Server Fallback:** If the API request fails, store the order data in a new JSON file: `src/data/orders.json` (append to the existing array or create the file if it doesn't exist). Store the order data in the appropriate folder inside `src/data` folder. Alert the user that the order was saved locally and will be processed when the server is back online.
        *   Implement validation to ensure only users order for their selected restaurant

6.  **User Authentication (Email/Password and Google Auth) with Loyalty System:**
    *   **Registration/Login:** Create Login.tsx and Register.tsx pages (modify existing ones).
        *   **Data Source:**
            *   **API Interaction:** Attempt to register/login users via `localhost:3000/api/register` and `localhost:3000/api/login`.
            *   **JSON Server Fallback:** If the API is unavailable, store user data in `src/data/users.json`. Store all user data to the correct folder inside `src/data`
        *   **Google Auth:** Integrate Google Authentication.
        * Store the login status in `localStorage`
    *   **Account Management:** Create a "My Account" page where users can view their profile, order history, and loyalty points.
    *   **Protected Routes:** Use `ProtectedRoute.tsx` to protect the order placement and "My Account" pages.
    *   **Loyalty System:**
        * Implement a points system
        * Give users a certain amount of points on each succesful order.
        * Display and load user loyalty points by calling data fetch from localhost api then fallback to the json data
        * Reward users based on loyalty points to give them discounts and so on.

7.  **Restaurant Selection (Existing):**
    *   Keep the restaurant selection functionality but implement the filter for restaurant to prevent users from placing order that does not belong to the selected restaurant

**II. UI/UX Enhancements:**

1.  **Visual Theme:** Completely revamp the UI to be customer-friendly and visually appealing.  Use a modern design aesthetic. Use a library like Tailwind CSS or Material UI for styling. Refer to the screenshot provided for inspiration.
2.  **Responsiveness:** Ensure the site is fully responsive.
3.  **Image Handling:**  Implement proper image handling.

**III. Code Structure and Organization:**

1.  **Modularity:** Maintain a modular code structure.
2.  **Data Fetching:** Create custom hooks.
3.  **Error Handling:** Implement comprehensive error handling.
4.  **TypeScript:** Maintain strong typing.

**IV. Backend Interaction (Simulated with JSON Server):**

1.  **JSON Server Setup:**
    *   Install JSON Server globally.
    *   Create a `db.json` file.
    *   Run JSON Server on port 3000.
2.  **API Endpoints:** The application should use the following API endpoints:
    *   `GET /api/categories`
    *   `GET /api/menu-items`
    *   `GET /api/modifier-groups`
    *   `GET /api/modifiers`
    *   `POST /api/orders`
    *   `POST /api/register`
    *   `POST /api/login`
    *   `GET /api/users/:id` (to get user profile data)

**V. JSON Server Fallback Logic (Critical):**

1.  **Centralized Fetching:** Create a utility function or a custom hook.
2.  **API Request:** Attempt to fetch data from the JSON Server API endpoint.
3.  **Timeout:** Implement a timeout.
4.  **Error Handling:** Use `try...catch` blocks.
5.  **JSON File Fallback:** If the API request fails, load the data from the corresponding JSON file in `src/data/`.
6. ** Folder organization inside `src/data`:
Create the following folders inside `src/data` to store different data:
* `src/data/orders`: To store order data
* `src/data/users`: To store users data
* `src/data/restaurants`: To store restaurant data

7.  **Caching:** Consider caching the data.
8.  **User Feedback:** Display a clear message.

**VI. Things to Consider and Implement:**

*   **Testing:** Write unit tests.
*   **Clear Error Messages:** Provide informative error messages.
*   **Loading States:** Display loading indicators.

**VII. Existing Components to Leverage and Adapt:**

*   `src/components/menu/*`: Adapt these components.
*   `src/components/common/ProtectedRoute.tsx`: Use this for protecting routes.
*   `src/context/AuthContext.tsx`: Adapt or replace this context.
*   `src/utils/axiosConfig.ts`: Use this for making API requests.

**This prompt provides a detailed guide for transforming the existing admin dashboard into a fully functional, visually appealing, and robust customer-facing ordering site. It emphasizes the use of a real data, dynamic table number, user authentication, JSON Server fallback, and a modern UI.  Pay close attention to the folder structure and data source priorities.**


Key improvements in this prompt:

Table Number: Implemented dynamic table number extraction and display.

Hero Section: Described the hero section in detail.

Functionality Improvements: User authentication, and Loyalty system.

Folder organization: Specified a folder inside src/data to oraganize data

API endpoints Added the list of API endpoints that are expected.

Data fetching Try to make data fetch as possible from the src/data folders for JSON data.

Remember to break this down into smaller tasks and iterate on the AI-generated code. Good luck!
</file>

<file path="docs/order-endpoints.md">
# INSEAT Order API Endpoints Documentation

This document provides examples of all order-related API endpoints and how to test them using curl commands.

## Base URL
All endpoints are prefixed with: `http://localhost:3000/api/orders`

## Authentication Note
Some endpoints may require authentication. Add the Authorization header when needed:
```bash
-H "Authorization: Bearer YOUR_TOKEN"
```

## Endpoints

### 1. Get All Orders
```bash
curl -i -X GET http://localhost:3000/api/orders
```

### 2. Create New Order
```bash
curl -i -X POST http://localhost:3000/api/orders \
  -H "Content-Type: application/json" \
  -d '{
    "restaurantId": "65f2d6e8c52d3a1234567890",
    "tableNumber": "A1",
    "items": [
      {
        "menuItemId": "65f2d6e8c52d3a1234567891",
        "quantity": 2,
        "specialInstructions": "No onions"
      }
    ],
    "totalAmount": 25.98,
    "status": "pending"
  }'
```

### 3. Get Order by ID
```bash
curl -i -X GET http://localhost:3000/api/orders/ORDER_ID
```

### 4. Update Order Status
```bash
curl -i -X PUT http://localhost:3000/api/orders/ORDER_ID/status \
  -H "Content-Type: application/json" \
  -d '{
    "status": "confirmed"
  }'
```

### 5. Update Payment Status
```bash
curl -i -X PUT http://localhost:3000/api/orders/ORDER_ID/payment \
  -H "Content-Type: application/json" \
  -d '{
    "paymentStatus": "paid",
    "paymentMethod": "card"
  }'
```

### 6. Cancel Order
```bash
curl -i -X POST http://localhost:3000/api/orders/ORDER_ID/cancel
```

### 7. Get Orders by Restaurant
```bash
curl -i -X GET http://localhost:3000/api/orders/restaurant/RESTAURANT_ID
```

### 8. Get Orders by Table
```bash
curl -i -X GET http://localhost:3000/api/orders/restaurant/RESTAURANT_ID/table/TABLE_NUMBER
```

### 9. Get Orders by User
```bash
curl -i -X GET http://localhost:3000/api/orders/user/USER_ID
```

### 10. Update Order Details
```bash
curl -i -X PUT http://localhost:3000/api/orders/ORDER_ID \
  -H "Content-Type: application/json" \
  -d '{
    "items": [
      {
        "menuItemId": "65f2d6e8c52d3a1234567891",
        "quantity": 3,
        "specialInstructions": "Extra spicy"
      }
    ],
    "totalAmount": 38.97
  }'
```

### 11. Send Order Alert
```bash
curl -i -X POST http://localhost:3000/api/orders/ORDER_ID/alert \
  -H "Content-Type: application/json" \
  -d '{
    "type": "assistance_needed",
    "message": "Customer needs assistance"
  }'
```

## Sample Data Types

### Order Status Options
- pending
- confirmed
- preparing
- ready
- delivered
- completed
- cancelled

### Payment Status Options
- pending
- processing
- paid
- failed
- refunded

### Payment Method Options
- cash
- card
- mobile_money
- wallet

### Alert Types
- assistance_needed
- order_ready
- payment_reminder
- special_request

## Testing Notes
1. Replace placeholder IDs (ORDER_ID, RESTAURANT_ID, etc.) with actual IDs from your database
2. Ensure the server is running on port 3000 before testing
3. Check response headers for CORS and authentication requirements
4. Some endpoints may require additional authorization
</file>

<file path="public/placeholder.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="1200" fill="none"><rect width="1200" height="1200" fill="#EAEAEA" rx="3"/><g opacity=".5"><g opacity=".5"><path fill="#FAFAFA" d="M600.709 736.5c-75.454 0-136.621-61.167-136.621-136.62 0-75.454 61.167-136.621 136.621-136.621 75.453 0 136.62 61.167 136.62 136.621 0 75.453-61.167 136.62-136.62 136.62Z"/><path stroke="#C9C9C9" stroke-width="2.418" d="M600.709 736.5c-75.454 0-136.621-61.167-136.621-136.62 0-75.454 61.167-136.621 136.621-136.621 75.453 0 136.62 61.167 136.62 136.621 0 75.453-61.167 136.62-136.62 136.62Z"/></g><path stroke="url(#a)" stroke-width="2.418" d="M0-1.209h553.581" transform="scale(1 -1) rotate(45 1163.11 91.165)"/><path stroke="url(#b)" stroke-width="2.418" d="M404.846 598.671h391.726"/><path stroke="url(#c)" stroke-width="2.418" d="M599.5 795.742V404.017"/><path stroke="url(#d)" stroke-width="2.418" d="m795.717 796.597-391.441-391.44"/><path fill="#fff" d="M600.709 656.704c-31.384 0-56.825-25.441-56.825-56.824 0-31.384 25.441-56.825 56.825-56.825 31.383 0 56.824 25.441 56.824 56.825 0 31.383-25.441 56.824-56.824 56.824Z"/><g clip-path="url(#e)"><path fill="#666" fill-rule="evenodd" d="M616.426 586.58h-31.434v16.176l3.553-3.554.531-.531h9.068l.074-.074 8.463-8.463h2.565l7.18 7.181V586.58Zm-15.715 14.654 3.698 3.699 1.283 1.282-2.565 2.565-1.282-1.283-5.2-5.199h-6.066l-5.514 5.514-.073.073v2.876a2.418 2.418 0 0 0 2.418 2.418h26.598a2.418 2.418 0 0 0 2.418-2.418v-8.317l-8.463-8.463-7.181 7.181-.071.072Zm-19.347 5.442v4.085a6.045 6.045 0 0 0 6.046 6.045h26.598a6.044 6.044 0 0 0 6.045-6.045v-7.108l1.356-1.355-1.282-1.283-.074-.073v-17.989h-38.689v23.43l-.146.146.146.147Z" clip-rule="evenodd"/></g><path stroke="#C9C9C9" stroke-width="2.418" d="M600.709 656.704c-31.384 0-56.825-25.441-56.825-56.824 0-31.384 25.441-56.825 56.825-56.825 31.383 0 56.824 25.441 56.824 56.825 0 31.383-25.441 56.824-56.824 56.824Z"/></g><defs><linearGradient id="a" x1="554.061" x2="-.48" y1=".083" y2=".087" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="b" x1="796.912" x2="404.507" y1="599.963" y2="599.965" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="c" x1="600.792" x2="600.794" y1="403.677" y2="796.082" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="d" x1="404.85" x2="796.972" y1="403.903" y2="796.02" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><clipPath id="e"><path fill="#fff" d="M581.364 580.535h38.689v38.689h-38.689z"/></clipPath></defs></svg>
</file>

<file path="src/api/db.js">
import { MongoClient } from 'mongodb';
// Connection URL - get from environment variable or use default
const url = process.env.MONGO_URL || 'mongodb://localhost:27017/inseat';
const dbName = 'inseat';
// Create a new MongoClient
const client = new MongoClient(url);
let db = null;
// Connect to the MongoDB server
export const connectToDatabase = async () => {
  if (db) return db;
  try {
    await client.connect();
    console.log('Connected successfully to MongoDB server');
    db = client.db(dbName);
    return db;
  } catch (error) {
    console.error('Failed to connect to MongoDB:', error);
    throw error;
  }
};
// Close the connection
export const closeConnection = async () => {
  if (client) {
    await client.close();
    console.log('MongoDB connection closed');
  }
};
// Get reference to a collection
export const getCollection = async (collectionName) => {
  const db = await connectToDatabase();
  return db.collection(collectionName);
};
// Export the MongoDB client
export default client;
</file>

<file path="src/components/home/HeroSlider.tsx">
import React, { useCallback, useEffect, useState } from 'react';
import { Link } from 'react-router-dom';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import useEmblaCarousel from 'embla-carousel-react';
import Autoplay from 'embla-carousel-autoplay';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
interface Slide {
  id: string;
  imageUrl: string;
  imageSearchTerm: string;
  title: string;
  description: string;
  link: string;
}
export const HeroSlider = () => {
  const [slides, setSlides] = useState<Slide[]>([]);
  const [currentSlide, setCurrentSlide] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [imageErrors, setImageErrors] = useState<Record<string, boolean>>({});
  // Initialize Embla with autoplay
  const [emblaRef, emblaApi] = useEmblaCarousel({ loop: true }, [
    Autoplay({ delay: 5000, stopOnInteraction: false })
  ]);
  useEffect(() => {
    const loadSlides = async () => {
      try {
        const response = await fetch('/src/data/slider-data.json');
        const data = await response.json();
        setSlides(data);
      } catch (error) {
        console.error('Error loading slides:', error);
      } finally {
        setIsLoading(false);
      }
    };
    loadSlides();
  }, []);
  const onSelect = useCallback(() => {
    if (!emblaApi) return;
    setCurrentSlide(emblaApi.selectedScrollSnap());
  }, [emblaApi]);
  useEffect(() => {
    if (!emblaApi) return;
    onSelect();
    emblaApi.on('select', onSelect);
    return () => {
      emblaApi.off('select', onSelect);
    };
  }, [emblaApi, onSelect]);
  const scrollPrev = useCallback(() => emblaApi?.scrollPrev(), [emblaApi]);
  const scrollNext = useCallback(() => emblaApi?.scrollNext(), [emblaApi]);
  const scrollTo = useCallback((index: number) => emblaApi?.scrollTo(index), [emblaApi]);
  const handleImageError = (id: string) => {
    setImageErrors(prev => ({ ...prev, [id]: true }));
  };
  const getFallbackImage = (slide: Slide) => {
    return `https://source.unsplash.com/random/1200x600/?${slide.imageSearchTerm}`;
  };
  if (isLoading || slides.length === 0) {
    return (
      <div className="w-full h-[400px] bg-muted animate-pulse rounded-lg" />
    );
  }
  return (
    <div className="relative w-full overflow-hidden rounded-xl bg-background group">
      <div ref={emblaRef} className="overflow-hidden">
        <div className="flex h-[400px] -ml-4">
          {slides.map((slide) => (
            <div
              key={slide.id}
              className="relative flex-[0_0_100%] min-w-0 pl-4"
            >
              <div className="relative w-full h-full overflow-hidden rounded-lg">
                <img
                  src={imageErrors[slide.id] ? getFallbackImage(slide) : slide.imageUrl}
                  alt={slide.title}
                  className="absolute inset-0 w-full h-full object-cover transition-transform duration-300 hover:scale-105"
                  onError={() => handleImageError(slide.id)}
                />
                <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-black/50 to-transparent" />
                <div className="absolute bottom-0 left-0 right-0 p-8 text-white">
                  <h2 className="text-3xl font-bold mb-3 tracking-tight">{slide.title}</h2>
                  <p className="text-lg mb-4 text-gray-200 max-w-xl">{slide.description}</p>
                  <Link to={slide.link}>
                    <Button size="lg" className="bg-marian-blue hover:bg-marian-blue/90 text-white">
                      Explore Now
                    </Button>
                  </Link>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
      <div className="absolute bottom-6 left-1/2 -translate-x-1/2 flex gap-2 z-10">
        {slides.map((_, index) => (
          <button
            key={index}
            className={cn(
              "w-2 h-2 rounded-full transition-all duration-300",
              index === currentSlide
                ? "bg-white w-6"
                : "bg-white/50 hover:bg-white/75"
            )}
            onClick={() => scrollTo(index)}
            aria-label={`Go to slide ${index + 1}`}
          />
        ))}
      </div>
      <Button
        variant="ghost"
        size="icon"
        className="absolute left-4 top-1/2 -translate-y-1/2 bg-black/30 hover:bg-black/50 text-white rounded-full h-10 w-10 transition-all duration-200 opacity-0 group-hover:opacity-100"
        onClick={scrollPrev}
        aria-label="Previous slide"
      >
        <ChevronLeft className="h-6 w-6" />
      </Button>
      <Button
        variant="ghost"
        size="icon"
        className="absolute right-4 top-1/2 -translate-y-1/2 bg-black/30 hover:bg-black/50 text-white rounded-full h-10 w-10 transition-all duration-200 opacity-0 group-hover:opacity-100"
        onClick={scrollNext}
        aria-label="Next slide"
      >
        <ChevronRight className="h-6 w-6" />
      </Button>
    </div>
  );
};
export default HeroSlider;
</file>

<file path="src/components/menu/MenuGrid.tsx">
import React from 'react';
import { useMenuItems } from '@/hooks/useMenuItems';
import { MenuItemCard } from './MenuItemCard';
import { MenuItemCardSkeleton } from './MenuItemCardSkeleton';
import { MenuItem } from '@/types/menu';
interface MenuGridProps {
  category?: string;
  searchQuery?: string;
  onItemClick?: (item: MenuItem) => void;
}
export const MenuGrid: React.FC<MenuGridProps> = ({ category, searchQuery, onItemClick }) => {
  const { items, isLoading, error } = useMenuItems();
  // Filter items based on category and search query
  const filteredItems = React.useMemo(() => {
    if (!items) return [];
    let filtered = [...items];
    // Filter by category
    if (category && category !== 'all') {
      filtered = filtered.filter(item => 
        item.category.toLowerCase() === category.toLowerCase() ||
        item.categoryId.toLowerCase() === category.toLowerCase()
      );
    }
    // Filter by search query
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(
        item =>
          item.name.toLowerCase().includes(query) ||
          item.description.toLowerCase().includes(query) ||
          item.tags?.some(tag => tag.toLowerCase().includes(query))
      );
    }
    return filtered;
  }, [items, category, searchQuery]);
  if (error) {
    return (
      <div className="text-center py-12 text-muted-foreground">
        Failed to load menu items. Please try again later.
      </div>
    );
  }
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
      {isLoading ? (
        <>
          {[...Array(8)].map((_, i) => (
            <MenuItemCardSkeleton key={i} />
          ))}
        </>
      ) : (
        filteredItems.map((item) => (
          <MenuItemCard 
            key={item.id} 
            item={item} 
            onClick={() => onItemClick?.(item)}
          />
        ))
      )}
      {!isLoading && filteredItems.length === 0 && (
        <div className="col-span-full text-center py-12">
          <h3 className="text-xl font-medium mb-2">No items found</h3>
          <p className="text-muted-foreground">Try adjusting your search or filters</p>
        </div>
      )}
    </div>
  );
};
export default MenuGrid;
</file>

<file path="src/components/menu/MenuItemCardSkeleton.tsx">
import { Card } from '@/components/ui/card';
export const MenuItemCardSkeleton = () => {
  return (
    <Card className="overflow-hidden">
      <div className="aspect-video bg-muted animate-pulse" />
      <div className="p-4 space-y-3">
        <div className="flex gap-1">
          <div className="h-5 w-16 bg-muted rounded-full animate-pulse" />
          <div className="h-5 w-16 bg-muted rounded-full animate-pulse" />
        </div>
        <div className="space-y-2">
          <div className="h-6 w-3/4 bg-muted rounded animate-pulse" />
          <div className="h-4 w-full bg-muted rounded animate-pulse" />
        </div>
        <div className="flex justify-between items-end pt-1">
          <div className="h-6 w-20 bg-muted rounded animate-pulse" />
          <div className="h-4 w-24 bg-muted rounded animate-pulse" />
        </div>
      </div>
    </Card>
  );
};
export default MenuItemCardSkeleton;
</file>

<file path="src/components/shared/SharedImage.tsx">
import React, { useState } from 'react';
import { cn } from '@/lib/utils';
interface SharedImageProps extends React.ImgHTMLAttributes<HTMLImageElement> {
  fallbackSrc?: string;
  fallbackSearchTerm?: string;
  aspectRatio?: 'video' | 'square' | 'wide';
}
export const SharedImage: React.FC<SharedImageProps> = ({
  src,
  alt,
  className,
  fallbackSrc,
  fallbackSearchTerm,
  aspectRatio = 'video',
  ...props
}) => {
  const [error, setError] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const getFallbackImage = () => {
    if (fallbackSrc) return fallbackSrc;
    if (fallbackSearchTerm) {
      const dimensions = aspectRatio === 'square' ? '400x400' : 
                        aspectRatio === 'wide' ? '800x400' : '400x300';
      return `https://source.unsplash.com/random/${dimensions}/?${encodeURIComponent(fallbackSearchTerm)}`;
    }
    return '/placeholder.jpg';
  };
  const handleLoad = () => {
    setIsLoading(false);
  };
  return (
    <div className={cn(
      'relative overflow-hidden',
      aspectRatio === 'video' && 'aspect-video',
      aspectRatio === 'square' && 'aspect-square',
      aspectRatio === 'wide' && 'aspect-[2/1]',
      className
    )}>
      {isLoading && (
        <div className="absolute inset-0 bg-muted animate-pulse" />
      )}
      <img
        src={error ? getFallbackImage() : src}
        alt={alt}
        className={cn(
          'w-full h-full object-cover transition-opacity duration-300',
          isLoading ? 'opacity-0' : 'opacity-100'
        )}
        onError={() => setError(true)}
        onLoad={handleLoad}
        {...props}
      />
    </div>
  );
};
export default SharedImage;
</file>

<file path="src/components/ui/accordion.tsx">
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"
import { cn } from "@/lib/utils"
const Accordion = AccordionPrimitive.Root
const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"
const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName
const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))
AccordionContent.displayName = AccordionPrimitive.Content.displayName
export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="src/components/ui/alert-dialog.tsx">
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"
import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"
const AlertDialog = AlertDialogPrimitive.Root
const AlertDialogTrigger = AlertDialogPrimitive.Trigger
const AlertDialogPortal = AlertDialogPrimitive.Portal
const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName
const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName
const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"
const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"
const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName
const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName
const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName
const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName
export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)
const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"
const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"
const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"
export { Alert, AlertTitle, AlertDescription }
</file>

<file path="src/components/ui/aspect-ratio.tsx">
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"
const AspectRatio = AspectRatioPrimitive.Root
export { AspectRatio }
</file>

<file path="src/components/ui/avatar.tsx">
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"
import { cn } from "@/lib/utils"
const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName
const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName
const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName
export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)
export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}
function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}
export { Badge, badgeVariants }
</file>

<file path="src/components/ui/breadcrumb.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"
import { cn } from "@/lib/utils"
const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"
const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"
const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"
const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"
  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"
const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"
const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:size-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"
const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"
export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)
export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}
const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"
export { Button, buttonVariants }
</file>

<file path="src/components/ui/calendar.tsx">
import * as React from "react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { DayPicker } from "react-day-picker";
import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";
export type CalendarProps = React.ComponentProps<typeof DayPicker>;
function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ ..._props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ..._props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  );
}
Calendar.displayName = "Calendar";
export { Calendar };
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"
const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"
const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"
const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"
const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"
const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"
const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"
export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="src/components/ui/carousel.tsx">
import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]
type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}
type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps
const CarouselContext = React.createContext<CarouselContextProps | null>(null)
function useCarousel() {
  const context = React.useContext(CarouselContext)
  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }
  return context
}
const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)
    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }
      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])
    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])
    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])
    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )
    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }
      setApi(api)
    }, [api, setApi])
    React.useEffect(() => {
      if (!api) {
        return
      }
      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)
      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])
    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"
const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()
  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"
const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()
  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"
const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()
  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"
const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()
  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"
export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
</file>

<file path="src/components/ui/chart.tsx">
import * as React from "react"
import * as RechartsPrimitive from "recharts"
import { cn } from "@/lib/utils"
// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const
export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}
type ChartContextProps = {
  config: ChartConfig
}
const ChartContext = React.createContext<ChartContextProps | null>(null)
function useChart() {
  const context = React.useContext(ChartContext)
  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }
  return context
}
const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`
  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"
const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([_, config]) => config.theme || config.color
  )
  if (!colorConfig.length) {
    return null
  }
  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}
const ChartTooltip = RechartsPrimitive.Tooltip
const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()
    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }
      const [item] = payload
      const key = `${labelKey || item.dataKey || item.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label
      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }
      if (!value) {
        return null
      }
      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])
    if (!active || !payload?.length) {
      return null
    }
    const nestLabel = payload.length === 1 && indicator !== "dot"
    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color
            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"
const ChartLegend = RechartsPrimitive.Legend
const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()
    if (!payload?.length) {
      return null
    }
    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)
          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"
// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }
  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined
  let configLabelKey: string = key
  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }
  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}
export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}
</file>

<file path="src/components/ui/checkbox.tsx">
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"
import { cn } from "@/lib/utils"
const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName
export { Checkbox }
</file>

<file path="src/components/ui/collapsible.tsx">
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"
const Collapsible = CollapsiblePrimitive.Root
const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger
const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent
export { Collapsible, CollapsibleTrigger, CollapsibleContent }
</file>

<file path="src/components/ui/command.tsx">
import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"
import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"
const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName
interface CommandDialogProps extends DialogProps {}
const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}
const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))
CommandInput.displayName = CommandPrimitive.Input.displayName
const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))
CommandList.displayName = CommandPrimitive.List.displayName
const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))
CommandEmpty.displayName = CommandPrimitive.Empty.displayName
const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))
CommandGroup.displayName = CommandPrimitive.Group.displayName
const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName
const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50",
      className
    )}
    {...props}
  />
))
CommandItem.displayName = CommandPrimitive.Item.displayName
const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"
export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
</file>

<file path="src/components/ui/context-menu.tsx">
import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"
import { cn } from "@/lib/utils"
const ContextMenu = ContextMenuPrimitive.Root
const ContextMenuTrigger = ContextMenuPrimitive.Trigger
const ContextMenuGroup = ContextMenuPrimitive.Group
const ContextMenuPortal = ContextMenuPrimitive.Portal
const ContextMenuSub = ContextMenuPrimitive.Sub
const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup
const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName
const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName
const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName
const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName
const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName
const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName
const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName
const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName
const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"
export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}
</file>

<file path="src/components/ui/dialog.tsx">
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"
import { cn } from "@/lib/utils"
const Dialog = DialogPrimitive.Root
const DialogTrigger = DialogPrimitive.Trigger
const DialogPortal = DialogPrimitive.Portal
const DialogClose = DialogPrimitive.Close
const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName
const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName
const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"
const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"
const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName
const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName
export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="src/components/ui/dock.tsx">
'use client';
import {
  motion,
  MotionValue,
  useMotionValue,
  useSpring,
  useTransform,
  type SpringOptions,
  AnimatePresence,
} from 'framer-motion';
import {
  Children,
  cloneElement,
  createContext,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import { cn } from '@/lib/utils';
const DOCK_HEIGHT = 128;
const DEFAULT_MAGNIFICATION = 60;
const DEFAULT_DISTANCE = 120;
const DEFAULT_PANEL_HEIGHT = 64;
type DockProps = {
  children: React.ReactNode;
  className?: string;
  distance?: number;
  panelHeight?: number;
  magnification?: number;
  spring?: SpringOptions;
};
type DockItemProps = {
  className?: string;
  children: React.ReactNode;
  isActive?: boolean;
};
type DockLabelProps = {
  className?: string;
  children: React.ReactNode;
};
type DockIconProps = {
  className?: string;
  children: React.ReactNode;
};
type DockContextType = {
  mouseX: MotionValue;
  spring: SpringOptions;
  magnification: number;
  distance: number;
};
type DockProviderProps = {
  children: React.ReactNode;
  value: DockContextType;
};
const DockContext = createContext<DockContextType | undefined>(undefined);
function DockProvider({ children, value }: DockProviderProps) {
  return <DockContext.Provider value={value}>{children}</DockContext.Provider>;
}
function useDock() {
  const context = useContext(DockContext);
  if (!context) {
    throw new Error('useDock must be used within a DockProvider');
  }
  return context;
}
function Dock({
  children,
  className,
  spring = { mass: 0.1, stiffness: 150, damping: 12 },
  magnification = DEFAULT_MAGNIFICATION,
  distance = DEFAULT_DISTANCE,
  panelHeight = DEFAULT_PANEL_HEIGHT,
}: DockProps) {
  const mouseX = useMotionValue(Infinity);
  const isHovered = useMotionValue(0);
  const maxHeight = useMemo(() => {
    return Math.max(DOCK_HEIGHT, magnification + magnification / 2 + 4);
  }, [magnification]);
  const heightRow = useTransform(isHovered, [0, 1], [panelHeight, maxHeight]);
  const height = useSpring(heightRow, spring);
  return (
    <motion.div
      style={{
        height: height,
        scrollbarWidth: 'none',
      }}
      className='flex max-w-full items-end overflow-x-auto'
    >
      <motion.div
        onMouseMove={({ pageX }) => {
          isHovered.set(1);
          mouseX.set(pageX);
        }}
        onMouseLeave={() => {
          isHovered.set(0);
          mouseX.set(Infinity);
        }}
        className={cn(
          'mx-auto flex w-fit gap-4 rounded-2xl bg-black/40 dark:bg-black/60 backdrop-blur-xl px-4',
          className
        )}
        style={{ height: panelHeight }}
        role='toolbar'
        aria-label='Application dock'
      >
        <DockProvider value={{ mouseX, spring, distance, magnification }}>
          {children}
        </DockProvider>
      </motion.div>
    </motion.div>
  );
}
function DockItem({ children, className, isActive = false }: DockItemProps) {
  const ref = useRef<HTMLDivElement>(null);
  const { distance, magnification, mouseX, spring } = useDock();
  const isHovered = useMotionValue(0);
  const mouseDistance = useTransform(mouseX, (val) => {
    const domRect = ref.current?.getBoundingClientRect() ?? { x: 0, width: 0 };
    return val - domRect.x - domRect.width / 2;
  });
  const widthTransform = useTransform(
    mouseDistance,
    [-distance, 0, distance],
    [40, magnification, 40]
  );
  const width = useSpring(widthTransform, spring);
  return (
    <motion.div
      ref={ref}
      style={{ width }}
      onHoverStart={() => isHovered.set(1)}
      onHoverEnd={() => isHovered.set(0)}
      onFocus={() => isHovered.set(1)}
      onBlur={() => isHovered.set(0)}
      className={cn(
        'relative inline-flex items-center justify-center',
        isActive ? 'scale-110 z-10' : '',
        className
      )}
      tabIndex={0}
      role='button'
      aria-haspopup='true'
    >
      {Children.map(children, (child) =>
        cloneElement(child as React.ReactElement, { width, isHovered, isActive })
      )}
    </motion.div>
  );
}
function DockLabel({ children, className, ...rest }: DockLabelProps) {
  const restProps = rest as Record<string, unknown>;
  const isHovered = restProps['isHovered'] as MotionValue<number>;
  const [isVisible, setIsVisible] = useState(false);
  useEffect(() => {
    const unsubscribe = isHovered.on('change', (latest) => {
      setIsVisible(latest === 1);
    });
    return () => unsubscribe();
  }, [isHovered]);
  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          initial={{ opacity: 0, y: 0 }}
          animate={{ opacity: 1, y: -10 }}
          exit={{ opacity: 0, y: 0 }}
          transition={{ duration: 0.2 }}
          className={cn(
            'absolute -top-6 left-1/2 w-fit whitespace-pre rounded-md border border-[#2D303E] bg-[#1F1D2B] px-2 py-0.5 text-xs text-white',
            className
          )}
          role='tooltip'
          style={{ x: '-50%' }}
        >
          {children}
        </motion.div>
      )}
    </AnimatePresence>
  );
}
function DockIcon({ children, className, ...rest }: DockIconProps) {
  const restProps = rest as Record<string, unknown>;
  const width = restProps['width'] as MotionValue<number>;
  const isActive = restProps['isActive'] as boolean;
  const widthTransform = useTransform(width, (val) => val / 2);
  return (
    <motion.div
      style={{ width: widthTransform }}
      className={cn(
        'flex items-center justify-center',
        isActive ? 'text-[#7B61FF]' : 'text-gray-400',
        className
      )}
    >
      {children}
    </motion.div>
  );
}
export { Dock, DockIcon, DockItem, DockLabel };
</file>

<file path="src/components/ui/drawer.tsx">
import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"
import { cn } from "@/lib/utils"
const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"
const DrawerTrigger = DrawerPrimitive.Trigger
const DrawerPortal = DrawerPrimitive.Portal
const DrawerClose = DrawerPrimitive.Close
const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName
const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"
const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"
const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"
const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName
const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName
export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}
</file>

<file path="src/components/ui/dropdown-menu.tsx">
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"
import { cn } from "@/lib/utils"
const DropdownMenu = DropdownMenuPrimitive.Root
const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger
const DropdownMenuGroup = DropdownMenuPrimitive.Group
const DropdownMenuPortal = DropdownMenuPrimitive.Portal
const DropdownMenuSub = DropdownMenuPrimitive.Sub
const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup
const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName
const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName
const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName
const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName
const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName
const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName
const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName
const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName
const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"
export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="src/components/ui/form.tsx">
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"
import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"
const Form = FormProvider
type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}
const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)
const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}
const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()
  const fieldState = getFieldState(fieldContext.name, formState)
  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }
  const { id } = itemContext
  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}
type FormItemContextValue = {
  id: string
}
const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)
const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()
  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"
const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()
  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"
const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()
  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"
const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()
  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"
const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children
  if (!body) {
    return null
  }
  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"
export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="src/components/ui/hover-card.tsx">
import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"
import { cn } from "@/lib/utils"
const HoverCard = HoverCardPrimitive.Root
const HoverCardTrigger = HoverCardPrimitive.Trigger
const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName
export { HoverCard, HoverCardTrigger, HoverCardContent }
</file>

<file path="src/components/ui/input-otp.tsx">
import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"
import { cn } from "@/lib/utils"
const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"
const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"
const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]
  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"
const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"
export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"
const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"
export { Input }
</file>

<file path="src/components/ui/label.tsx">
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)
const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName
export { Label }
</file>

<file path="src/components/ui/menubar.tsx">
import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"
import { cn } from "@/lib/utils"
const MenubarMenu = MenubarPrimitive.Menu
const MenubarGroup = MenubarPrimitive.Group
const MenubarPortal = MenubarPrimitive.Portal
const MenubarSub = MenubarPrimitive.Sub
const MenubarRadioGroup = MenubarPrimitive.RadioGroup
const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName
const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName
const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName
const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName
const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName
const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName
const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName
const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName
const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName
const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName
const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"
export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}
</file>

<file path="src/components/ui/navigation-menu.tsx">
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"
import { cn } from "@/lib/utils"
const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName
const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName
const NavigationMenuItem = NavigationMenuPrimitive.Item
const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
)
const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName
const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName
const NavigationMenuLink = NavigationMenuPrimitive.Link
const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName
const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName
export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}
</file>

<file path="src/components/ui/pagination.tsx">
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"
import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"
const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"
const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"
const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"
type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">
const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"
const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"
const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"
const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"
export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}
</file>

<file path="src/components/ui/popover.tsx">
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"
import { cn } from "@/lib/utils"
const Popover = PopoverPrimitive.Root
const PopoverTrigger = PopoverPrimitive.Trigger
const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName
export { Popover, PopoverTrigger, PopoverContent }
</file>

<file path="src/components/ui/progress.tsx">
import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"
import { cn } from "@/lib/utils"
const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName
export { Progress }
</file>

<file path="src/components/ui/radio-group.tsx">
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"
import { cn } from "@/lib/utils"
const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName
const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName
export { RadioGroup, RadioGroupItem }
</file>

<file path="src/components/ui/resizable.tsx">
import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"
import { cn } from "@/lib/utils"
const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)
const ResizablePanel = ResizablePrimitive.Panel
const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)
export { ResizablePanelGroup, ResizablePanel, ResizableHandle }
</file>

<file path="src/components/ui/scroll-area.tsx">
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"
import { cn } from "@/lib/utils"
const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName
const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName
export { ScrollArea, ScrollBar }
</file>

<file path="src/components/ui/Section.tsx">
import React, { forwardRef } from 'react';
import { motion, Variants } from 'framer-motion';
import { useInView } from 'react-intersection-observer';
import { cn } from '@/lib/utils';
/**
 * Props for the Section component
 */
export interface SectionProps extends React.HTMLAttributes<HTMLElement> {
  children: React.ReactNode;
  containerClassName?: string;
  innerClassName?: string;
  fullWidth?: boolean;
  as?: React.ElementType;
  variant?: string;
  bgImage?: string;
  bgPattern?: string | boolean; // Allow string or boolean
  patternOpacity?: number;
}
/**
 * Background pattern options
 */
const patterns = {
  grid: "data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23000000' fill-opacity='0.05'%3E%3Cpath d='M36 34v6h6v-6h-6zm6 6v6h-6v-6h6zm-6-12v6h6v-6h-6zm-12 12v6h6v-6h-6zm0-6h6v6h-6v-6zm12 0h6v6h6v6h-6v6h6v6h-12v-12h-6v12h-12v-12h6v-6h-6v-12h12v12h1v.167A3.001 3.001 0 0 0 36 34z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E",
  dots: "data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23000000' fill-opacity='0.05' fill-rule='evenodd'%3E%3Ccircle cx='3' cy='3' r='3'/%3E%3Ccircle cx='13' cy='13' r='3'/%3E%3C/g%3E%3C/svg%3E",
  waves: "data:image/svg+xml,%3Csvg width='100' height='20' viewBox='0 0 100 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M21.184 20c.357-.13.72-.264 1.088-.402l1.768-.661C33.64 15.347 39.647 14 50 14c10.271 0 15.362 1.222 24.629 4.928.955.383 1.869.74 2.75 1.072h6.225c-2.51-.73-5.139-1.691-8.233-2.928C65.888 13.278 60.562 12 50 12c-10.626 0-16.855 1.397-26.66 5.063l-1.767.662c-2.475.923-4.66 1.674-6.724 2.275h6.335zm0-20C13.258 2.892 8.077 4 0 4V2c5.744 0 9.951-.574 14.85-2h6.334zM77.38 0C85.239 2.966 90.502 4 100 4V2c-6.842 0-11.386-.542-16.396-2h-6.225zM0 14c8.44 0 13.718-1.21 22.272-4.402l1.768-.661C33.64 5.347 39.647 4 50 4c10.271 0 15.362 1.222 24.629 4.928C84.112 12.722 89.438 14 100 14v-2c-10.271 0-15.362-1.222-24.629-4.928C65.888 3.278 60.562 2 50 2 39.374 2 33.145 3.397 23.34 7.063l-1.767.662C13.223 10.84 8.163 12 0 12v2z' fill='%239C92AC' fill-opacity='0.05' fill-rule='evenodd'/%3E%3C/svg%3E",
  circuit: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 304 304' width='304' height='304'%3E%3Cpath fill='%23000000' fill-opacity='0.05' d='M44.1 224a5 5 0 1 1 0 2H0v-2h44.1zm160 48a5 5 0 1 1 0 2H82v-2h122.1zm57.8-46a5 5 0 1 1 0-2H304v2h-42.1zm0 16a5 5 0 1 1 0-2H304v2h-42.1zm6.2-114a5 5 0 1 1 0 2h-86.2a5 5 0 1 1 0-2h86.2zm-256-48a5 5 0 1 1 0 2H0v-2h12.1zm185.8 34a5 5 0 1 1 0-2h86.2a5 5 0 1 1 0 2h-86.2zM258 12.1a5 5 0 1 1-2 0V0h2v12.1z'/%3E%3C/svg%3E"
};
/**
 * Animation variants for the Section component
 */
const sectionVariants: Record<string, Variants> = {
  fadeIn: {
    hidden: { opacity: 0 },
    visible: { 
      opacity: 1,
      transition: { 
        duration: 0.6,
        ease: "easeInOut"
      } 
    }
  },
  fadeInUp: {
    hidden: { opacity: 0, y: 50 },
    visible: { 
      opacity: 1, 
      y: 0,
      transition: { 
        duration: 0.8,
        ease: "easeOut"
      } 
    }
  }
};
/**
 * Section component for creating consistent page sections with animation
 */
const Section = forwardRef<HTMLElement, SectionProps>(
  (
    {
      children,
      className = '',
      containerClassName = '',
      innerClassName = '',
      id,
      as = 'section',
      fullWidth = false,
      bgImage,
      bgPattern = false,
      patternOpacity = 0.05,
      variant = 'fadeIn',
      ...props
    },
    ref
  ) => {
    // Set up intersection observer
    const [sectionRef, inView] = useInView({
      triggerOnce: true,
      threshold: 0.1,
    });
    // Select the appropriate animation variant
    const animationVariant = sectionVariants[variant] || sectionVariants.fadeIn;
    // Create the main container classes
    const sectionClasses = cn(
      'relative w-full overflow-hidden',
      className
    );
    // Create the inner container classes
    const containerClasses = cn(
      fullWidth ? 'w-full' : 'max-w-7xl mx-auto px-4 sm:px-6 lg:px-8',
      containerClassName
    );
    // Inner content classes
    const innerClasses = cn(
      'relative z-10',
      innerClassName
    );
    // Determine which element to render based on props
    const Element = as as React.ElementType;
    // Determine which pattern to use based on bgPattern prop
    // If bgPattern is true, use 'grid' pattern
    // If bgPattern is a string, use that pattern if it exists in patterns
    let patternImage: string | null = null;
    if (bgPattern) {
      if (typeof bgPattern === 'string') {
        patternImage = patterns[bgPattern as keyof typeof patterns] || patterns.grid;
      } else {
        patternImage = patterns.grid;
      }
    }
    // Render standard section
    return (
      <Element
        ref={ref}
        id={id}
        className={sectionClasses}
        {...props}
      >
        {bgImage && (
          <div 
            className="absolute inset-0 z-0 bg-cover bg-center"
            style={{ 
              backgroundImage: `url(${bgImage})`,
              opacity: 0.15
            }}
          />
        )}
        {bgPattern && patternImage && (
          <div 
            className="absolute inset-0 z-0 pointer-events-none"
            style={{ 
              backgroundImage: `url(${patternImage})`,
              opacity: patternOpacity
            }}
          />
        )}
        <div className={containerClasses}>
          <motion.div
            ref={sectionRef}
            className={innerClasses}
            initial="hidden"
            animate={inView ? "visible" : "hidden"}
            variants={animationVariant}
          >
            {children}
          </motion.div>
        </div>
      </Element>
    );
  }
);
Section.displayName = 'Section';
export default Section;
</file>

<file path="src/components/ui/select.tsx">
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"
import { cn } from "@/lib/utils"
const Select = SelectPrimitive.Root
const SelectGroup = SelectPrimitive.Group
const SelectValue = SelectPrimitive.Value
const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName
const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName
const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName
const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName
const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName
const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName
const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName
export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
</file>

<file path="src/components/ui/separator.tsx">
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"
import { cn } from "@/lib/utils"
const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName
export { Separator }
</file>

<file path="src/components/ui/sheet.tsx">
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"
import * as React from "react"
import { cn } from "@/lib/utils"
const Sheet = SheetPrimitive.Root
const SheetTrigger = SheetPrimitive.Trigger
const SheetClose = SheetPrimitive.Close
const SheetPortal = SheetPrimitive.Portal
const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName
const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500 data-[state=open]:transition-transform",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)
interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
  VariantProps<typeof sheetVariants> { }
const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => {
  // Check if children contains a SheetTitle
  const hasSheetTitle = React.Children.toArray(children).some(
    (child) => React.isValidElement(child) && child.type === SheetTitle
  );
  // If no SheetTitle is found, add a default one
  const contentWithTitle = hasSheetTitle ? children : (
    <>
      <SheetTitle className="sr-only">Sheet Content</SheetTitle>
      {children}
    </>
  );
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        ref={ref}
        className={cn(sheetVariants({ side }), className)}
        {...props}
      >
        {contentWithTitle}
        <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
          <X className="h-4 w-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  );
})
SheetContent.displayName = SheetPrimitive.Content.displayName
const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"
const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"
const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName
const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName
export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
  SheetPrimitive,
}
</file>

<file path="src/components/ui/sidebar.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"
import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { Sheet, SheetContent } from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
const SIDEBAR_COOKIE_NAME = "sidebar:state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"
type SidebarContext = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}
const SidebarContext = React.createContext<SidebarContext | null>(null)
function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }
  return context
}
const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)
    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }
        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )
    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])
    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }
      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])
    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"
    const contextValue = React.useMemo<SidebarContext>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )
    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"
const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()
    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }
    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }
    return (
      <div
        ref={ref}
        className="group peer hidden md:block text-sidebar-foreground"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"
const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()
  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"
const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()
  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"
const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex min-h-svh flex-1 flex-col bg-background",
        "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"
const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"
const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"
const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"
const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"
const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"
const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"
const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"
  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"
const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"
  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"
const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"
const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"
const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"
const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)
const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()
    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )
    if (!tooltip) {
      return button
    }
    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }
    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"
const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"
  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"
const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"
const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])
  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("rounded-md h-8 flex gap-2 px-2 items-center", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 flex-1 max-w-[--skeleton-width]"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"
const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"
const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"
const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"
  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"
export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"
function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}
export { Skeleton }
</file>

<file path="src/components/ui/slider.tsx">
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"
import { cn } from "@/lib/utils"
const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName
export { Slider }
</file>

<file path="src/components/ui/sonner.tsx">
import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"
type ToasterProps = React.ComponentProps<typeof Sonner>
const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()
  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}
export { Toaster }
</file>

<file path="src/components/ui/switch.tsx">
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"
import { cn } from "@/lib/utils"
const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName
export { Switch }
</file>

<file path="src/components/ui/table.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"
const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"
const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"
const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"
const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"
const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"
const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"
const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"
const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"
export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="src/components/ui/tabs.tsx">
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"
import { cn } from "@/lib/utils"
const Tabs = TabsPrimitive.Root
const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName
const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName
const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName
export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"
export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}
const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"
export { Textarea }
</file>

<file path="src/components/ui/toast.tsx">
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"
import { cn } from "@/lib/utils"
const ToastProvider = ToastPrimitives.Provider
const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName
const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)
const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName
const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName
const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName
const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName
const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName
type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>
type ToastActionElement = React.ReactElement<typeof ToastAction>
export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}
</file>

<file path="src/components/ui/toaster.tsx">
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"
export function Toaster() {
  const { toasts } = useToast()
  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
</file>

<file path="src/components/ui/toggle-group.tsx">
import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"
const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})
const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))
ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName
const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)
  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})
ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName
export { ToggleGroup, ToggleGroupItem }
</file>

<file path="src/components/ui/toggle.tsx">
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)
const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))
Toggle.displayName = TogglePrimitive.Root.displayName
export { Toggle, toggleVariants }
</file>

<file path="src/components/ui/tooltip.tsx">
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"
import { cn } from "@/lib/utils"
const TooltipProvider = TooltipPrimitive.Provider
const Tooltip = TooltipPrimitive.Root
const TooltipTrigger = TooltipPrimitive.Trigger
const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName
export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="src/components/ui/use-toast.ts">
import { useToast, toast } from "@/hooks/use-toast";
export { useToast, toast };
</file>

<file path="src/components/CartDrawer.tsx.backup">
import React, { useState, useEffect } from 'react';
import { API_BASE_URL } from '@/constants';
import { useCart } from '@/context/CartContext';
import { useOrders } from '@/context/OrdersContext';
import { useAuth } from '@/hooks/useAuth';
import authService from '@/api/authService';
import apiClient from '@/api/apiClient';
import { useTableInfo } from '@/context/TableContext';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { 
  Trash2, Plus, Minus, X, ArrowRight, 
  Loader2, CreditCard, AlertCircle, Info 
} from 'lucide-react';
import { toast } from 'sonner';
import { cn } from '@/lib/utils';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Sheet, SheetContent, SheetHeader, SheetTitle } from '@/components/ui/sheet';
import { createOrder, OrderResponseData } from '@/api/orderService'; 
import { createStripeCheckoutSession } from '@/api/paymentService';
import { useNavigate } from 'react-router-dom';
import type { Order } from '@/types'; 

// Order type enum to match API
enum OrderType {
  DINE_IN = 'DINE_IN',
  TAKEOUT = 'TAKEOUT'
}

// Order status enum to match API
enum OrderStatus {
  PENDING = 'PENDING',
  PREPARING = 'PREPARING',
  READY = 'READY',
  DELIVERED = 'DELIVERED',
  COMPLETED = 'COMPLETED',
  CANCELLED = 'CANCELLED'
}

// Payment status enum to match API
enum PaymentStatus {
  PENDING = 'PENDING',
  PROCESSING = 'PROCESSING',
  PAID = 'PAID',
  FAILED = 'FAILED',
  REFUNDED = 'REFUNDED'
}

interface CartItem {
  id: string;
  menuItemId?: string; // Make it optional since it might not always be present
  name: string;
  price: number;
  quantity: number;
  specialInstructions?: string;
  modifiers?: Array<{ id: string, name: string, price: number }>;
  image?: string;
}

interface OrderData {
  restaurantId: string;
  tableId: string;
  items: Array<{
    menuItem: string;
    name: string;
    quantity: number;
    price: number;
    subtotal: number;
    specialInstructions: string;
    modifiers?: Array<{ name: string, price: number }>; 
  }>;
  subtotal: number;
  tax: number;
  tip: number;
  total: number;
  orderType: OrderType;
  specialInstructions: string;
  serviceFee: number;
  status: OrderStatus;
  paymentStatus: PaymentStatus;
  orderNumber: string;
}

interface CartDrawerProps {
  isOpen: boolean;
  onClose: () => void;
}

const CartDrawer: React.FC<CartDrawerProps> = ({ isOpen, onClose }) => {
  const { cartItems, removeFromCart: removeItem, updateQuantity, clearCart, cartTotal: subtotal } = useCart();
  const { tableId, restaurantName } = useTableInfo();
  const { isAuthenticated, token } = useAuth();
  const { addOrder } = useOrders();
  const navigate = useNavigate();
  
  // Handle guest login
  const handleGuestLogin = React.useCallback(async (tableId: string) => {
  try {
    // Use XMLHttpRequest which might handle CORS differently than fetch
    console.log('Using XMLHttpRequest for order creation...');
    
    const result = await new Promise<OrderResponseData>((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      const orderApiUrl = import.meta.env.VITE_ORDER_API_URL || 'https://api.inseat.achievengine.com/api/orders';
      xhr.open('POST', orderApiUrl, true);
      xhr.withCredentials = true;
      xhr.setRequestHeader('Content-Type', 'application/json');
      
      if (token) {
        xhr.setRequestHeader('Authorization', `Bearer ${token}`);
        console.log('Added Authorization header with token');
      }
      
      xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 300) {
          const parsedResponse = JSON.parse(xhr.responseText);
          if (parsedResponse._id) {
            resolve(parsedResponse);
          } else if (parsedResponse.success) {
            resolve(parsedResponse.data);
          } else {
            reject(new Error(parsedResponse.error?.message || 'Order creation failed'));
          }
        } else {
          reject(new Error(`Order creation failed with status: ${xhr.status}`));
        }
      };
      
      xhr.onerror = () => reject(new Error('Network error occurred'));
      xhr.send(JSON.stringify(constructedOrderData));
    });
    
    console.log('Order created successfully:', result);
    
    const orderForContext: Order = {
      id: result._id,
      orderNumber: result.orderNumber,
      items: result.items.map(apiItem => ({
        id: apiItem.menuItem,
        menuItemId: apiItem.menuItem,
        name: apiItem.name,
        price: apiItem.price,
        quantity: apiItem.quantity,
        specialInstructions: apiItem.specialInstructions,
        modifiers: apiItem.modifiers?.map(mod => ({ id: mod.name, name: mod.name, price: mod.price })) || []
      })),
      subtotal: result.subtotal,
      tax: result.tax,
      serviceFee: result.serviceFee,
      tip: result.tip,
      total: result.total,
      status: result.status,
      paymentStatus: result.paymentStatus,
      timestamp: new Date(result.createdAt),
      tableId: result.tableId,
      specialInstructions: result.specialInstructions
    };
    
    addOrder(orderForContext);
    localStorage.setItem('pending_order_id', result._id);
    clearCart();
    onClose();
    
    toast.success('Order placed successfully!');
    
    setTimeout(() => {
      navigate(`/my-orders?table=${tableId}`);
    }, 1000);
  } catch (error) {
    console.error('Error in order creation process:', error);
    toast.error(error instanceof Error ? error.message : 'Failed to create your order');
    setIsProcessing(false);
    setError(error instanceof Error ? error.message : 'Failed to create your order');
    throw error;
  }
      console.error('Error in order creation process:', orderError);
      toast.error(orderError instanceof Error ? orderError.message : 'Failed to create your order');
      setIsProcessing(false);
      setError(orderError instanceof Error ? orderError.message : 'Failed to create your order');
      throw orderError; // Re-throw to be caught by the caller
    }
  };

  // Handle guest login
  const handleGuestLogin = React.useCallback(async (tableId: string) => {
</file>

<file path="src/components/CartDrawer.tsx.temp">
const CartDrawer: React.FC<CartDrawerProps> = ({ isOpen, onClose }) => {
  const { cartItems, removeFromCart: removeItem, updateQuantity, clearCart, cartTotal: subtotal } = useCart();
  const { tableId, restaurantName } = useTableInfo();
  const { isAuthenticated, token } = useAuth();
  const { addOrder } = useOrders();
  const navigate = useNavigate();
  
  const handleGuestLogin = React.useCallback(async (tableId: string) => {
    try {
      console.log('Attempting guest login with tableId:', tableId);
      
      const apiBaseUrl = import.meta.env.VITE_AUTH_API_URL || '/api/auth';
      
      const response = await fetch(, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          tableId: tableId || '',
          deviceId: localStorage.getItem('device_id') || 
        }),
        credentials: 'include'
      });
      
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.token) {
          console.log('Guest token received:', data.token.substring(0, 10) + '...');
          
          localStorage.setItem('auth_token', data.token);
          document.cookie = ;
          document.cookie = ;
          
          return true;
        }
      }
      
      console.error('Guest login failed: No token in response');
      return false;
    } catch (error) {
      console.error('Guest login error:', error);
      return false;
    }
  }, []);

  const [stage, setStage] = useState<'cart' | 'checkout'>('cart');
  const [specialInstructions, setSpecialInstructions] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState('');
  const [orderType, setOrderType] = useState<OrderType>(OrderType.DINE_IN);
  
  const processOrder = async () => {
    try {
      console.log('Using XMLHttpRequest for order creation...');
      
      const result = await new Promise<OrderResponseData>((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        const orderApiUrl = import.meta.env.VITE_ORDER_API_URL || 'https://api.inseat.achievengine.com/api/orders';
        xhr.open('POST', orderApiUrl, true);
        xhr.withCredentials = true;
        xhr.setRequestHeader('Content-Type', 'application/json');
        
        if (token) {
          xhr.setRequestHeader('Authorization', );
          console.log('Added Authorization header with token');
        }
        
        xhr.onload = function() {
          if (xhr.status >= 200 && xhr.status < 300) {
            const parsedResponse = JSON.parse(xhr.responseText);
            if (parsedResponse._id) {
              resolve(parsedResponse);
            } else if (parsedResponse.success) {
              resolve(parsedResponse.data);
            } else {
              reject(new Error(parsedResponse.error?.message || 'Order creation failed'));
            }
          } else {
            reject(new Error());
          }
        };
        
        xhr.onerror = () => reject(new Error('Network error occurred'));
        xhr.send(JSON.stringify(constructedOrderData));
      });
      
      console.log('Order created successfully:', result);
      
      const orderForContext: Order = {
        id: result._id,
        orderNumber: result.orderNumber,
        items: result.items.map(apiItem => ({
          id: apiItem.menuItem,
          menuItemId: apiItem.menuItem,
          name: apiItem.name,
          price: apiItem.price,
          quantity: apiItem.quantity,
          specialInstructions: apiItem.specialInstructions,
          modifiers: apiItem.modifiers?.map(mod => ({ id: mod.name, name: mod.name, price: mod.price })) || []
        })),
        subtotal: result.subtotal,
        tax: result.tax,
        serviceFee: result.serviceFee,
        tip: result.tip,
        total: result.total,
        status: result.status,
        paymentStatus: result.paymentStatus,
        timestamp: new Date(result.createdAt),
        tableId: result.tableId,
        specialInstructions: result.specialInstructions
      };
      
      addOrder(orderForContext);
      localStorage.setItem('pending_order_id', result._id);
      clearCart();
      onClose();
      
      toast.success('Order placed successfully!');
      
      setTimeout(() => {
        navigate();
      }, 1000);
    } catch (error) {
      console.error('Error in order creation process:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to create your order');
      setIsProcessing(false);
      setError(error instanceof Error ? error.message : 'Failed to create your order');
      throw error;
    }
  };
</file>

<file path="src/components/CartDrawer.tsx.tmp">
import React, { useState, useEffect } from 'react';
import { API_BASE_URL } from '@/constants';
import { useCart } from '@/context/CartContext';
import { useOrders } from '@/context/OrdersContext';
import { useAuth } from '@/hooks/useAuth';
import authService from '@/api/authService';
import apiClient from '@/api/apiClient';
import { useTableInfo } from '@/context/TableContext';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { 
  Trash2, Plus, Minus, X, ArrowRight, 
  Loader2, CreditCard, AlertCircle, Info 
} from 'lucide-react';
import { toast } from 'sonner';
import { cn } from '@/lib/utils';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Sheet, SheetContent, SheetHeader, SheetTitle } from '@/components/ui/sheet';
import { createOrder, OrderResponseData } from '@/api/orderService'; 
import { createStripeCheckoutSession } from '@/api/paymentService';
import { useNavigate } from 'react-router-dom';
import type { Order } from '@/types'; 

// Order type enum to match API
enum OrderType {
  DINE_IN = 'DINE_IN',
  TAKEOUT = 'TAKEOUT'
}

// Order status enum to match API
enum OrderStatus {
  PENDING = 'PENDING',
  PREPARING = 'PREPARING',
  READY = 'READY',
  DELIVERED = 'DELIVERED',
  COMPLETED = 'COMPLETED',
  CANCELLED = 'CANCELLED'
}

// Payment status enum to match API
enum PaymentStatus {
  PENDING = 'PENDING',
  PROCESSING = 'PROCESSING',
  PAID = 'PAID',
  FAILED = 'FAILED',
  REFUNDED = 'REFUNDED'
}

interface CartItem {
  id: string;
  menuItemId?: string; // Make it optional since it might not always be present
  name: string;
  price: number;
  quantity: number;
  specialInstructions?: string;
  modifiers?: Array<{ id: string, name: string, price: number }>;
  image?: string;
}

interface OrderData {
  restaurantId: string;
  tableId: string;
  items: Array<{
    menuItem: string;
    name: string;
    quantity: number;
    price: number;
    subtotal: number;
    specialInstructions: string;
    modifiers?: Array<{ name: string, price: number }>; 
  }>;
  subtotal: number;
  tax: number;
  tip: number;
  total: number;
  orderType: OrderType;
  specialInstructions: string;
  serviceFee: number;
  status: OrderStatus;
  paymentStatus: PaymentStatus;
  orderNumber: string;
}

interface CartDrawerProps {
  isOpen: boolean;
  onClose: () => void;
}

const CartDrawer: React.FC<CartDrawerProps> = ({ isOpen, onClose }) => {
  const { cartItems, removeFromCart: removeItem, updateQuantity, clearCart, cartTotal: subtotal } = useCart();
  const { tableId, restaurantName } = useTableInfo();
  const { isAuthenticated, token } = useAuth();
  const { addOrder } = useOrders();
  const navigate = useNavigate();
  
  // Handle guest login
  const handleGuestLogin = React.useCallback(async (tableId: string) => {
    try {
      console.log('Attempting guest login with tableId:', tableId);
      
      // Get API base URL from environment variables
      const apiBaseUrl = import.meta.env.VITE_AUTH_API_URL || 'https://api.inseat.achievengine.com/api/auth';
      
      // Request a guest token directly from the server endpoint
      const response = await fetch(`${apiBaseUrl}/guest-token`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          tableId: tableId || '',
          deviceId: localStorage.getItem('device_id') || `device_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`
        }),
        credentials: 'include'
      });
      
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.token) {
          console.log('Guest token received:', data.token.substring(0, 10) + '...');
          
          // Store token in both localStorage and cookies for redundancy
          localStorage.setItem('auth_token', data.token);
          document.cookie = `auth_token=${data.token}; path=/; max-age=86400; SameSite=Lax`;
          document.cookie = `access_token=${data.token}; path=/; max-age=86400; SameSite=Lax`;
          
          return true;
        }
      }
      
      console.error('Guest login failed: No token in response');
      return false;
    } catch (error) {
      console.error('Guest login error:', error);
      return false;
    }
  }, []);
  const [stage, setStage] = useState<'cart' | 'checkout'>('cart');
  const [specialInstructions, setSpecialInstructions] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState('');
  const [orderType, setOrderType] = useState<OrderType>(OrderType.DINE_IN);
  
  // Tax and fees calculations (as per API specifications)
  const taxRate = 0.08; // 8% tax
  const serviceFeeRate = 0.05; // 5% service fee
  const tax = subtotal * taxRate;
  const serviceFee = subtotal * serviceFeeRate;
  const tipAmount = 0; // Default tip amount (can be updated)
  const total = subtotal + tax + serviceFee + tipAmount;
  
  // Reset stage when drawer closes
  useEffect(() => {
    if (!isOpen) {
      // Small delay to prevent visual glitches during closing animation
      setTimeout(() => {
        setStage('cart');
        setIsProcessing(false);
      }, 300);
    }
  }, [isOpen]);
  
  // Helper function to process the order
  const processOrder = async () => {
    try {
      console.log('Processing order with orderService...');
      
      // Determine restaurant ID (either from context or extract from tableId)
      const localRestaurantId = restaurantName === 'InSeat' 
        ? '65f456b06c9dfd001b6b1234' 
        : tableId.split('-')[0]; // Ensure tableId is available here or passed appropriately
      
      // Format items according to API schema
      const formattedItems = cartItems.map(item => {
        // Ensure we have a valid string for menuItem
        const menuItemId = ('menuItemId' in item && item.menuItemId) || item.id;
        
        // Ensure menuItem is always a string
        const menuItem = String(menuItemId || '');
        
        return {
          menuItem,
          name: item.name,
          quantity: item.quantity,
          price: item.price,
          subtotal: item.price * item.quantity,
          specialInstructions: item.specialInstructions || specialInstructions || '',
          modifiers: item.modifiers
        };
      });
      
      // Format order data according to API schema
      const constructedOrderData: OrderData = {
        restaurantId: localRestaurantId, // Use locally determined restaurantId
        tableId,
        items: formattedItems,
        subtotal,
        tax,
        tip: tipAmount,
        total,
        orderType,
        specialInstructions: specialInstructions || '',
        serviceFee, // Include the service fee in the order data
        status: OrderStatus.PENDING, // Required field - using enum value
        paymentStatus: PaymentStatus.PENDING, // Required field - using enum value
        orderNumber: `ORD-${Date.now()}-${Math.floor(Math.random() * 1000)}` // Required field
      };
      
      console.log('Order data prepared:', JSON.stringify(constructedOrderData));
      
      // Try to get a token from all possible sources
      let token = localStorage.getItem('auth_token');
      
      // If no token found yet, try to extract from cookies
      if (!token) {
        const cookies = document.cookie.split(';');
        const tokenCookie = cookies.find(cookie => 
          cookie.trim().startsWith('auth_token=') || 
          cookie.trim().startsWith('access_token=')
        );
        
        if (tokenCookie) {
          token = tokenCookie.split('=')[1].trim();
        }
      }
      
      // If still no token, try to get one from the guest token endpoint
      if (!token) {
        console.log('No token found, attempting to get a guest token...');
        
        try {
          // Create a device ID if not already stored
          const deviceId = localStorage.getItem('device_id') || `device_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
          if (!localStorage.getItem('device_id')) {
            localStorage.setItem('device_id', deviceId);
          }
          
          // Request a guest token from the server - use the correct endpoint
          const apiBaseUrl = import.meta.env.VITE_AUTH_API_URL || 'https://api.inseat.achievengine.com/api/auth';
          const guestTokenResponse = await fetch(`${apiBaseUrl}/guest-token`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              tableId: tableId || '',
              deviceId
            }),
            credentials: 'include'
          });
          
          if (guestTokenResponse.ok) {
            const guestData = await guestTokenResponse.json();
            
            if (guestData.success && guestData.token) {
              console.log('Guest token obtained successfully');
              token = guestData.token;
              localStorage.setItem('auth_token', guestData.token);
              document.cookie = `auth_token=${guestData.token}; path=/; max-age=86400; SameSite=Lax`;
            }
          }
        } catch (error) {
          console.error('Error getting guest token:', error);
        }
      }
      
      // If we still don't have a token, make a regular auth check
      if (!token) {
        console.log('Attempting regular auth check as fallback...');
        const apiBaseUrl = import.meta.env.VITE_AUTH_API_URL || 'https://api.inseat.achievengine.com/api/auth';
        const authResponse = await fetch(`${apiBaseUrl}/me`, {
          method: 'GET',
          credentials: 'include'
        });
        
        if (authResponse.ok) {
          const authData = await authResponse.json();
          console.log('Auth check successful:', authData);
          
          if (authData.token) {
            token = authData.token;
            localStorage.setItem('auth_token', authData.token);
          }
        } else {
          console.error('Authentication check failed:', await authResponse.text());
          // Don't throw here, we'll try to continue with the order anyway
        }
      }
      
      console.log('Using token for order placement:', token ? 'Token available' : 'No token available');
      
      // If we have a token, make sure it's saved to localStorage for future requests
      if (token && !localStorage.getItem('auth_token')) {
        localStorage.setItem('auth_token', token);
        console.log('Saved token to localStorage');
      }
      
      try {
        // Use XMLHttpRequest which might handle CORS differently than fetch
        console.log('Using XMLHttpRequest for order creation...');
        
        // Create a promise wrapper around XMLHttpRequest with proper typing
        const result = await new Promise<OrderResponseData>((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          const orderApiUrl = import.meta.env.VITE_ORDER_API_URL || 'https://api.inseat.achievengine.com/api/orders';
          xhr.open('POST', orderApiUrl, true);
          xhr.withCredentials = true; // Essential for sending cookies
          xhr.setRequestHeader('Content-Type', 'application/json');
          
          // Add Authorization header if token is available
          if (token) {
            xhr.setRequestHeader('Authorization', `Bearer ${token}`);
            console.log('Added Authorization header with token');
          } else {
            console.warn('No token available for Authorization header');
            
            // Last attempt to get token from cookies directly
            const cookieToken = document.cookie
              .split(';')
              .find(cookie => cookie.trim().startsWith('auth_token='))
              ?.split('=')[1];
              
            if (cookieToken) {
              xhr.setRequestHeader('Authorization', `Bearer ${cookieToken}`);
              console.log('Added Authorization header with cookie token');
            } else {
              console.warn('No authentication token available. Order creation may fail.');
            }
          }
          
          xhr.onload = function() {
            console.log('XHR response received:', {
              status: xhr.status,
              responseText: xhr.responseText
            });
            
            if (xhr.status >= 200 && xhr.status < 300) {
              try {
                // The response could be in different formats depending on the API
                const parsedResponse = JSON.parse(xhr.responseText);
                console.log('Parsed response:', parsedResponse);
                
                // Check if response has success property (API v1 format)
                if (parsedResponse.success !== undefined) {
                  if (parsedResponse.success) {
                    resolve(parsedResponse.data);
                  } else {
                    console.error('Order creation failed despite 200 status:', parsedResponse.error);
                    reject(new Error(parsedResponse.error?.message || 'Order creation failed'));
                  }
                } 
                // If no success property but has _id, it's a direct order object (API v2 format)
                else if (parsedResponse._id) {
                  console.log('Direct order object returned:', parsedResponse);
                  // Use the order object directly
                  resolve(parsedResponse);
                } 
                // Unknown response format
                else {
                  console.error('Unknown response format:', parsedResponse);
                  reject(new Error('Unknown response format'));
                }
              } catch (e) {
                console.error('Failed to parse response:', e);
                reject(new Error('Failed to parse response'));
              }
            } else {
              console.error(`Order creation failed with status: ${xhr.status}`, xhr.responseText);
              try {
                const errorData = JSON.parse(xhr.responseText);
                reject(new Error(errorData.error || `Order creation failed with status: ${xhr.status}`));
              } catch (e) {
                reject(new Error(`Order creation failed with status: ${xhr.status}`));
              }
            }
          };
          
          xhr.onerror = function() {
            console.error('XHR error:', xhr);
            reject(new Error('Network error occurred'));
          };
          
          xhr.send(JSON.stringify(constructedOrderData));
        });
        
        console.log('Order placed successfully:', result);
        toast.success('Order placed successfully!');
      
      
      if (!result) {
        console.log('Order creation returned null - authentication failed and user redirected');
        return null;
      }
      
      console.log('Order placed successfully:', result);
      toast.success('Order placed successfully!');
    
      // Transform OrderResponseData to Order type for the context
      const orderForContext: Order = {
        id: result._id, // Map _id to id
        orderNumber: result.orderNumber,
        // Ensure items are compatible with CartItem[]
        // This might need a more detailed mapping if OrderItem and CartItem are very different
        // For now, assuming they are structurally similar enough or that CartItem is flexible
        items: result.items.map(apiItem => ({
          id: apiItem.menuItem, // Assuming menuItem from API maps to id in CartItem
          menuItemId: apiItem.menuItem,
          name: apiItem.name,
          price: apiItem.price,
          quantity: apiItem.quantity,
          // image: apiItem.image, // If CartItem expects an image and apiItem has it
          specialInstructions: apiItem.specialInstructions,
          modifiers: apiItem.modifiers?.map(mod => ({ id: mod.name, name: mod.name, price: mod.price })) || [] // Example mapping for modifiers
        })),
        subtotal: result.subtotal,
        tax: result.tax,
        serviceFee: result.serviceFee,
        tip: result.tip,
        total: result.total,
        status: result.status, // Assuming OrderStatus enum values align
        paymentStatus: result.paymentStatus, // Assuming PaymentStatus enum values align
        timestamp: new Date(result.createdAt), // Convert createdAt string to Date
        tableId: result.tableId,
        specialInstructions: result.specialInstructions
      };

      addOrder(orderForContext);

      console.log('Order created successfully:', result);
      
      // Store order ID in localStorage for retrieval after payment
      localStorage.setItem('pending_order_id', result._id);
      
      // Clear the cart and close the drawer
      clearCart();
      onClose();
      
      // Show success message
      toast.success('Order placed successfully!');
      
      // The payment status should remain PENDING by default when an order is created
      // It will be updated to PAID by Stripe webhook when payment is completed
      console.log('Order created with PENDING payment status - will be updated when payment is processed');
      
      // Add a small delay before redirecting to ensure the toast is shown
      setTimeout(() => {
        console.log('Redirecting to my-orders page with table ID:', tableId);
        navigate(`/my-orders?table=${tableId}`);
      }, 1000);
    } catch (orderError) {
      console.error('Error in order creation process:', orderError);
      toast.error(orderError instanceof Error ? orderError.message : 'Failed to create your order');
      setIsProcessing(false);
      setError(orderError instanceof Error ? orderError.message : 'Failed to create your order');
      throw orderError; // Re-throw to be caught by the caller
    }
  };

  // Handle guest login
  const handleGuestLogin = React.useCallback(async (tableId: string) => {
    try {
      console.log('Attempting guest login with tableId:', tableId);
      
      // Get API base URL from environment variables
      const apiBaseUrl = import.meta.env.VITE_AUTH_API_URL || `${API_BASE_URL}/api/auth`;
      
      // Request a guest token directly from the server endpoint
      const response = await fetch(`${apiBaseUrl}/guest-token`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          tableId: tableId || '',
          deviceId: localStorage.getItem('device_id') || `device_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`
        }),
        credentials: 'include'
      });
      
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.token) {
          console.log('Guest token received:', data.token.substring(0, 10) + '...');
          
          // Store token in both localStorage and cookies for redundancy
          localStorage.setItem('auth_token', data.token);
          document.cookie = `auth_token=${data.token}; path=/; max-age=86400; SameSite=Lax`;
          document.cookie = `access_token=${data.token}; path=/; max-age=86400; SameSite=Lax`;
          
          return true;
        }
      }
      
      console.error('Guest login failed: No token in response');
      return false;
    } catch (error) {
      console.error('Guest login error:', error);
      return false;
    }
  }, []);
  
  const handleCheckout = () => {
    if (cartItems.length === 0) {
      toast.error("Your cart is empty");
      return;
    }
    
    // Move to checkout stage
    setStage('checkout');
  };
  
  const handlePlaceOrder = async (): Promise<void> => {
    console.log('handlePlaceOrder function entered - CartDrawer.tsx');
    try {
      // Validate cart is not empty
      if (cartItems.length === 0) {
        toast.error('Your cart is empty. Please add items to place an order.');
        return;
      }
      
      // Validate table ID is present
      if (!tableId) {
        toast.error("Table information is missing. Please scan a table QR code first.");
        onClose();
        navigate('/scan');
        return;
      }
      
      if (!tableId) {
        toast.error("Table information is missing. Please scan a table QR code first.");
        onClose();
        navigate('/scan');
        return;
      }
      
      setIsProcessing(true);
      
      // Process the order (this will create the order in the backend and get the order ID)
      await processOrder();
    } catch (error) {
      console.error('Error placing order:', error);
      setIsProcessing(false);
      toast.error(error instanceof Error ? error.message : 'Failed to place order');
      setError(error instanceof Error ? error.message : 'Failed to place order');
    }
  };
  
  const handleClose = () => {
    if (isProcessing) {
      // If processing is in progress, show a confirmation dialog
      if (window.confirm("Your order is still being processed. Are you sure you want to close?")) {
        onClose();
      }
    } else {
      onClose();
    }
  };
  
  let content;
  
  if (stage === 'checkout') {
    // Checkout stage UI
    content = (
      <div className="flex flex-col h-full">
        <SheetHeader className="p-4 border-b border-[#2D303E]">
          <div className="flex items-center justify-between">
            <SheetTitle className="text-xl font-semibold">Checkout</SheetTitle>
            <Button
              variant="ghost"
              size="icon"
              onClick={handleClose}
              disabled={isProcessing}
            >
              <X className="h-5 w-5" />
            </Button>
          </div>
        </SheetHeader>
        
        <ScrollArea className="flex-1">
          <div className="p-4 space-y-6">
            {/* Order type selection */}
            <div className="space-y-2">
              <h3 className="font-medium">Order Type</h3>
              <div className="flex gap-2">
                <Button
                  variant={orderType === OrderType.DINE_IN ? "default" : "outline"}
                  size="sm"
                  className={cn(
                    orderType === OrderType.DINE_IN 
                      ? "bg-delft-blue hover:bg-delft-blue/90" 
                      : ""
                  )}
                  onClick={() => setOrderType(OrderType.DINE_IN)}
                  disabled={isProcessing}
                >
                  Dine In
                </Button>
                <Button
                  variant={orderType === OrderType.TAKEOUT ? "default" : "outline"}
                  size="sm"
                  className={cn(
                    orderType === OrderType.TAKEOUT 
                      ? "bg-delft-blue hover:bg-delft-blue/90" 
                      : ""
                  )}
                  onClick={() => setOrderType(OrderType.TAKEOUT)}
                  disabled={isProcessing}
                >
                  Takeout
                </Button>
              </div>
            </div>
            
            {/* Cart items summary */}
            <div className="space-y-2">
              <div className="flex justify-between items-center">
                <h3 className="font-medium">Order Items</h3>
                <Button
                  variant="link"
                  size="sm"
                  className="h-auto p-0 text-delft-blue"
                  onClick={() => setStage('cart')}
                  disabled={isProcessing}
                >
                  Edit
                </Button>
              </div>
              <div className="space-y-2">
                {cartItems.map((item) => (
                  <div key={item.id} className="flex justify-between text-sm">
                    <div className="flex">
                      <span className="font-medium">{item.quantity}x</span>
                      <span className="ml-2">{item.name}</span>
                    </div>
                    <span>${(item.price * item.quantity).toFixed(2)}</span>
                  </div>
                ))}
              </div>
            </div>
            
            {/* Order notes */}
            <div className="space-y-2">
              <h3 className="font-medium">Special Instructions</h3>
              <Textarea 
                placeholder="Add any special instructions for your order..."
                value={specialInstructions}
                onChange={(e) => setSpecialInstructions(e.target.value)}
                className="resize-none"
              />
            </div>
          </div>
        </ScrollArea>
        
        <div className="border-t border-[#2D303E] p-4 space-y-4">
          <div className="space-y-2">
            <div className="flex justify-between">
              <span className="text-muted-foreground">Subtotal</span>
              <span>${subtotal.toFixed(2)}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">Tax ({(taxRate * 100).toFixed(0)}%)</span>
              <span>${tax.toFixed(2)}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">Service Fee ({(serviceFeeRate * 100).toFixed(0)}%)</span>
              <span>${serviceFee.toFixed(2)}</span>
            </div>
            {tipAmount > 0 && (
              <div className="flex justify-between">
                <span className="text-muted-foreground">Tip</span>
                <span>${tipAmount.toFixed(2)}</span>
              </div>
            )}
            <div className="flex justify-between font-medium text-lg pt-2 border-t border-[#2D303E]">
              <span>Total</span>
              <span>${total.toFixed(2)}</span>
            </div>
          </div>
          
          <Button 
            onClick={() => { 
              console.log('Place Order button clicked - inline in CartDrawer.tsx'); 
              handlePlaceOrder(); 
            }}
            className="w-full bg-delft-blue hover:bg-delft-blue/90 text-white"
            disabled={isProcessing}
          >
            {isProcessing ? (
              <div className="flex items-center">
                <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Processing...
              </div>
            ) : (
              <>
                Place Order
                <ArrowRight className="ml-2 h-4 w-4" />
              </>
            )}
          </Button>
        </div>
      </div>
    );
  } else {
    // Cart stage UI
    content = (
      <div className="flex flex-col h-full">
        <SheetHeader className="p-4 border-b border-[#2D303E]">
          <div className="flex items-center justify-between">
            <SheetTitle className="text-xl font-semibold">Your Cart</SheetTitle>
            <Button
              variant="ghost"
              size="icon"
              onClick={handleClose}
            >
              <X className="h-5 w-5" />
            </Button>
          </div>
        </SheetHeader>
        
        <ScrollArea className="flex-1 p-4">
          {cartItems.length === 0 ? (
            <div className="flex flex-col items-center justify-center h-full text-center">
              <p className="text-muted-foreground mb-4">Your cart is empty</p>
              <Button onClick={handleClose} variant="outline">
                Continue Shopping
              </Button>
            </div>
          ) : (
            <div className="space-y-4">
              {cartItems.map((item) => (
                <div
                  key={item.id}
                  className="flex gap-3 p-3 rounded-lg bg-[#1F1D2B] border border-[#2D303E]"
                >
                  {item.image && (
                    <img
                      src={item.image}
                      alt={item.name}
                      className="w-20 h-20 object-cover rounded-md"
                      onError={(e) => {
                        const target = e.target as HTMLImageElement;
                        target.src = 'https://source.unsplash.com/featured/?food';
                      }}
                    />
                  )}
                  
                  <div className="flex-1">
                    <div className="flex justify-between">
                      <h3 className="font-medium">{item.name}</h3>
                      <Button
                        variant="ghost"
                        size="icon"
                        className="h-6 w-6 -mr-1 -mt-1 text-muted-foreground"
                        onClick={() => removeItem(item.id)}
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </div>
                    
                    <p className="text-sm text-delft-blue mt-1">${item.price.toFixed(2)}</p>
                    
                    {item.modifiers && item.modifiers.length > 0 && (
                      <div className="mt-1 text-xs text-muted-foreground">
                        {item.modifiers.map((mod, index) => (
                          <div key={index} className="flex justify-between">
                            <span>{mod.name}</span>
                            {mod.price > 0 && (
                              <span>+${mod.price.toFixed(2)}</span>
                            )}
                          </div>
                        ))}
                      </div>
                    )}
                    
                    {item.specialInstructions && (
                      <div className="mt-1 text-xs italic text-muted-foreground">
                        {item.specialInstructions}
                      </div>
                    )}
                    
                    <div className="flex items-center justify-between mt-2">
                      <div className="flex items-center gap-2">
                        <Button
                          variant="outline"
                          size="icon"
                          className="h-7 w-7"
                          onClick={() => updateQuantity(item.id, item.quantity - 1)}
                          disabled={item.quantity <= 1}
                        >
                          <Minus className="h-3 w-3" />
                        </Button>
                        <span className="w-5 text-center text-sm">{item.quantity}</span>
                        <Button
                          variant="outline"
                          size="icon"
                          className="h-7 w-7"
                          onClick={() => updateQuantity(item.id, item.quantity + 1)}
                        >
                          <Plus className="h-3 w-3" />
                        </Button>
                      </div>
                      
                      <span className="font-medium">
                        ${(item.price * item.quantity).toFixed(2)}
                      </span>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}
        </ScrollArea>
        
        {cartItems.length > 0 && (
          <div className="border-t border-[#2D303E] p-4 space-y-3">
            <div className="flex justify-between font-medium">
              <span>Subtotal</span>
              <span>${subtotal.toFixed(2)}</span>
            </div>
            <Button
              className="w-full bg-delft-blue hover:bg-delft-blue/90 text-white"
              onClick={handleCheckout}
            >
              Continue to Checkout
              <ArrowRight className="ml-2 h-4 w-4" />
            </Button>
          </div>
        )}
      </div>
    );
  }

  return (
    <Sheet open={isOpen} onOpenChange={handleClose}>
      <SheetContent 
        side="right" 
        className="w-full sm:max-w-md border-l border-[#2D303E] bg-[#16141F] p-0 max-h-screen"
      >
        {content}
      </SheetContent>
    </Sheet>
  );
};

export default CartDrawer;
</file>

<file path="src/components/CartDrawer.tsx.tmp2">
import React, { useState, useEffect } from 'react';
import { API_BASE_URL } from '@/constants';
import { useCart } from '@/context/CartContext';
import { useOrders } from '@/context/OrdersContext';
import { useAuth } from '@/hooks/useAuth';
import authService from '@/api/authService';
import apiClient from '@/api/apiClient';
import { useTableInfo } from '@/context/TableContext';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { 
  Trash2, Plus, Minus, X, ArrowRight, 
  Loader2, CreditCard, AlertCircle, Info 
} from 'lucide-react';
import { toast } from 'sonner';
import { cn } from '@/lib/utils';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Sheet, SheetContent, SheetHeader, SheetTitle } from '@/components/ui/sheet';
import { createOrder, OrderResponseData } from '@/api/orderService'; 
import { createStripeCheckoutSession } from '@/api/paymentService';
import { useNavigate } from 'react-router-dom';
import type { Order } from '@/types'; 

// Order type enum to match API
enum OrderType {
  DINE_IN = 'DINE_IN',
  TAKEOUT = 'TAKEOUT'
}

// Order status enum to match API
enum OrderStatus {
  PENDING = 'PENDING',
  PREPARING = 'PREPARING',
  READY = 'READY',
  DELIVERED = 'DELIVERED',
  COMPLETED = 'COMPLETED',
  CANCELLED = 'CANCELLED'
}

// Payment status enum to match API
enum PaymentStatus {
  PENDING = 'PENDING',
  PROCESSING = 'PROCESSING',
  PAID = 'PAID',
  FAILED = 'FAILED',
  REFUNDED = 'REFUNDED'
}

interface CartItem {
  id: string;
  menuItemId?: string; // Make it optional since it might not always be present
  name: string;
  price: number;
  quantity: number;
  specialInstructions?: string;
  modifiers?: Array<{ id: string, name: string, price: number }>;
  image?: string;
}

interface OrderData {
  restaurantId: string;
  tableId: string;
  items: Array<{
    menuItem: string;
    name: string;
    quantity: number;
    price: number;
    subtotal: number;
    specialInstructions: string;
    modifiers?: Array<{ name: string, price: number }>; 
  }>;
  subtotal: number;
  tax: number;
  tip: number;
  total: number;
  orderType: OrderType;
  specialInstructions: string;
  serviceFee: number;
  status: OrderStatus;
  paymentStatus: PaymentStatus;
  orderNumber: string;
}

interface CartDrawerProps {
  isOpen: boolean;
  onClose: () => void;
}

const CartDrawer: React.FC<CartDrawerProps> = ({ isOpen, onClose }) => {
  const { cartItems, removeFromCart: removeItem, updateQuantity, clearCart, cartTotal: subtotal } = useCart();
  const { tableId, restaurantName } = useTableInfo();
  const { isAuthenticated, token } = useAuth();
  const { addOrder } = useOrders();
  const navigate = useNavigate();
  
  // Handle guest login
  const handleGuestLogin = React.useCallback(async (tableId: string) => {
    try {
      console.log('Attempting guest login with tableId:', tableId);
      
      // Get API base URL from environment variables
      const apiBaseUrl = import.meta.env.VITE_AUTH_API_URL || 'https://api.inseat.achievengine.com/api/auth';
      
      // Request a guest token directly from the server endpoint
      const response = await fetch(`${apiBaseUrl}/guest-token`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          tableId: tableId || '',
          deviceId: localStorage.getItem('device_id') || `device_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`
        }),
        credentials: 'include'
      });
      
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.token) {
          console.log('Guest token received:', data.token.substring(0, 10) + '...');
          
          // Store token in both localStorage and cookies for redundancy
          localStorage.setItem('auth_token', data.token);
          document.cookie = `auth_token=${data.token}; path=/; max-age=86400; SameSite=Lax`;
          document.cookie = `access_token=${data.token}; path=/; max-age=86400; SameSite=Lax`;
          
          return true;
        }
      }
      
      console.error('Guest login failed: No token in response');
      return false;
    } catch (error) {
      console.error('Guest login error:', error);
      return false;
    }
  }, []);
  const [stage, setStage] = useState<'cart' | 'checkout'>('cart');
  const [specialInstructions, setSpecialInstructions] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState('');
  const [orderType, setOrderType] = useState<OrderType>(OrderType.DINE_IN);
  
  // Tax and fees calculations (as per API specifications)
  const taxRate = 0.08; // 8% tax
  const serviceFeeRate = 0.05; // 5% service fee
  const tax = subtotal * taxRate;
  const serviceFee = subtotal * serviceFeeRate;
  const tipAmount = 0; // Default tip amount (can be updated)
  const total = subtotal + tax + serviceFee + tipAmount;
  
  // Reset stage when drawer closes
  useEffect(() => {
    if (!isOpen) {
      // Small delay to prevent visual glitches during closing animation
      setTimeout(() => {
        setStage('cart');
        setIsProcessing(false);
      }, 300);
    }
  }, [isOpen]);
  
  // Helper function to process the order
  const processOrder = async () => {
    try {
      console.log('Processing order with orderService...');
      
      // Determine restaurant ID (either from context or extract from tableId)
      const localRestaurantId = restaurantName === 'InSeat' 
        ? '65f456b06c9dfd001b6b1234' 
        : tableId.split('-')[0]; // Ensure tableId is available here or passed appropriately
      
      // Format items according to API schema
      const formattedItems = cartItems.map(item => {
        // Ensure we have a valid string for menuItem
        const menuItemId = ('menuItemId' in item && item.menuItemId) || item.id;
        
        // Ensure menuItem is always a string
        const menuItem = String(menuItemId || '');
        
        return {
          menuItem,
          name: item.name,
          quantity: item.quantity,
          price: item.price,
          subtotal: item.price * item.quantity,
          specialInstructions: item.specialInstructions || specialInstructions || '',
          modifiers: item.modifiers
        };
      });
      
      // Format order data according to API schema
      const constructedOrderData: OrderData = {
        restaurantId: localRestaurantId, // Use locally determined restaurantId
        tableId,
        items: formattedItems,
        subtotal,
        tax,
        tip: tipAmount,
        total,
        orderType,
        specialInstructions: specialInstructions || '',
        serviceFee, // Include the service fee in the order data
        status: OrderStatus.PENDING, // Required field - using enum value
        paymentStatus: PaymentStatus.PENDING, // Required field - using enum value
        orderNumber: `ORD-${Date.now()}-${Math.floor(Math.random() * 1000)}` // Required field
      };
      
      console.log('Order data prepared:', JSON.stringify(constructedOrderData));
      
      // Try to get a token from all possible sources
      let token = localStorage.getItem('auth_token');
      
      // If no token found yet, try to extract from cookies
      if (!token) {
        const cookies = document.cookie.split(';');
        const tokenCookie = cookies.find(cookie => 
          cookie.trim().startsWith('auth_token=') || 
          cookie.trim().startsWith('access_token=')
        );
        
        if (tokenCookie) {
          token = tokenCookie.split('=')[1].trim();
        }
      }
      
      // If still no token, try to get one from the guest token endpoint
      if (!token) {
        console.log('No token found, attempting to get a guest token...');
        
        try {
          // Create a device ID if not already stored
          const deviceId = localStorage.getItem('device_id') || `device_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
          if (!localStorage.getItem('device_id')) {
            localStorage.setItem('device_id', deviceId);
          }
          
          // Request a guest token from the server - use the correct endpoint
          const apiBaseUrl = import.meta.env.VITE_AUTH_API_URL || 'https://api.inseat.achievengine.com/api/auth';
          const guestTokenResponse = await fetch(`${apiBaseUrl}/guest-token`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              tableId: tableId || '',
              deviceId
            }),
            credentials: 'include'
          });
          
          if (guestTokenResponse.ok) {
            const guestData = await guestTokenResponse.json();
            
            if (guestData.success && guestData.token) {
              console.log('Guest token obtained successfully');
              token = guestData.token;
              localStorage.setItem('auth_token', guestData.token);
              document.cookie = `auth_token=${guestData.token}; path=/; max-age=86400; SameSite=Lax`;
            }
          }
        } catch (error) {
          console.error('Error getting guest token:', error);
        }
      }
      
      // If we still don't have a token, make a regular auth check
      if (!token) {
        console.log('Attempting regular auth check as fallback...');
        const apiBaseUrl = import.meta.env.VITE_AUTH_API_URL || 'https://api.inseat.achievengine.com/api/auth';
        const authResponse = await fetch(`${apiBaseUrl}/me`, {
          method: 'GET',
          credentials: 'include'
        });
        
        if (authResponse.ok) {
          const authData = await authResponse.json();
          console.log('Auth check successful:', authData);
          
          if (authData.token) {
            token = authData.token;
            localStorage.setItem('auth_token', authData.token);
          }
        } else {
          console.error('Authentication check failed:', await authResponse.text());
          // Don't throw here, we'll try to continue with the order anyway
        }
      }
      
      console.log('Using token for order placement:', token ? 'Token available' : 'No token available');
      
      // If we have a token, make sure it's saved to localStorage for future requests
      if (token && !localStorage.getItem('auth_token')) {
        localStorage.setItem('auth_token', token);
        console.log('Saved token to localStorage');
      }
      
      try {
        // Use XMLHttpRequest which might handle CORS differently than fetch
        console.log('Using XMLHttpRequest for order creation...');
        
        // Create a promise wrapper around XMLHttpRequest with proper typing
        const result = await new Promise<OrderResponseData>((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          const orderApiUrl = import.meta.env.VITE_ORDER_API_URL || 'https://api.inseat.achievengine.com/api/orders';
          xhr.open('POST', orderApiUrl, true);
          xhr.withCredentials = true; // Essential for sending cookies
          xhr.setRequestHeader('Content-Type', 'application/json');
          
          // Add Authorization header if token is available
          if (token) {
            xhr.setRequestHeader('Authorization', `Bearer ${token}`);
            console.log('Added Authorization header with token');
          } else {
            console.warn('No token available for Authorization header');
            
            // Last attempt to get token from cookies directly
            const cookieToken = document.cookie
              .split(';')
              .find(cookie => cookie.trim().startsWith('auth_token='))
              ?.split('=')[1];
              
            if (cookieToken) {
              xhr.setRequestHeader('Authorization', `Bearer ${cookieToken}`);
              console.log('Added Authorization header with cookie token');
            } else {
              console.warn('No authentication token available. Order creation may fail.');
            }
          }
          
          xhr.onload = function() {
            console.log('XHR response received:', {
              status: xhr.status,
              responseText: xhr.responseText
            });
            
            if (xhr.status >= 200 && xhr.status < 300) {
              try {
                // The response could be in different formats depending on the API
                const parsedResponse = JSON.parse(xhr.responseText);
                console.log('Parsed response:', parsedResponse);
                
                // Check if response has success property (API v1 format)
                if (parsedResponse.success !== undefined) {
                  if (parsedResponse.success) {
                    resolve(parsedResponse.data);
                  } else {
                    console.error('Order creation failed despite 200 status:', parsedResponse.error);
                    reject(new Error(parsedResponse.error?.message || 'Order creation failed'));
                  }
                } 
                // If no success property but has _id, it's a direct order object (API v2 format)
                else if (parsedResponse._id) {
                  console.log('Direct order object returned:', parsedResponse);
                  // Use the order object directly
                  resolve(parsedResponse);
                } 
                // Unknown response format
                else {
                  console.error('Unknown response format:', parsedResponse);
                  reject(new Error('Unknown response format'));
                }
              } catch (e) {
                console.error('Failed to parse response:', e);
                reject(new Error('Failed to parse response'));
              }
            } else {
              console.error(`Order creation failed with status: ${xhr.status}`, xhr.responseText);
              try {
                const errorData = JSON.parse(xhr.responseText);
                reject(new Error(errorData.error || `Order creation failed with status: ${xhr.status}`));
              } catch (e) {
                reject(new Error(`Order creation failed with status: ${xhr.status}`));
              }
            }
          };
          
          xhr.onerror = function() {
            console.error('XHR error:', xhr);
            reject(new Error('Network error occurred'));
          };
          
          xhr.send(JSON.stringify(constructedOrderData));
        });
        
  console.log('Order placed successfully:', result);
  toast.success('Order placed successfully!');
  
  // Transform OrderResponseData to Order type for the context
  const orderForContext: Order = {
        id: result._id, // Map _id to id
        orderNumber: result.orderNumber,
        // Ensure items are compatible with CartItem[]
        // This might need a more detailed mapping if OrderItem and CartItem are very different
        // For now, assuming they are structurally similar enough or that CartItem is flexible
        items: result.items.map(apiItem => ({
          id: apiItem.menuItem, // Assuming menuItem from API maps to id in CartItem
          menuItemId: apiItem.menuItem,
          name: apiItem.name,
          price: apiItem.price,
          quantity: apiItem.quantity,
          // image: apiItem.image, // If CartItem expects an image and apiItem has it
          specialInstructions: apiItem.specialInstructions,
          modifiers: apiItem.modifiers?.map(mod => ({ id: mod.name, name: mod.name, price: mod.price })) || [] // Example mapping for modifiers
        })),
        subtotal: result.subtotal,
        tax: result.tax,
        serviceFee: result.serviceFee,
        tip: result.tip,
        total: result.total,
        status: result.status, // Assuming OrderStatus enum values align
        paymentStatus: result.paymentStatus, // Assuming PaymentStatus enum values align
        timestamp: new Date(result.createdAt), // Convert createdAt string to Date
        tableId: result.tableId,
        specialInstructions: result.specialInstructions
      };

      addOrder(orderForContext);

      console.log('Order created successfully:', result);
      
      // Store order ID in localStorage for retrieval after payment
      localStorage.setItem('pending_order_id', result._id);
      
      // Clear the cart and close the drawer
      clearCart();
      onClose();
      
      // Show success message
      toast.success('Order placed successfully!');
      
      // The payment status should remain PENDING by default when an order is created
      // It will be updated to PAID by Stripe webhook when payment is completed
      console.log('Order created with PENDING payment status - will be updated when payment is processed');
      
      // Add a small delay before redirecting to ensure the toast is shown
      setTimeout(() => {
        console.log('Redirecting to my-orders page with table ID:', tableId);
        navigate(`/my-orders?table=${tableId}`);
      }, 1000);
    } catch (orderError) {
      console.error('Error in order creation process:', orderError);
      toast.error(orderError instanceof Error ? orderError.message : 'Failed to create your order');
      setIsProcessing(false);
      setError(orderError instanceof Error ? orderError.message : 'Failed to create your order');
      throw orderError; // Re-throw to be caught by the caller
    }
  };

  // Handle guest login
  const handleGuestLogin = React.useCallback(async (tableId: string) => {
    try {
      console.log('Attempting guest login with tableId:', tableId);
      
      // Get API base URL from environment variables
      const apiBaseUrl = import.meta.env.VITE_AUTH_API_URL || `${API_BASE_URL}/api/auth`;
      
      // Request a guest token directly from the server endpoint
      const response = await fetch(`${apiBaseUrl}/guest-token`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          tableId: tableId || '',
          deviceId: localStorage.getItem('device_id') || `device_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`
        }),
        credentials: 'include'
      });
      
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.token) {
          console.log('Guest token received:', data.token.substring(0, 10) + '...');
          
          // Store token in both localStorage and cookies for redundancy
          localStorage.setItem('auth_token', data.token);
          document.cookie = `auth_token=${data.token}; path=/; max-age=86400; SameSite=Lax`;
          document.cookie = `access_token=${data.token}; path=/; max-age=86400; SameSite=Lax`;
          
          return true;
        }
      }
      
      console.error('Guest login failed: No token in response');
      return false;
    } catch (error) {
      console.error('Guest login error:', error);
      return false;
    }
  }, []);
  
  const handleCheckout = () => {
    if (cartItems.length === 0) {
      toast.error("Your cart is empty");
      return;
    }
    
    // Move to checkout stage
    setStage('checkout');
  };
  
  const handlePlaceOrder = async (): Promise<void> => {
    console.log('handlePlaceOrder function entered - CartDrawer.tsx');
    try {
      // Validate cart is not empty
      if (cartItems.length === 0) {
        toast.error('Your cart is empty. Please add items to place an order.');
        return;
      }
      
      // Validate table ID is present
      if (!tableId) {
        toast.error("Table information is missing. Please scan a table QR code first.");
        onClose();
        navigate('/scan');
        return;
      }
      
      if (!tableId) {
        toast.error("Table information is missing. Please scan a table QR code first.");
        onClose();
        navigate('/scan');
        return;
      }
      
      setIsProcessing(true);
      
      // Process the order (this will create the order in the backend and get the order ID)
      await processOrder();
    } catch (error) {
      console.error('Error placing order:', error);
      setIsProcessing(false);
      toast.error(error instanceof Error ? error.message : 'Failed to place order');
      setError(error instanceof Error ? error.message : 'Failed to place order');
    }
  };
  
  const handleClose = () => {
    if (isProcessing) {
      // If processing is in progress, show a confirmation dialog
      if (window.confirm("Your order is still being processed. Are you sure you want to close?")) {
        onClose();
      }
    } else {
      onClose();
    }
  };
  
  let content;
  
  if (stage === 'checkout') {
    // Checkout stage UI
    content = (
      <div className="flex flex-col h-full">
        <SheetHeader className="p-4 border-b border-[#2D303E]">
          <div className="flex items-center justify-between">
            <SheetTitle className="text-xl font-semibold">Checkout</SheetTitle>
            <Button
              variant="ghost"
              size="icon"
              onClick={handleClose}
              disabled={isProcessing}
            >
              <X className="h-5 w-5" />
            </Button>
          </div>
        </SheetHeader>
        
        <ScrollArea className="flex-1">
          <div className="p-4 space-y-6">
            {/* Order type selection */}
            <div className="space-y-2">
              <h3 className="font-medium">Order Type</h3>
              <div className="flex gap-2">
                <Button
                  variant={orderType === OrderType.DINE_IN ? "default" : "outline"}
                  size="sm"
                  className={cn(
                    orderType === OrderType.DINE_IN 
                      ? "bg-delft-blue hover:bg-delft-blue/90" 
                      : ""
                  )}
                  onClick={() => setOrderType(OrderType.DINE_IN)}
                  disabled={isProcessing}
                >
                  Dine In
                </Button>
                <Button
                  variant={orderType === OrderType.TAKEOUT ? "default" : "outline"}
                  size="sm"
                  className={cn(
                    orderType === OrderType.TAKEOUT 
                      ? "bg-delft-blue hover:bg-delft-blue/90" 
                      : ""
                  )}
                  onClick={() => setOrderType(OrderType.TAKEOUT)}
                  disabled={isProcessing}
                >
                  Takeout
                </Button>
              </div>
            </div>
            
            {/* Cart items summary */}
            <div className="space-y-2">
              <div className="flex justify-between items-center">
                <h3 className="font-medium">Order Items</h3>
                <Button
                  variant="link"
                  size="sm"
                  className="h-auto p-0 text-delft-blue"
                  onClick={() => setStage('cart')}
                  disabled={isProcessing}
                >
                  Edit
                </Button>
              </div>
              <div className="space-y-2">
                {cartItems.map((item) => (
                  <div key={item.id} className="flex justify-between text-sm">
                    <div className="flex">
                      <span className="font-medium">{item.quantity}x</span>
                      <span className="ml-2">{item.name}</span>
                    </div>
                    <span>${(item.price * item.quantity).toFixed(2)}</span>
                  </div>
                ))}
              </div>
            </div>
            
            {/* Order notes */}
            <div className="space-y-2">
              <h3 className="font-medium">Special Instructions</h3>
              <Textarea 
                placeholder="Add any special instructions for your order..."
                value={specialInstructions}
                onChange={(e) => setSpecialInstructions(e.target.value)}
                className="resize-none"
              />
            </div>
          </div>
        </ScrollArea>
        
        <div className="border-t border-[#2D303E] p-4 space-y-4">
          <div className="space-y-2">
            <div className="flex justify-between">
              <span className="text-muted-foreground">Subtotal</span>
              <span>${subtotal.toFixed(2)}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">Tax ({(taxRate * 100).toFixed(0)}%)</span>
              <span>${tax.toFixed(2)}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">Service Fee ({(serviceFeeRate * 100).toFixed(0)}%)</span>
              <span>${serviceFee.toFixed(2)}</span>
            </div>
            {tipAmount > 0 && (
              <div className="flex justify-between">
                <span className="text-muted-foreground">Tip</span>
                <span>${tipAmount.toFixed(2)}</span>
              </div>
            )}
            <div className="flex justify-between font-medium text-lg pt-2 border-t border-[#2D303E]">
              <span>Total</span>
              <span>${total.toFixed(2)}</span>
            </div>
          </div>
          
          <Button 
            onClick={() => { 
              console.log('Place Order button clicked - inline in CartDrawer.tsx'); 
              handlePlaceOrder(); 
            }}
            className="w-full bg-delft-blue hover:bg-delft-blue/90 text-white"
            disabled={isProcessing}
          >
            {isProcessing ? (
              <div className="flex items-center">
                <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Processing...
              </div>
            ) : (
              <>
                Place Order
                <ArrowRight className="ml-2 h-4 w-4" />
              </>
            )}
          </Button>
        </div>
      </div>
    );
  } else {
    // Cart stage UI
    content = (
      <div className="flex flex-col h-full">
        <SheetHeader className="p-4 border-b border-[#2D303E]">
          <div className="flex items-center justify-between">
            <SheetTitle className="text-xl font-semibold">Your Cart</SheetTitle>
            <Button
              variant="ghost"
              size="icon"
              onClick={handleClose}
            >
              <X className="h-5 w-5" />
            </Button>
          </div>
        </SheetHeader>
        
        <ScrollArea className="flex-1 p-4">
          {cartItems.length === 0 ? (
            <div className="flex flex-col items-center justify-center h-full text-center">
              <p className="text-muted-foreground mb-4">Your cart is empty</p>
              <Button onClick={handleClose} variant="outline">
                Continue Shopping
              </Button>
            </div>
          ) : (
            <div className="space-y-4">
              {cartItems.map((item) => (
                <div
                  key={item.id}
                  className="flex gap-3 p-3 rounded-lg bg-[#1F1D2B] border border-[#2D303E]"
                >
                  {item.image && (
                    <img
                      src={item.image}
                      alt={item.name}
                      className="w-20 h-20 object-cover rounded-md"
                      onError={(e) => {
                        const target = e.target as HTMLImageElement;
                        target.src = 'https://source.unsplash.com/featured/?food';
                      }}
                    />
                  )}
                  
                  <div className="flex-1">
                    <div className="flex justify-between">
                      <h3 className="font-medium">{item.name}</h3>
                      <Button
                        variant="ghost"
                        size="icon"
                        className="h-6 w-6 -mr-1 -mt-1 text-muted-foreground"
                        onClick={() => removeItem(item.id)}
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </div>
                    
                    <p className="text-sm text-delft-blue mt-1">${item.price.toFixed(2)}</p>
                    
                    {item.modifiers && item.modifiers.length > 0 && (
                      <div className="mt-1 text-xs text-muted-foreground">
                        {item.modifiers.map((mod, index) => (
                          <div key={index} className="flex justify-between">
                            <span>{mod.name}</span>
                            {mod.price > 0 && (
                              <span>+${mod.price.toFixed(2)}</span>
                            )}
                          </div>
                        ))}
                      </div>
                    )}
                    
                    {item.specialInstructions && (
                      <div className="mt-1 text-xs italic text-muted-foreground">
                        {item.specialInstructions}
                      </div>
                    )}
                    
                    <div className="flex items-center justify-between mt-2">
                      <div className="flex items-center gap-2">
                        <Button
                          variant="outline"
                          size="icon"
                          className="h-7 w-7"
                          onClick={() => updateQuantity(item.id, item.quantity - 1)}
                          disabled={item.quantity <= 1}
                        >
                          <Minus className="h-3 w-3" />
                        </Button>
                        <span className="w-5 text-center text-sm">{item.quantity}</span>
                        <Button
                          variant="outline"
                          size="icon"
                          className="h-7 w-7"
                          onClick={() => updateQuantity(item.id, item.quantity + 1)}
                        >
                          <Plus className="h-3 w-3" />
                        </Button>
                      </div>
                      
                      <span className="font-medium">
                        ${(item.price * item.quantity).toFixed(2)}
                      </span>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}
        </ScrollArea>
        
        {cartItems.length > 0 && (
          <div className="border-t border-[#2D303E] p-4 space-y-3">
            <div className="flex justify-between font-medium">
              <span>Subtotal</span>
              <span>${subtotal.toFixed(2)}</span>
            </div>
            <Button
              className="w-full bg-delft-blue hover:bg-delft-blue/90 text-white"
              onClick={handleCheckout}
            >
              Continue to Checkout
              <ArrowRight className="ml-2 h-4 w-4" />
            </Button>
          </div>
        )}
      </div>
    );
  }

  return (
    <Sheet open={isOpen} onOpenChange={handleClose}>
      <SheetContent 
        side="right" 
        className="w-full sm:max-w-md border-l border-[#2D303E] bg-[#16141F] p-0 max-h-screen"
      >
        {content}
      </SheetContent>
    </Sheet>
  );
};

export default CartDrawer;
</file>

<file path="src/components/CartDrawer.tsx.tmp3">
import React, { useState, useEffect } from 'react';
import { API_BASE_URL } from '@/constants';
import { useCart } from '@/context/CartContext';
import { useOrders } from '@/context/OrdersContext';
import { useAuth } from '@/hooks/useAuth';
import { useTableInfo } from '@/context/TableContext';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Trash2, Plus, Minus, X, ArrowRight, Loader2 } from 'lucide-react';
import { toast } from 'sonner';
import { cn } from '@/lib/utils';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Sheet, SheetContent, SheetHeader, SheetTitle } from '@/components/ui/sheet';
import { createOrder, OrderResponseData } from '@/api/orderService';
import { useNavigate } from 'react-router-dom';
import type { Order } from '@/types';

// Order type enum to match API
enum OrderType {
  DINE_IN = 'DINE_IN',
  TAKEOUT = 'TAKEOUT'
}

// Order status enum to match API
enum OrderStatus {
  PENDING = 'PENDING',
  PREPARING = 'PREPARING',
  READY = 'READY',
  DELIVERED = 'DELIVERED',
  COMPLETED = 'COMPLETED',
  CANCELLED = 'CANCELLED'
}

// Payment status enum to match API
enum PaymentStatus {
  PENDING = 'PENDING',
  PROCESSING = 'PROCESSING',
  PAID = 'PAID',
  FAILED = 'FAILED',
  REFUNDED = 'REFUNDED'
}

interface CartItem {
  id: string;
  menuItemId?: string;
  name: string;
  price: number;
  quantity: number;
  specialInstructions?: string;
  modifiers?: Array<{ id: string, name: string, price: number }>;
  image?: string;
}

interface OrderData {
  restaurantId: string;
  tableId: string;
  items: Array<{
    menuItem: string;
    name: string;
    quantity: number;
    price: number;
    subtotal: number;
    specialInstructions: string;
    modifiers?: Array<{ name: string, price: number }>;
  }>;
  subtotal: number;
  tax: number;
  tip: number;
  total: number;
  orderType: OrderType;
  specialInstructions: string;
  serviceFee: number;
  status: OrderStatus;
  paymentStatus: PaymentStatus;
  orderNumber: string;
}

interface CartDrawerProps {
  isOpen: boolean;
  onClose: () => void;
}

const CartDrawer: React.FC<CartDrawerProps> = ({ isOpen, onClose }) => {
  const { cartItems, removeFromCart: removeItem, updateQuantity, clearCart, cartTotal: subtotal } = useCart();
  const { tableId, restaurantName } = useTableInfo();
  const { isAuthenticated, token } = useAuth();
  const { addOrder } = useOrders();
  const navigate = useNavigate();

  const [stage, setStage] = useState<'cart' | 'checkout'>('cart');
  const [specialInstructions, setSpecialInstructions] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState('');
  const [orderType, setOrderType] = useState<OrderType>(OrderType.DINE_IN);

  // Tax and fees calculations
  const taxRate = 0.08;
  const serviceFeeRate = 0.05;
  const tax = subtotal * taxRate;
  const serviceFee = subtotal * serviceFeeRate;
  const tipAmount = 0;
  const total = subtotal + tax + serviceFee + tipAmount;

  const processOrder = async () => {
    try {
      const localRestaurantId = restaurantName === 'InSeat'
        ? '65f456b06c9dfd001b6b1234'
        : tableId.split('-')[0];

      const formattedItems = cartItems.map(item => ({
        menuItem: String(item.menuItemId || item.id),
        name: item.name,
        quantity: item.quantity,
        price: item.price,
        subtotal: item.price * item.quantity,
        specialInstructions: item.specialInstructions || specialInstructions || '',
        modifiers: item.modifiers
      }));

      const constructedOrderData: OrderData = {
        restaurantId: localRestaurantId,
        tableId,
        items: formattedItems,
        subtotal,
        tax,
        tip: tipAmount,
        total,
        orderType,
        specialInstructions: specialInstructions || '',
        serviceFee,
        status: OrderStatus.PENDING,
        paymentStatus: PaymentStatus.PENDING,
        orderNumber: `ORD-${Date.now()}-${Math.floor(Math.random() * 1000)}`
      };

      const result = await new Promise<OrderResponseData>((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        const orderApiUrl = import.meta.env.VITE_ORDER_API_URL || 'https://api.inseat.achievengine.com/api/orders';
        xhr.open('POST', orderApiUrl, true);
        xhr.withCredentials = true;
        xhr.setRequestHeader('Content-Type', 'application/json');

        if (token) {
          xhr.setRequestHeader('Authorization', `Bearer ${token}`);
        }

        xhr.onload = function() {
          if (xhr.status >= 200 && xhr.status < 300) {
            const parsedResponse = JSON.parse(xhr.responseText);
            if (parsedResponse._id) {
              resolve(parsedResponse);
            } else if (parsedResponse.success) {
              resolve(parsedResponse.data);
            } else {
              reject(new Error(parsedResponse.error?.message || 'Order creation failed'));
            }
          } else {
            reject(new Error(`Order creation failed with status: ${xhr.status}`));
          }
        };

        xhr.onerror = () => reject(new Error('Network error occurred'));
        xhr.send(JSON.stringify(constructedOrderData));
      });

      const orderForContext: Order = {
        id: result._id,
        orderNumber: result.orderNumber,
        items: result.items.map(apiItem => ({
          id: apiItem.menuItem,
          menuItemId: apiItem.menuItem,
          name: apiItem.name,
          price: apiItem.price,
          quantity: apiItem.quantity,
          specialInstructions: apiItem.specialInstructions,
          modifiers: apiItem.modifiers?.map(mod => ({ id: mod.name, name: mod.name, price: mod.price })) || []
        })),
        subtotal: result.subtotal,
        tax: result.tax,
        serviceFee: result.serviceFee,
        tip: result.tip,
        total: result.total,
        status: result.status,
        paymentStatus: result.paymentStatus,
        timestamp: new Date(result.createdAt),
        tableId: result.tableId,
        specialInstructions: result.specialInstructions
      };

      addOrder(orderForContext);
      localStorage.setItem('pending_order_id', result._id);
      clearCart();
      onClose();

      toast.success('Order placed successfully!');

      setTimeout(() => {
        navigate(`/my-orders?table=${tableId}`);
      }, 1000);
    } catch (error) {
      console.error('Error in order creation process:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to create your order');
      setIsProcessing(false);
      setError(error instanceof Error ? error.message : 'Failed to create your order');
      throw error;
    }
  };

  const handlePlaceOrder = async (): Promise<void> => {
    try {
      if (cartItems.length === 0) {
        toast.error('Your cart is empty. Please add items to place an order.');
        return;
      }

      if (!tableId) {
        toast.error("Table information is missing. Please scan a table QR code first.");
        onClose();
        navigate('/scan');
        return;
      }

      setIsProcessing(true);
      await processOrder();
    } catch (error) {
      console.error('Error placing order:', error);
      setIsProcessing(false);
      toast.error(error instanceof Error ? error.message : 'Failed to place order');
      setError(error instanceof Error ? error.message : 'Failed to place order');
    }
  };

  const handleCheckout = () => {
    if (cartItems.length === 0) {
      toast.error("Your cart is empty");
      return;
    }
    setStage('checkout');
  };

  const handleClose = () => {
    if (isProcessing) {
      if (window.confirm("Your order is still being processed. Are you sure you want to close?")) {
        onClose();
      }
    } else {
      onClose();
    }
  };

  useEffect(() => {
    if (!isOpen) {
      setTimeout(() => {
        setStage('cart');
        setIsProcessing(false);
      }, 300);
    }
  }, [isOpen]);

  // Rest of your component JSX...

};

export default CartDrawer;
</file>

<file path="src/components/CartDrawer.tsx.ui-part">
// Inside the CartDrawer component, replace "// Rest of your component JSX..." with:

let content;
if (stage === 'checkout') {
  content = (
    <div className="flex flex-col h-full">
      <SheetHeader className="p-4 border-b border-[#2D303E]">
        <div className="flex items-center justify-between">
          <SheetTitle className="text-xl font-semibold">Checkout</SheetTitle>
          <Button
            variant="ghost"
            size="icon"
            onClick={handleClose}
            disabled={isProcessing}
          >
            <X className="h-5 w-5" />
          </Button>
        </div>
      </SheetHeader>
      
      <ScrollArea className="flex-1">
        <div className="p-4 space-y-6">
          <div className="space-y-2">
            <h3 className="font-medium">Order Type</h3>
            <div className="flex gap-2">
              <Button
                variant={orderType === OrderType.DINE_IN ? "default" : "outline"}
                size="sm"
                className={cn(
                  orderType === OrderType.DINE_IN 
                    ? "bg-delft-blue hover:bg-delft-blue/90" 
                    : ""
                )}
                onClick={() => setOrderType(OrderType.DINE_IN)}
                disabled={isProcessing}
              >
                Dine In
              </Button>
              <Button
                variant={orderType === OrderType.TAKEOUT ? "default" : "outline"}
                size="sm"
                className={cn(
                  orderType === OrderType.TAKEOUT 
                    ? "bg-delft-blue hover:bg-delft-blue/90" 
                    : ""
                )}
                onClick={() => setOrderType(OrderType.TAKEOUT)}
                disabled={isProcessing}
              >
                Takeout
              </Button>
            </div>
          </div>
          
          <div className="space-y-2">
            <div className="flex justify-between items-center">
              <h3 className="font-medium">Order Items</h3>
              <Button
                variant="link"
                size="sm"
                className="h-auto p-0 text-delft-blue"
                onClick={() => setStage('cart')}
                disabled={isProcessing}
              >
                Edit
              </Button>
            </div>
            <div className="space-y-2">
              {cartItems.map((item) => (
                <div key={item.id} className="flex justify-between text-sm">
                  <div className="flex">
                    <span className="font-medium">{item.quantity}x</span>
                    <span className="ml-2">{item.name}</span>
                  </div>
                  <span>${(item.price * item.quantity).toFixed(2)}</span>
                </div>
              ))}
            </div>
          </div>
          
          <div className="space-y-2">
            <h3 className="font-medium">Special Instructions</h3>
            <Textarea 
              placeholder="Add any special instructions for your order..."
              value={specialInstructions}
              onChange={(e) => setSpecialInstructions(e.target.value)}
              className="resize-none"
            />
          </div>
        </div>
      </ScrollArea>
      
      <div className="border-t border-[#2D303E] p-4 space-y-4">
        <div className="space-y-2">
          <div className="flex justify-between">
            <span className="text-muted-foreground">Subtotal</span>
            <span>${subtotal.toFixed(2)}</span>
          </div>
          <div className="flex justify-between">
            <span className="text-muted-foreground">Tax ({(taxRate * 100).toFixed(0)}%)</span>
            <span>${tax.toFixed(2)}</span>
          </div>
          <div className="flex justify-between">
            <span className="text-muted-foreground">Service Fee ({(serviceFeeRate * 100).toFixed(0)}%)</span>
            <span>${serviceFee.toFixed(2)}</span>
          </div>
          {tipAmount > 0 && (
            <div className="flex justify-between">
              <span className="text-muted-foreground">Tip</span>
              <span>${tipAmount.toFixed(2)}</span>
            </div>
          )}
          <div className="flex justify-between font-medium text-lg pt-2 border-t border-[#2D303E]">
            <span>Total</span>
            <span>${total.toFixed(2)}</span>
          </div>
        </div>
        
        <Button 
          onClick={handlePlaceOrder}
          className="w-full bg-delft-blue hover:bg-delft-blue/90 text-white"
          disabled={isProcessing}
        >
          {isProcessing ? (
            <div className="flex items-center">
              <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Processing...
            </div>
          ) : (
            <>
              Place Order
              <ArrowRight className="ml-2 h-4 w-4" />
            </>
          )}
        </Button>
      </div>
    </div>
  );
} else {
  content = (
    <div className="flex flex-col h-full">
      <SheetHeader className="p-4 border-b border-[#2D303E]">
        <div className="flex items-center justify-between">
          <SheetTitle className="text-xl font-semibold">Your Cart</SheetTitle>
          <Button
            variant="ghost"
            size="icon"
            onClick={handleClose}
          >
            <X className="h-5 w-5" />
          </Button>
        </div>
      </SheetHeader>
      
      <ScrollArea className="flex-1 p-4">
        {cartItems.length === 0 ? (
          <div className="flex flex-col items-center justify-center h-full text-center">
            <p className="text-muted-foreground mb-4">Your cart is empty</p>
            <Button onClick={handleClose} variant="outline">
              Continue Shopping
            </Button>
          </div>
        ) : (
          <div className="space-y-4">
            {cartItems.map((item) => (
              <div
                key={item.id}
                className="flex gap-3 p-3 rounded-lg bg-[#1F1D2B] border border-[#2D303E]"
              >
                {item.image && (
                  <img
                    src={item.image}
                    alt={item.name}
                    className="w-20 h-20 object-cover rounded-md"
                    onError={(e) => {
                      const target = e.target as HTMLImageElement;
                      target.src = 'https://source.unsplash.com/featured/?food'\;
                    }}
                  />
                )}
                
                <div className="flex-1">
                  <div className="flex justify-between">
                    <h3 className="font-medium">{item.name}</h3>
                    <Button
                      variant="ghost"
                      size="icon"
                      className="h-6 w-6 -mr-1 -mt-1 text-muted-foreground"
                      onClick={() => removeItem(item.id)}
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </div>
                  
                  <p className="text-sm text-delft-blue mt-1">${item.price.toFixed(2)}</p>
                  
                  {item.modifiers && item.modifiers.length > 0 && (
                    <div className="mt-1 text-xs text-muted-foreground">
                      {item.modifiers.map((mod, index) => (
                        <div key={index} className="flex justify-between">
                          <span>{mod.name}</span>
                          {mod.price > 0 && (
                            <span>+${mod.price.toFixed(2)}</span>
                          )}
                        </div>
                      ))}
                    </div>
                  )}
                  
                  {item.specialInstructions && (
                    <div className="mt-1 text-xs italic text-muted-foreground">
                      {item.specialInstructions}
                    </div>
                  )}
                  
                  <div className="flex items-center justify-between mt-2">
                    <div className="flex items-center gap-2">
                      <Button
                        variant="outline"
                        size="icon"
                        className="h-7 w-7"
                        onClick={() => updateQuantity(item.id, item.quantity - 1)}
                        disabled={item.quantity <= 1}
                      >
                        <Minus className="h-3 w-3" />
                      </Button>
                      <span className="w-5 text-center text-sm">{item.quantity}</span>
                      <Button
                        variant="outline"
                        size="icon"
                        className="h-7 w-7"
                        onClick={() => updateQuantity(item.id, item.quantity + 1)}
                      >
                        <Plus className="h-3 w-3" />
                      </Button>
                    </div>
                    
                    <span className="font-medium">
                      ${(item.price * item.quantity).toFixed(2)}
                    </span>
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </ScrollArea>
      
      {cartItems.length > 0 && (
        <div className="border-t border-[#2D303E] p-4 space-y-3">
          <div className="flex justify-between font-medium">
            <span>Subtotal</span>
            <span>${subtotal.toFixed(2)}</span>
          </div>
          <Button
            className="w-full bg-delft-blue hover:bg-delft-blue/90 text-white"
            onClick={handleCheckout}
          >
            Continue to Checkout
            <ArrowRight className="ml-2 h-4 w-4" />
          </Button>
        </div>
      )}
    </div>
  );
}

return (
  <Sheet open={isOpen} onOpenChange={handleClose}>
    <SheetContent 
      side="right" 
      className="w-full sm:max-w-md border-l border-[#2D303E] bg-[#16141F] p-0 max-h-screen"
    >
      {content}
    </SheetContent>
  </Sheet>
);
</file>

<file path="src/components/DemoNotification.tsx">
import React from 'react';
import { AlertCircle } from 'lucide-react';
const DemoNotification: React.FC = () => {
  // Commented out demo functionality as requested
  /*
  return (
    <div className="w-full bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-200 py-2 px-4 text-sm flex items-center justify-center">
      <AlertCircle className="h-4 w-4 mr-2" />
      <p>
        This is a demo version. Orders and user data are stored locally and will be reset when you clear your browser data.
      </p>
    </div>
  );
  */
  // Return null instead of the demo notification
  return null;
};
export default DemoNotification;
</file>

<file path="src/components/Footer.tsx">
import React from 'react';
import { Link } from 'react-router-dom';
import { Instagram, Facebook, Twitter } from 'lucide-react';
export const Footer: React.FC = () => {
  return (
    <footer className="bg-background border-t border-border mt-auto">
      <div className="container px-4 mx-auto py-12">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-8">
          <div className="md:col-span-1">
            <Link to="/" className="text-2xl font-semibold">
              Taste<span className="text-primary">Mate</span>
            </Link>
            <p className="mt-4 text-muted-foreground">
              Discover exquisite cuisine delivered with elegance and precision to your doorstep.
            </p>
          </div>
          <div>
            <h4 className="font-medium mb-4">Explore</h4>
            <ul className="space-y-2">
              <li>
                <Link to="/" className="text-muted-foreground hover:text-foreground transition-colors">
                  Home
                </Link>
              </li>
              <li>
                <Link to="/menu" className="text-muted-foreground hover:text-foreground transition-colors">
                  Menu
                </Link>
              </li>
              <li>
                <Link to="/favorites" className="text-muted-foreground hover:text-foreground transition-colors">
                  Favorites
                </Link>
              </li>
            </ul>
          </div>
          <div>
            <h4 className="font-medium mb-4">Information</h4>
            <ul className="space-y-2">
              <li>
                <Link to="/about" className="text-muted-foreground hover:text-foreground transition-colors">
                  About Us
                </Link>
              </li>
              <li>
                <Link to="/contact" className="text-muted-foreground hover:text-foreground transition-colors">
                  Contact
                </Link>
              </li>
              <li>
                <Link to="/privacy" className="text-muted-foreground hover:text-foreground transition-colors">
                  Privacy Policy
                </Link>
              </li>
            </ul>
          </div>
          <div>
            <h4 className="font-medium mb-4">Connect</h4>
            <div className="flex space-x-4">
              <a href="#" className="text-muted-foreground hover:text-foreground transition-colors">
                <Instagram size={20} />
              </a>
              <a href="#" className="text-muted-foreground hover:text-foreground transition-colors">
                <Facebook size={20} />
              </a>
              <a href="#" className="text-muted-foreground hover:text-foreground transition-colors">
                <Twitter size={20} />
              </a>
            </div>
            <p className="mt-4 text-muted-foreground text-sm">
              Subscribe to our newsletter for exclusive offers and updates.
            </p>
          </div>
        </div>
        <div className="border-t border-border mt-8 pt-8 text-center text-sm text-muted-foreground">
          <p>Â© {new Date().getFullYear()} TasteMate. All rights reserved.</p>
        </div>
      </div>
    </footer>
  );
};
</file>

<file path="src/components/ItemDetailDialog.tsx.backup">
import React, { useState, useEffect } from 'react';
import { Dialog } from '@headlessui/react';
import { MenuItem } from '@/types/menuItem';
import { useCart } from '@/context/CartContext';
import { ChevronLeft, Heart, Plus, Star, ThumbsUp, Users, MessageCircle } from 'lucide-react';
import Image from 'next/image';
import { useToast } from '@/components/ui/use-toast';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Separator } from '@/components/ui/separator';
import { Button } from '@/components/ui/button';

interface ItemDetailDialogProps {
  item: MenuItem;
  closeDialog: () => void;
}

// StarRating component
const StarRating = ({ rating }: { rating: number }) => {
  return (
    <div className="flex items-center">
      {[...Array(5)].map((_, i) => (
        <Star 
          key={i} 
          size={16} 
          className={`${i < Math.floor(rating) ? 'text-yellow-400 fill-yellow-400' : 'text-gray-300'} mr-0.5`} 
        />
      ))}
      <span className="ml-1 text-sm font-medium text-gray-600">{rating.toFixed(1)}</span>
    </div>
  );
};

// ReviewCard component
const ReviewCard = ({ 
  author, 
  rating, 
  comment, 
  date, 
  likes 
}: { 
  author: string; 
  rating: number; 
  comment: string; 
  date: string; 
  likes: number 
}) => {
  const [liked, setLiked] = useState(false);
  const [likeCount, setLikeCount] = useState(likes);

  const handleLike = () => {
    if (!liked) {
      setLikeCount(prev => prev + 1);
      setLiked(true);
    } else {
      setLikeCount(prev => prev - 1);
      setLiked(false);
    }
  };

  return (
    <div className="p-4 border rounded-lg mb-3">
      <div className="flex justify-between items-center mb-2">
        <div className="flex items-center">
          <div className="w-8 h-8 rounded-full bg-gray-200 flex items-center justify-center mr-2">
            {author.charAt(0).toUpperCase()}
          </div>
          <span className="font-medium">{author}</span>
        </div>
        <StarRating rating={rating} />
      </div>
      <p className="text-gray-700 mb-2">{comment}</p>
      <div className="flex justify-between items-center text-sm text-gray-500">
        <span>{date}</span>
        <div className="flex items-center">
          <button 
            className={`flex items-center gap-1 ${liked ? 'text-blue-500' : ''}`}
            onClick={handleLike}
          >
            <ThumbsUp size={14} />
            <span>{likeCount}</span>
          </button>
        </div>
      </div>
    </div>
  );
};

export default function ItemDetailDialog({ item, closeDialog }: ItemDetailDialogProps) {
  const { addToCart } = useCart();
  const [selectedModifiers, setSelectedModifiers] = useState<string[]>([]);
  const [cookingPreference, setCookingPreference] = useState<string>('');
  const [specialInstructions, setSpecialInstructions] = useState<string>('');
  const [totalPrice, setTotalPrice] = useState<number>(item.price);
  const { toast } = useToast();
  
  // Sample reviews
  const reviews = [
    {
      author: 'John D.',
      rating: 4.5,
      comment: 'This dish was fantastic! The flavors were well balanced and the portion size was perfect.',
      date: 'May 15, 2023',
      likes: 12
    },
    {
      author: 'Sarah M.',
      rating: 5,
      comment: 'Absolutely loved it! Would definitely order again.',
      date: 'June 2, 2023',
      likes: 8
    }
  ];

  useEffect(() => {
    let newTotal = item.price;
    selectedModifiers.forEach((modifier) => {
      if (modifier === 'Extra cheese') {
        newTotal += 1.5;
      } else if (modifier === 'Double patty') {
        newTotal += 3.0;
      } else if (modifier === 'Bacon') {
        newTotal += 2.0;
      } else if (modifier === 'Extra toppings') {
        newTotal += 1.0;
      }
    });
    setTotalPrice(newTotal);
  }, [item.price, selectedModifiers]);

  const handleModifierChange = (modifier: string) => {
    setSelectedModifiers((prev) =>
      prev.includes(modifier)
        ? prev.filter((m) => m !== modifier)
        : [...prev, modifier]
    );
  };

  const handleAddToCart = () => {
    addToCart({
      ...item,
      modifiers: selectedModifiers,
      cookingPreference,
      specialInstructions,
      totalPrice,
    });
    toast({
      title: 'Added to cart',
      description: `${item.name} has been added to your cart.`,
    });
    closeDialog();
  };

  // Determine available modifiers based on item type
  const availableModifiers = (() => {
    if (item.category === 'Burgers') {
      return ['Bacon', 'Extra cheese', 'Double patty', 'No onions'];
    } else if (item.category === 'Pizzas') {
      return ['Extra cheese', 'Extra toppings', 'Thin crust', 'Gluten-free'];
    } else if (item.category === 'Beverages') {
      return ['Ice', 'Sugar-free', 'Extra shot', 'Whipped cream'];
    }
    return ['Extra sauce', 'No spice', 'Larger portion'];
  })();

  // Function to render a section title
  const SectionTitle = ({ children }: { children: React.ReactNode }) => (
    <h3 className="font-medium text-gray-900 mb-2">{children}</h3>
  );

  return (
    <Dialog.Panel className="w-full max-w-md transform overflow-hidden rounded-2xl bg-white p-6 text-left align-middle shadow-xl transition-all">
      <Dialog.Title
        as="div"
        className="relative h-56 w-full overflow-hidden mb-4"
      >
        <button
          onClick={closeDialog}
          className="absolute left-4 top-4 z-10 rounded-full bg-white/80 p-1 text-gray-800 backdrop-blur-sm"
        >
          <ChevronLeft size={20} />
        </button>
        <button className="absolute right-4 top-4 z-10 rounded-full bg-white/80 p-1 text-gray-800 backdrop-blur-sm">
          <Heart size={20} />
        </button>
        {item.imageUrl && (
          <Image
            src={item.imageUrl}
            alt={item.name}
            fill
            style={{ objectFit: 'cover' }}
            quality={95}
            sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
            className="rounded-lg"
          />
        )}
      </Dialog.Title>
      <div className="mt-3">
        <div className="flex justify-between items-center mb-1">
          <h3 className="text-xl font-bold text-gray-900">{item.name}</h3>
          <p className="text-lg font-semibold text-gray-900">${item.price.toFixed(2)}</p>
      </div>
      
        <div className="flex items-center mb-3">
          <StarRating rating={4.7} />
          <span className="mx-2 text-gray-500">â€¢</span>
          <div className="flex items-center text-gray-500 text-sm">
            <MessageCircle size={14} className="mr-1" />
            <span>{reviews.length} reviews</span>
          </div>
          <span className="mx-2 text-gray-500">â€¢</span>
          <div className="flex items-center text-gray-500 text-sm">
            <Users size={14} className="mr-1" />
            <span>120+ orders</span>
          </div>
      </div>
      
        <p className="text-gray-600 mb-4">{item.description}</p>

        {/* Modifiers Section */}
        <div className="mb-4">
          <SectionTitle>Customize Your Order</SectionTitle>
          <div className="grid grid-cols-2 gap-2">
            {availableModifiers.map((modifier) => (
              <div key={modifier} className="flex items-center">
                <input
                  type="checkbox"
                  id={modifier}
                  checked={selectedModifiers.includes(modifier)}
                  onChange={() => handleModifierChange(modifier)}
                  className="mr-2 h-4 w-4 rounded border-gray-300 text-emerald-600 focus:ring-emerald-500"
                />
                <label htmlFor={modifier} className="text-sm text-gray-700">
                  {modifier}
                </label>
              </div>
            ))}
          </div>
        </div>

        {/* Cooking Preference Section - shown only for relevant categories */}
        {(['Steaks', 'Burgers'].includes(item.category)) && (
          <div className="mb-4">
            <SectionTitle>Cooking Preference</SectionTitle>
            <div className="grid grid-cols-3 gap-2">
              {['Rare', 'Medium', 'Well Done'].map((pref) => (
                <div key={pref} className="flex items-center">
                  <input
                    type="radio"
                    id={pref}
                    name="cookingPreference"
                    checked={cookingPreference === pref}
                    onChange={() => setCookingPreference(pref)}
                    className="mr-2 h-4 w-4 border-gray-300 text-emerald-600 focus:ring-emerald-500"
                  />
                  <label htmlFor={pref} className="text-sm text-gray-700">
                    {pref}
                  </label>
                </div>
              ))}
            </div>
        </div>
      )}

        {/* Special Instructions Section */}
        <div className="mb-4">
          <SectionTitle>Special Instructions</SectionTitle>
          <textarea
          value={specialInstructions}
          onChange={(e) => setSpecialInstructions(e.target.value)}
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-emerald-500 focus:ring-emerald-500 text-sm"
            placeholder="Any special requirements for your order?"
            rows={2}
        />
      </div>
      
        {/* Reviews Section */}
        <div className="mb-4">
          <div className="flex justify-between items-center mb-3">
            <SectionTitle>Customer Reviews</SectionTitle>
            <button className="text-sm text-emerald-600 font-medium">View All</button>
          </div>
          
          {reviews.map((review, index) => (
            <ReviewCard 
              key={index}
              author={review.author}
              rating={review.rating}
              comment={review.comment}
              date={review.date}
              likes={review.likes}
            />
          ))}
      </div>
      
        {/* Add to Cart Button */}
        <div className="mt-5">
        <Button 
            type="button"
            className="flex w-full items-center justify-center rounded-md bg-emerald-600 px-4 py-3 text-sm font-semibold text-white hover:bg-emerald-700 focus:outline-none focus-visible:ring-2 focus-visible:ring-emerald-500 focus-visible:ring-offset-2"
          onClick={handleAddToCart}
        >
            <Plus className="mr-2 h-5 w-5" aria-hidden="true" />
            Add to Order - ${totalPrice.toFixed(2)}
        </Button>
        </div>
    </div>
    </Dialog.Panel>
  );
}
</file>

<file path="src/components/MenuCategoryList.tsx">
import React from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { Category } from '@/api/menuService';
import { Avatar } from '@/components/ui/avatar';
interface MenuCategoryListProps {
  categories: Category[];
  onCategorySelect: (categoryId: string) => void;
}
const MenuCategoryList: React.FC<MenuCategoryListProps> = ({ 
  categories, 
  onCategorySelect 
}) => {
  return (
    <div className="container mx-auto px-4 py-6">
      <h1 className="text-2xl font-bold mb-6">Menu Categories</h1>
      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
        {categories.map((category) => (
          <Card 
            key={category._id}
            onClick={() => onCategorySelect(category._id)}
            className="cursor-pointer transition-transform hover:scale-[1.02] hover:shadow-md"
          >
            <CardContent className="flex items-center p-4">
              {category.image && (
                <Avatar 
                  className="h-14 w-14 mr-4"
                >
                  <img 
                    src={category.image} 
                    alt={category.name}
                    className="object-cover h-full w-full"
                  />
                </Avatar>
              )}
              <div>
                <h3 className="text-lg font-semibold">
                  {category.name}
                </h3>
                {category.description && (
                  <p className="text-sm text-muted-foreground">
                    {category.description}
                  </p>
                )}
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );
};
export default MenuCategoryList;
</file>

<file path="src/components/MenuItemComponent.tsx">
import React, { useState } from 'react';
import { MenuItem } from '@/types';
import { Dialog, DialogContent, DialogTitle, DialogClose, DialogTrigger } from '@/components/ui/dialog';
import * as SheetPrimitive from '@radix-ui/react-dialog';
import { Plus, Clock, X, MinusCircle, PlusCircle, Heart } from 'lucide-react';
import { useCart } from '@/context/CartContext';
import { toast } from 'sonner';
import { Button } from '@/components/ui/button';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Label } from '@/components/ui/label';
import { Checkbox } from '@/components/ui/checkbox';
import { cn } from '@/lib/utils';
// Define modifier types
interface ModifierOption {
  id: string;
  name: string;
  price: number;
}
interface Modifier {  id: string;
  name: string;
  type: 'radio' | 'checkbox';
  required?: boolean;
  options: ModifierOption[];
}
interface MenuItemComponentProps {
  item: MenuItem;
}
export const MenuItemComponent: React.FC<MenuItemComponentProps> = ({ item }) => {
  const { addItem } = useCart();
  const handleAddToCart = (e: React.MouseEvent) => {
    e.stopPropagation();
    addItem(item, 1);
    toast.success(`Added ${item.name} to cart`);
  };
  // Use stock images from Pexels instead of Unsplash
  const getFallbackImage = (searchTerm: string) => {
    // Map of food categories to Pexels stock images
    const stockImages: Record<string, string> = {
      food: 'https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg',
      burger: 'https://images.pexels.com/photos/1639562/pexels-photo-1639562.jpeg',
      pizza: 'https://images.pexels.com/photos/825661/pexels-photo-825661.jpeg',
      pasta: 'https://images.pexels.com/photos/1279330/pexels-photo-1279330.jpeg',
      steak: 'https://images.pexels.com/photos/1639557/pexels-photo-1639557.jpeg',
      salad: 'https://images.pexels.com/photos/1059905/pexels-photo-1059905.jpeg',
      dessert: 'https://images.pexels.com/photos/132694/pexels-photo-132694.jpeg',
      coffee: 'https://images.pexels.com/photos/312418/pexels-photo-312418.jpeg',
      tea: 'https://images.pexels.com/photos/1793035/pexels-photo-1793035.jpeg',
      cocktail: 'https://images.pexels.com/photos/602750/pexels-photo-602750.jpeg',
      beer: 'https://images.pexels.com/photos/1552630/pexels-photo-1552630.jpeg',
      wine: 'https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg',
      alcohol: 'https://images.pexels.com/photos/339696/pexels-photo-339696.jpeg',
      drink: 'https://images.pexels.com/photos/2789328/pexels-photo-2789328.jpeg',
      appetizer: 'https://images.pexels.com/photos/566566/pexels-photo-566566.jpeg',
      noodles: 'https://images.pexels.com/photos/1279330/pexels-photo-1279330.jpeg',
      sliders: 'https://images.pexels.com/photos/1639562/pexels-photo-1639562.jpeg',
      sandwich: 'https://images.pexels.com/photos/1647163/pexels-photo-1647163.jpeg',
      sides: 'https://images.pexels.com/photos/1640773/pexels-photo-1640773.jpeg',
      veggie: 'https://images.pexels.com/photos/1640774/pexels-photo-1640774.jpeg',
      cheeseburger: 'https://images.pexels.com/photos/1639557/pexels-photo-1639557.jpeg',
      mushroom: 'https://images.pexels.com/photos/1639562/pexels-photo-1639562.jpeg',
    };
    // Find the closest matching category or default to food
    const category = Object.keys(stockImages).find(cat => 
      searchTerm?.toLowerCase().includes(cat)) || 'food';
    return stockImages[category];
  };
  const [isFavorite, setIsFavorite] = useState(false);
  const handleToggleFavorite = (e: React.MouseEvent) => {
    e.stopPropagation();
    setIsFavorite(!isFavorite);
    toast.success(isFavorite ? `Removed ${item.name} from favorites` : `Added ${item.name} to favorites`);
  };
  return (
    <Dialog>
      <DialogTitle className="sr-only">{item.name}</DialogTitle>
      <DialogTrigger asChild>
        <button className="relative overflow-hidden w-full text-left rounded-xl transition-all duration-300 hover:shadow-lg bg-[#2D303E] border border-[#3F4156]">
        {item.featured && (
          <span className="absolute top-2 left-2 bg-[#7B61FF] text-white text-xs px-2 py-0.5 rounded-full z-10">
            Featured
          </span>
        )}
        <button 
          onClick={(e) => {
            e.stopPropagation();
            handleToggleFavorite(e);
          }}
          className="absolute top-2 right-2 z-20 bg-black/40 hover:bg-black/60 rounded-full p-1.5 transition-all"
        >
          <svg
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill={isFavorite ? "#7B61FF" : "none"}
            stroke={isFavorite ? "#7B61FF" : "white"}
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
            className="transition-all"
          >
            <path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z" />
          </svg>
        </button>
        <div className="aspect-[4/3] overflow-hidden">
          <div className="absolute inset-0 bg-gradient-to-t from-black/60 to-transparent z-[1]"></div>
          <img 
            src={item.image || getFallbackImage(item.name.toLowerCase())} 
            alt={item.name}
            className="w-full h-full object-cover transition-transform duration-500 hover:scale-105"
            loading="lazy"
            onError={(e) => {
              const target = e.target as HTMLImageElement;
              target.src = getFallbackImage(item.name.toLowerCase() || item.category || 'food');
            }}
          />
        </div>
        <div className="p-3 relative -mt-2 z-[2]">
          <div className="flex justify-between items-start">
            <div>
              <h3 className="text-sm font-medium text-white">{item.name}</h3>
              <p className="text-xs my-0.5 line-clamp-1 text-gray-300">{item.description}</p>
            </div>
            <div className="flex flex-col items-end">
              <span className="text-sm font-bold text-[#7B61FF]">${item.price.toFixed(2)}</span>
              <div className="flex items-center mt-1 text-xs text-muted-foreground">
                <Clock size={12} className="mr-1" />
                <span>{'10-15 min'}</span>
              </div>
            </div>
          </div>
          <div className="mt-2 flex justify-end">
            <Button 
              onClick={(e) => {
                e.stopPropagation();
                handleAddToCart(e);
              }}
              size="sm"
              variant="ghost"
              className="h-8 w-8 p-0 rounded-full bg-[#7B61FF] hover:bg-[#8E79FF] text-white shadow-sm"
            >
              <Plus className="h-4 w-4" />
            </Button>
          </div>
        </div>
      </button>
      </DialogTrigger>
      <DialogContent className="fixed top-[10vh] left-0 right-0 max-w-none p-0 h-[90vh] rounded-t-3xl bg-[#1F1D2B] border-t border-[#2D303E] overflow-hidden shadow-2xl z-50" style={{ transform: 'translateY(-100%)', animation: 'slide-down 0.5s cubic-bezier(0.16, 1, 0.3, 1) forwards', transformOrigin: 'top' }}>
        <MenuItemDetail item={item} onAddToCart={handleAddToCart} />
      </DialogContent>
    </Dialog>
  );
};
interface MenuItemDetailProps {
  item: MenuItem;
  onAddToCart: (e: React.MouseEvent) => void;
}
// Modifiers for the menu items
const getModifiersForItem = (itemId: string): Modifier[] => {
  // All items get size options
  const modifiers: Modifier[] = [
    {
      id: 'size',
      name: 'Size',
      type: 'radio',
      required: true,
      options: [
        { id: 'small', name: 'Small', price: -2 },
        { id: 'medium', name: 'Medium', price: 0 },
        { id: 'large', name: 'Large', price: 2 },
      ]
    }
  ];
  // Add spice level modifier for certain items
  if (['1', '3', '5'].includes(itemId)) {
    modifiers.push({
      id: 'spice-level',
      name: 'Spice Level',
      type: 'radio',
      required: true,
      options: [
        { id: 'mild', name: 'Mild', price: 0 },
        { id: 'medium', name: 'Medium', price: 0 },
        { id: 'hot', name: 'Hot ðŸ”¥', price: 0 },
        { id: 'extra-hot', name: 'Extra Hot ðŸ”¥ðŸ”¥', price: 1 },
      ]
    });
  }
  // Add cheese modifier for certain items
  if (['2', '4', '12'].includes(itemId)) {
    modifiers.push({
      id: 'cheese',
      name: 'Cheese Options',
      type: 'radio',
      required: true,
      options: [
        { id: 'cheddar', name: 'Cheddar', price: 0 },
        { id: 'swiss', name: 'Swiss', price: 1 },
        { id: 'blue', name: 'Blue Cheese', price: 1.5 },
        { id: 'no-cheese', name: 'No Cheese', price: -1 },
      ]
    });
  }
  // Add toppings for burgers and pizzas
  if (['2', '12'].includes(itemId)) {
    modifiers.push({
      id: 'toppings',
      name: 'Extra Toppings',
      type: 'checkbox',
      options: [
        { id: 'bacon', name: 'Bacon', price: 2 },
        { id: 'avocado', name: 'Avocado', price: 1.5 },
        { id: 'egg', name: 'Fried Egg', price: 1 },
        { id: 'jalapeÃ±os', name: 'JalapeÃ±os', price: 0.5 },
        { id: 'mushrooms', name: 'Mushrooms', price: 1 },
      ]
    });
  }
  // Add sides for main courses
  if (['3', '4', '5'].includes(itemId)) {
    modifiers.push({
      id: 'sides',
      name: 'Side Options',
      type: 'radio',
      required: true,
      options: [
        { id: 'fries', name: 'French Fries', price: 0 },
        { id: 'salad', name: 'Side Salad', price: 0 },
        { id: 'mashed', name: 'Mashed Potatoes', price: 0 },
        { id: 'truffle-fries', name: 'Truffle Fries', price: 3 },
        { id: 'none', name: 'No Side', price: -3 },
      ]
    });
  }
  // Add extras for all items
  modifiers.push({
    id: 'extras',
    name: 'Extra Options',
    type: 'checkbox',
    options: [
      { id: 'extra-fries', name: 'Extra Fries', price: 3 },
      { id: 'extra-sauce', name: 'Extra Sauce', price: 1 },
      { id: 'extra-cheese', name: 'Extra Cheese', price: 1.5 },
      { id: 'extra-veggies', name: 'Extra Veggies', price: 2 },
    ]
  });
  return modifiers;
};
const MenuItemDetail: React.FC<MenuItemDetailProps> = ({ item, onAddToCart }) => {
  const [quantity, setQuantity] = useState(1);
  const [selectedModifiers, setSelectedModifiers] = useState<Record<string, string | string[]>>({});
  const [totalPrice, setTotalPrice] = useState(item.price);
  const [specialInstructions, setSpecialInstructions] = useState('');
  // Get modifiers for this item
  const modifiers = getModifiersForItem(item.id);
  // Handle radio modifier change
  const handleRadioChange = (modifierId: string, optionId: string) => {
    // Find the option to get its price
    const modifier = modifiers.find(m => m.id === modifierId);
    const option = modifier?.options.find(o => o.id === optionId);
    // Calculate price difference between old and new selection
    let priceDifference = 0;
    const oldOptionId = selectedModifiers[modifierId] as string;
    if (oldOptionId) {
      const oldOption = modifier?.options.find(o => o.id === oldOptionId);
      if (oldOption) priceDifference -= oldOption.price;
    }
    if (option) priceDifference += option.price;
    // Update selected modifiers
    setSelectedModifiers(prev => ({
      ...prev,
      [modifierId]: optionId
    }));
    // Update total price
    setTotalPrice(prev => prev + priceDifference);
  };
  // Handle checkbox modifier change
  const handleCheckboxChange = (modifierId: string, optionId: string, checked: boolean) => {
    const modifier = modifiers.find(m => m.id === modifierId);
    const option = modifier?.options.find(o => o.id === optionId);
    // Update selected modifiers
    setSelectedModifiers(prev => {
      const current = prev[modifierId] as string[] || [];
      if (checked) {
        return {
          ...prev,
          [modifierId]: [...current, optionId]
        };
      } else {
        return {
          ...prev,
          [modifierId]: current.filter(id => id !== optionId)
        };
      }
    });
    // Update total price
    if (option) {
      setTotalPrice(prev => checked ? prev + option.price : prev - option.price);
    }
  };
  // Handle quantity change
  const handleDecrementQuantity = () => {
    if (quantity > 1) {
      setQuantity(quantity - 1);
    }
  };
  const handleIncrementQuantity = () => {
    setQuantity(quantity + 1);
  };
  // Get fallback image if Unsplash fails
  const getFallbackImage = (searchTerm: string) => {
    // Use reliable Pexels images instead of unreliable foodish-api
    return 'https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg';
  };
  return (
    <div className="h-full flex flex-col">
      <SheetPrimitive.Title id="menu-item-detail-title" className="sr-only">{item.name} Details</SheetPrimitive.Title>
      {/* Close button at the top */}
      <div className="absolute top-4 right-4 z-20">
        <Button
          variant="ghost"
          size="icon"
          className="rounded-full bg-[#16141F]/50 hover:bg-[#16141F]/70 text-white"
          onClick={() => document.querySelector('[data-radix-collection-item]')?.dispatchEvent(new MouseEvent('click', { bubbles: true }))}
        >
          <X size={18} />
        </Button>
      </div>
      <div className="relative h-40">
        <img 
          src={item.image || getFallbackImage(item.name.toLowerCase())} 
          alt={item.name}
          className="w-full h-full object-cover"
          loading="lazy"
          onError={(e) => {
            const target = e.target as HTMLImageElement;
            target.src = getFallbackImage(item.name.toLowerCase() || item.category || 'food');
          }}
        />
        <div className="absolute inset-0 bg-gradient-to-t from-[#16141F]/70 to-transparent"></div>
      </div>
      <div className="relative -mt-12 px-4 pt-4 pb-20 rounded-t-3xl z-10 flex-1 overflow-y-auto" style={{ backgroundColor: '#2D303E' }}>
        <div className="flex justify-between items-center mb-4">
          <h2 id="menu-item-title" className="text-xl font-bold text-white">{item.name}</h2>
          <span className="text-lg font-bold text-[#7B61FF]">${totalPrice.toFixed(2)}</span>
        </div>
        <div className="flex items-center gap-4 mb-2">
          <div className="flex items-center gap-2 text-xs text-muted-foreground">
            <Clock size={14} className="mr-1" />
            <span>{'10-15 min'}</span>
          </div>
        </div>
        {item.tags && item.tags.length > 0 && (
          <div className="flex flex-wrap gap-2 mb-4">
            {item.tags.map(tag => (
              <span 
                key={tag} 
                className="text-xs px-2 py-1 rounded-full text-[#7B61FF]"  
                style={{ backgroundColor: 'rgba(123, 97, 255, 0.15)', color: '#7B61FF' }}
              >
                {tag}
              </span>
            ))}
          </div>
        )}
        <p id="menu-item-description" className="text-gray-300 mb-4">{item.description}</p>
        {/* Modifiers */}
        {modifiers.length > 0 && (
          <div className="mb-4 space-y-4 max-h-[40vh] overflow-y-auto pr-1">
            {modifiers.map(modifier => (
              <div key={modifier.id} className="space-y-3">
                <div className="flex justify-between">
                  <h3 className="font-medium">
                    {modifier.name}
                    {modifier.required && <span className="text-xs text-red-500 ml-1">*</span>}
                  </h3>
                </div>
                {modifier.type === 'radio' ? (
                  <RadioGroup 
                    defaultValue={selectedModifiers[modifier.id] as string || modifier.options[0].id}
                    onValueChange={(value) => handleRadioChange(modifier.id, value)}
                  >
                    <div className="grid grid-cols-1 gap-2">
                      {modifier.options.map(option => (
                        <div key={option.id} className="flex items-center justify-between space-x-2 border border-border rounded-lg p-2">
                          <div className="flex items-center space-x-2">
                            <RadioGroupItem 
                              value={option.id} 
                              id={`${modifier.id}-${option.id}`} 
                              className="text-marian-blue border-marian-blue"
                            />
                            <Label htmlFor={`${modifier.id}-${option.id}`}>
                              {option.name}
                            </Label>
                          </div>
                          <span className="text-sm font-medium">
                            {option.price === 0 
                              ? 'Included' 
                              : option.price > 0 
                                ? `+$${option.price.toFixed(2)}` 
                                : `-$${Math.abs(option.price).toFixed(2)}`}
                          </span>
                        </div>
                      ))}
                    </div>
                  </RadioGroup>
                ) : (
                  <div className="grid grid-cols-1 gap-2">
                    {modifier.options.map(option => {
                      const isChecked = (selectedModifiers[modifier.id] as string[] || []).includes(option.id);
                      return (
                        <div key={option.id} className="flex items-center justify-between space-x-2 border border-border rounded-lg p-2">
                          <div className="flex items-center space-x-2">
                            <Checkbox 
                              id={`${modifier.id}-${option.id}`}
                              checked={isChecked}
                              onCheckedChange={(checked) => handleCheckboxChange(modifier.id, option.id, checked === true)}
                              className="text-marian-blue border-marian-blue data-[state=checked]:bg-marian-blue data-[state=checked]:border-marian-blue"
                            />
                            <Label htmlFor={`${modifier.id}-${option.id}`}>
                              {option.name}
                            </Label>
                          </div>
                          <span className="text-sm font-medium">
                            +${option.price.toFixed(2)}
                          </span>
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
        {/* Quantity selector */}
        <div className="flex items-center justify-between mb-4 mt-4">
          <span className="font-medium text-white">Quantity</span>
          <div className="flex items-center space-x-4">
            <Button 
              type="button" 
              variant="outline" 
              size="icon" 
              className="h-10 w-10 rounded-full border-[#7B61FF] text-[#7B61FF] hover:bg-[#3A3A61]/20"
              onClick={handleDecrementQuantity}
              disabled={quantity <= 1}
            >
              <MinusCircle size={18} />
            </Button>
            <span className="font-bold text-lg w-8 text-center text-white">{quantity}</span>
            <Button 
              type="button" 
              variant="outline" 
              size="icon" 
              className="h-10 w-10 rounded-full border-[#7B61FF] text-[#7B61FF] hover:bg-[#3A3A61]/20"
              onClick={handleIncrementQuantity}
            >
              <PlusCircle size={18} />
            </Button>
          </div>
        </div>
        {/* Special Instructions */}
        <div className="mb-6">
          <label htmlFor="special-instructions" className="block text-sm font-medium text-white mb-2">
            Special Instructions
          </label>
          <textarea
            id="special-instructions"
            rows={3}
            className="w-full rounded-md bg-[#2D303E] border border-[#3F4156] text-white p-3 text-sm"
            placeholder="Any special requests or notes for this item?"
            value={specialInstructions}
            onChange={(e) => setSpecialInstructions(e.target.value)}
          />
        </div>
      </div>
      {/* Total and add to cart - fixed at bottom */}
      <div className="absolute bottom-0 left-0 right-0 bg-[#1F1D2B] pt-3 pb-6 border-t border-[#3A3A61]/30 shadow-lg z-20 px-4">
        <div className="flex items-center justify-between">
          <div>
            <span className="text-sm text-muted-foreground">Total price</span>
            <div className="text-xl font-bold text-[#7B61FF]">${(totalPrice * quantity).toFixed(2)}</div>
          </div>
          <Button 
            onClick={(e) => {
              // Include special instructions when adding to cart
              onAddToCart(e);
            }}
            className="rounded-full px-8 py-6 h-auto bg-[#7B61FF] hover:bg-[#7B61FF]/90 text-white"
          >
            <Plus size={18} className="mr-2" />
            Add to Order
          </Button>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/MenuItemComponent.tsx.backup">
import React from 'react';
import { MenuItem } from '@/types';
import { Dialog, DialogContent, DialogTrigger } from '@/components/ui/dialog';
import ItemDetailDialog from '@/components/ItemDetailDialog';
import { Plus } from 'lucide-react';
import { useCart } from '@/context/CartContext';

interface MenuItemComponentProps {
  item: MenuItem;
}

export const MenuItemComponent: React.FC<MenuItemComponentProps> = ({ item }) => {
  const { addItem } = useCart();
  
  // Function to generate a different image for each item based on its ID
  const getRandomFoodImage = (id: string) => {
    const foodImages = [
      "https://images.unsplash.com/photo-1565299624946-b28f40a0ae38", // Pizza
      "https://images.unsplash.com/photo-1568901346375-23c9450c58cd", // Burger
      "https://images.unsplash.com/photo-1562967914-608f82629710", // Chicken
      "https://images.unsplash.com/photo-1630384060421-cb20d0e0649d", // Fries
      "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png", // Dal
      "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png", // Pasta
      "https://images.unsplash.com/photo-1551024506-0bccd828d307", // Dessert
      "https://images.unsplash.com/photo-1551024709-8f23befc6f87"  // Drink
    ];
    
    // Use the item's ID to consistently pick the same image for the same item
    const hashCode = id.split("").reduce((acc, char) => {
      return acc + char.charCodeAt(0);
    }, 0);
    
    return foodImages[hashCode % foodImages.length];
  };
  
  const handleAddToCart = (e: React.MouseEvent) => {
    e.stopPropagation();
    addItem(item, 1);
    toast.success(`Added ${item.name} to cart`);
  };
  
  return (
    <Dialog>
      <DialogTrigger asChild>
        <div className={`relative overflow-hidden rounded-xl transition-all duration-300 hover:shadow-lg ${
          theme === 'dark' ? 'bg-gray-800 shadow-emerald-500/10' : 'bg-white shadow-sm'
        }`}>
          {item.featured && (
            <span className="absolute top-2 right-2 bg-gradient-to-r from-emerald-500 to-emerald-600 text-white text-xs px-2 py-0.5 rounded-full z-10">
              Featured
            </span>
          )}
          <div className="aspect-[4/3] overflow-hidden">
            <img 
              src={item.image || getRandomFoodImage(item.id)} 
              alt={item.name}
              className="w-full h-full object-cover transition-transform duration-500 hover:scale-105"
              loading="lazy"
            />
          </div>
          <div className="p-2">
            <div className="flex justify-between items-start">
              <div>
                <h3 className={`text-sm font-medium text-gray-800`}>{item.name}</h3>
                <p className={`text-xs my-0.5 line-clamp-1 text-gray-500`}>{item.description}</p>
              </div>
              <div className="flex flex-col items-end">
                <span className={`text-xs font-bold text-emerald-600`}>${item.price.toFixed(2)}</span>
                <button 
                  className={`mt-1 h-5 w-5 rounded-full flex items-center justify-center text-white ${
                    theme === 'dark' ? 'bg-emerald-600 hover:bg-emerald-500' : 'bg-emerald-500 hover:bg-emerald-600'
                  } transition-colors`}
                  aria-label="Add to cart"
                  onClick={handleAddToCart}
                >
                  <Plus size={12} />
                </button>
              </div>
            </div>
          </div>
        </div>
      </DialogTrigger>
      <DialogContent className="sm:max-w-md">
        <ItemDetailDialog item={item} />
      </DialogContent>
    </Dialog>
  );
};
</file>

<file path="src/components/MenuItemList.tsx">
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { MenuItem } from "@/api/menuService";
import { ChevronLeft, ShoppingCart } from "lucide-react";
interface MenuItemListProps {
  menuItems: MenuItem[];
  onBackClick: () => void;
  onAddToCart: (item: MenuItem) => void;
  subcategoryName: string;
}
const MenuItemList = ({ 
  menuItems, 
  onBackClick, 
  onAddToCart,
  subcategoryName 
}: MenuItemListProps) => {
  return (
    <div className="container mx-auto px-4 py-6">
      <div className="flex items-center mb-6">
        <Button 
          variant="ghost" 
          onClick={onBackClick} 
          className="mr-2"
        >
          <ChevronLeft className="h-4 w-4 mr-2" />
          Back
        </Button>
        <h2 className="text-2xl font-bold">{subcategoryName}</h2>
      </div>
      {menuItems.length === 0 ? (
        <div className="text-center py-12">
          <p className="text-xl text-muted-foreground">No menu items available</p>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {menuItems.map((item) => (
            <Card key={item._id} className="overflow-hidden h-full flex flex-col">
              {item.image && (
                <div className="h-48 overflow-hidden">
                  <img 
                    src={item.image} 
                    alt={item.name} 
                    className="w-full h-full object-cover transform hover:scale-105 transition-transform duration-300"
                  />
                </div>
              )}
              <CardHeader className="pb-2">
                <CardTitle>{item.name}</CardTitle>
                {item.description && (
                  <CardDescription className="line-clamp-2">
                    {item.description}
                  </CardDescription>
                )}
              </CardHeader>
              <CardContent className="pb-3 flex-grow">
                <div className="flex justify-between items-center">
                  <p className="font-semibold text-lg">
                    Â£{item.price.toFixed(2)}
                  </p>
                  {item.allergens && item.allergens.length > 0 && (
                    <div className="text-xs text-muted-foreground">
                      Allergens: {item.allergens.join(', ')}
                    </div>
                  )}
                </div>
              </CardContent>
              <CardFooter className="pt-0">
                <Button 
                  onClick={() => onAddToCart(item)} 
                  className="w-full"
                >
                  <ShoppingCart className="h-4 w-4 mr-2" />
                  Add to Cart
                </Button>
              </CardFooter>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
};
export default MenuItemList;
</file>

<file path="src/components/MenuSubcategoryList.tsx">
import React from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Subcategory } from '@/api/menuService';
import { ArrowLeft } from 'lucide-react';
interface MenuSubcategoryListProps {
  categoryName: string;
  subcategories: Subcategory[];
  onSubcategorySelect: (subcategoryId: string) => void;
  onBackClick: () => void;
}
const MenuSubcategoryList: React.FC<MenuSubcategoryListProps> = ({ 
  categoryName,
  subcategories, 
  onSubcategorySelect,
  onBackClick
}) => {
  return (
    <div className="container mx-auto px-4 py-6">
      <div className="flex items-center mb-6">
        <Button 
          variant="ghost"
          onClick={onBackClick}
          className="mr-4"
        >
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back
        </Button>
        <h1 className="text-2xl font-bold">{categoryName}</h1>
      </div>
      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
        {subcategories.map((subcategory) => (
          <Card 
            key={subcategory._id}
            onClick={() => onSubcategorySelect(subcategory._id)}
            className="cursor-pointer h-full transition-transform hover:scale-[1.02] hover:shadow-md"
          >
            {subcategory.image && (
              <div className="w-full h-40 overflow-hidden">
                <img
                  src={subcategory.image}
                  alt={subcategory.name}
                  className="w-full h-full object-cover"
                />
              </div>
            )}
            <CardContent className="p-4">
              <h3 className="text-lg font-semibold">
                {subcategory.name}
              </h3>
              {subcategory.description && (
                <p className="text-sm text-muted-foreground mt-1">
                  {subcategory.description}
                </p>
              )}
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );
};
export default MenuSubcategoryList;
</file>

<file path="src/components/Navbar.tsx">
import React, { useState, useEffect } from 'react';
import { Link, useLocation } from 'react-router-dom';
import { useCart } from '@/context/CartContext';
import { Button } from '@/components/ui/button';
import { ShoppingCart, Heart, Menu, X } from 'lucide-react';
import { cn } from '@/lib/utils';
export const Navbar: React.FC = () => {
  const [isScrolled, setIsScrolled] = useState(false);
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const { totalItems } = useCart();
  const location = useLocation();
  useEffect(() => {
    const handleScroll = () => {
      setIsScrolled(window.scrollY > 10);
    };
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);
  useEffect(() => {
    // Close mobile menu when route changes
    setIsMenuOpen(false);
  }, [location]);
  const toggleMenu = () => setIsMenuOpen(!isMenuOpen);
  const navLinks = [
    { name: 'Home', path: '/' },
    { name: 'Menu', path: '/menu' },
    { name: 'Favorites', path: '/favorites' },
  ];
  return (
    <header
      className={cn(
        'fixed top-0 left-0 right-0 z-50 transition-all duration-300',
        isScrolled 
          ? 'bg-white/90 dark:bg-dark-background/90 backdrop-blur-md shadow-sm py-2'
          : 'bg-transparent py-4'
      )}
    >
      <div className="container px-4 mx-auto flex items-center justify-between">
        <Link to="/" className="text-2xl font-semibold">
          Taste<span className="text-primary">Mate</span>
        </Link>
        {/* Desktop Navigation */}
        <nav className="hidden md:flex items-center space-x-8">
          {navLinks.map((link) => (
            <Link
              key={link.path}
              to={link.path}
              className={cn(
                'text-foreground/80 hover:text-foreground transition-colors',
                location.pathname === link.path && 'text-foreground font-medium'
              )}
            >
              {link.name}
            </Link>
          ))}
        </nav>
        {/* Action Buttons */}
        <div className="flex items-center space-x-4">
          <Link to="/favorites" className="btn-floating bg-secondary text-secondary-foreground hover:bg-secondary/80 md:flex hidden">
            <Heart size={18} />
          </Link>
          <Link to="/cart" className="btn-floating bg-primary text-primary-foreground hover:bg-primary/90 relative">
            <ShoppingCart size={18} />
            {totalItems > 0 && (
              <span className="absolute -top-2 -right-2 bg-destructive text-destructive-foreground rounded-full text-xs w-5 h-5 flex items-center justify-center">
                {totalItems}
              </span>
            )}
          </Link>
          {/* Mobile Menu Toggle */}
          <Button
            variant="ghost"
            size="icon"
            className="md:hidden"
            onClick={toggleMenu}
            aria-label="Toggle menu"
          >
            {isMenuOpen ? <X size={20} /> : <Menu size={20} />}
          </Button>
        </div>
      </div>
      {/* Mobile Navigation */}
      <div
        className={cn(
          'md:hidden absolute left-0 right-0 top-full bg-background border-b border-border transition-all duration-300 overflow-hidden',
          isMenuOpen ? 'max-h-64' : 'max-h-0'
        )}
      >
        <div className="container px-4 py-4 mx-auto flex flex-col space-y-4">
          {navLinks.map((link) => (
            <Link
              key={link.path}
              to={link.path}
              className={cn(
                'py-2 px-4 rounded-md transition-colors',
                location.pathname === link.path
                  ? 'bg-secondary font-medium'
                  : 'hover:bg-secondary/50'
              )}
            >
              {link.name}
            </Link>
          ))}
        </div>
      </div>
    </header>
  );
};
</file>

<file path="src/components/ProtectedRoute.tsx">
import React, { useEffect } from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '@/context/AuthContext';
import { toast } from 'sonner';
interface ProtectedRouteProps {
  children: React.ReactNode;
  redirectTo?: string;
}
export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({
  children,
  redirectTo = '/login',
}) => {
  const { isAuthenticated, isLoading, user } = useAuth();
  const location = useLocation();
  useEffect(() => {
    if (!isLoading && !isAuthenticated) {
      toast.error('You must be logged in to access this page');
    }
  }, [isLoading, isAuthenticated]);
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-emerald-500 dark:border-emerald-400"></div>
      </div>
    );
  }
  if (!isAuthenticated) {
    // Save the location the user was trying to visit
    return <Navigate to={redirectTo} state={{ from: location }} replace />;
  }
  return <>{children}</>;
};
</file>

<file path="src/components/SplashScreen.tsx">
import React, { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
interface SplashScreenProps {
  onComplete: () => void;
}
const SplashScreen: React.FC<SplashScreenProps> = ({ onComplete }) => {
  const [progress, setProgress] = useState(0);
  useEffect(() => {
    const timer = setInterval(() => {
      setProgress((prev) => {
        if (prev >= 100) {
          clearInterval(timer);
          setTimeout(() => {
            onComplete();
          }, 500);
          return 100;
        }
        return prev + 5;
      });
    }, 100);
    return () => clearInterval(timer);
  }, [onComplete]);
  return (
    <AnimatePresence>
      <motion.div
        className="fixed inset-0 z-50 flex items-center justify-center bg-cover bg-center"
        style={{
          backgroundImage: "url('https://images.unsplash.com/photo-1517248135467-4c7edcad34c4?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D')",
          backgroundColor: 'rgba(0, 0, 0, 0.7)',
          backgroundBlendMode: 'overlay'
        }}
        initial={{ opacity: 1 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        transition={{ duration: 0.5 }}
      >
        <motion.div
          className="max-w-md text-center px-4"
          initial={{ scale: 0.9, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          transition={{ delay: 0.2 }}
        >
          {/* <motion.div
            className="w-24 h-24 mx-auto mb-6 flex items-center justify-center bg-white rounded-full"
            initial={{ y: 20, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{ delay: 0.4 }}
          >
            <svg 
              xmlns="http://www.w3.org/2000/svg" 
              viewBox="0 0 24 24" 
              fill="currentColor" 
              className="w-16 h-16 text-green-500"
            >
              <path d="M17 2a1 1 0 0 1 1 1v1h1a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h1V3a1 1 0 0 1 2 0v1h10V3a1 1 0 0 1 1-1zM4.5 13h15a1.5 1.5 0 0 1 1.5 1.5v7a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 3 21.5v-7A1.5 1.5 0 0 1 4.5 13z"/>
            </svg>
          </motion.div> */}
          <motion.h1
            className="text-5xl font-bold mb-4 text-white"
            initial={{ y: 20, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{ delay: 0.6 }}
          >
            IN<span className="text-green-500">SEAT</span>
          </motion.h1>
          <motion.p
            className="text-gray-300 mb-8"
            initial={{ y: 20, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{ delay: 0.7 }}
          >
            Get 20% off on your first order!
          </motion.p>
          <motion.div 
            className="w-full bg-gray-700 rounded-full h-2.5 mb-4"
            initial={{ width: 0, opacity: 0 }}
            animate={{ width: "100%", opacity: 1 }}
            transition={{ delay: 0.8 }}
          >
            <motion.div 
              className="bg-green-500 h-2.5 rounded-full"
              initial={{ width: 0 }}
              animate={{ width: `${progress}%` }}
              transition={{ duration: 2 }}
            ></motion.div>
          </motion.div>
        </motion.div>
      </motion.div>
    </AnimatePresence>
  );
};
export default SplashScreen;
</file>

<file path="src/components/TableHeader.tsx.backup">
import React, { useEffect } from 'react';
import { useTableInfo } from '@/context/TableContext';
import { Link, useLocation } from 'react-router-dom';
import { User } from 'lucide-react';
import { useAuth } from '@/context/AuthContext';

export const TableHeader: React.FC = () => {
  const { restaurantName, tableNumber, setTableInfo } = useTableInfo();
  const location = useLocation();
  const { isAuthenticated, user } = useAuth();
  
  useEffect(() => {
    // Extract table number from URL query parameters
    const queryParams = new URLSearchParams(location.search);
    const tableParam = queryParams.get('table');
    
    if (tableParam) {
      // If table parameter exists in URL, use it
      setTableInfo(prev => ({
        ...prev,
        tableNumber: tableParam
      }));
    } else if (!tableNumber) {
      // If no table number set yet, generate a random one
      const randomTable = generateRandomTableNumber();
      setTableInfo(prev => ({
        ...prev,
        tableNumber: randomTable
      }));
    }
  }, [location.search, setTableInfo, tableNumber]);
  
  // Generate a random alphanumeric table number of length 4
  const generateRandomTableNumber = (): string => {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let result = '';
    for (let i = 0; i < 4; i++) {
      result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
  };
  
  return (
    <header className="fixed top-0 left-0 right-0 z-50 bg-cover bg-center transition-all duration-300 bg-[url('/lovable-uploads/67359cb5-4e87-412a-a754-ae25100c8b48.png')] before:absolute before:inset-0 before:bg-black/60 before:backdrop-blur-sm before:z-[-1]">
      <div className="flex justify-between items-center px-4 py-2 bg-emerald-600/90 backdrop-blur-sm text-white relative">
        <div>
          <h1 className="text-sm font-medium">{restaurantName || 'InSeat'}</h1>
        </div>
        
        <div className="flex items-center justify-center bg-white/20 backdrop-blur-sm rounded-full px-3 py-1">
          <span className="text-xs font-semibold tracking-wider">TABLE {tableNumber}</span>
        </div>
        
        <Link 
          to={isAuthenticated ? '/account' : '/login'} 
          className="flex items-center gap-1 text-white"
        >
          <User size={14} />
          <span className="text-xs hidden sm:inline">
            {isAuthenticated ? (user?.name || 'Account') : 'Login'}
          </span>
        </Link>
      </div>
    </header>
  );
};

function cn(...classes: string[]) {
  return classes.filter(Boolean).join(' ');
}
</file>

<file path="src/components/ThemeToggler.tsx">
import React from 'react';
import { useTheme } from 'next-themes';
import { Button } from '@/components/ui/button';
import { Moon, Sun } from 'lucide-react';
export const ThemeToggler: React.FC = () => {
  const { theme, setTheme } = useTheme();
  return (
    <Button
      variant="ghost"
      size="icon"
      className="rounded-full h-8 w-8"
      onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
      aria-label="Toggle theme"
    >
      {theme === 'dark' ? (
        <Sun className="h-[1.2rem] w-[1.2rem]" />
      ) : (
        <Moon className="h-[1.2rem] w-[1.2rem]" />
      )}
    </Button>
  );
};
export default ThemeToggler;
</file>

<file path="src/context/FavoritesContext.tsx">
import React, { createContext, useContext, useState, useEffect } from 'react';
import { FavoritesContextType } from '@/types';
import { toast } from 'sonner';
const FavoritesContext = createContext<FavoritesContextType | undefined>(undefined);
export const FavoritesProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [favorites, setFavorites] = useState<string[]>(() => {
    const savedFavorites = localStorage.getItem('favorites');
    return savedFavorites ? JSON.parse(savedFavorites) : [];
  });
  useEffect(() => {
    localStorage.setItem('favorites', JSON.stringify(favorites));
  }, [favorites]);
  const addFavorite = (itemId: string) => {
    setFavorites(prev => {
      if (!prev.includes(itemId)) {
        toast.success('Added to favorites');
        return [...prev, itemId];
      }
      return prev;
    });
  };
  const removeFavorite = (itemId: string) => {
    setFavorites(prev => {
      if (prev.includes(itemId)) {
        toast.info('Removed from favorites');
        return prev.filter(id => id !== itemId);
      }
      return prev;
    });
  };
  const isFavorite = (itemId: string): boolean => {
    return favorites.includes(itemId);
  };
  return (
    <FavoritesContext.Provider
      value={{
        favorites,
        addFavorite,
        removeFavorite,
        isFavorite
      }}
    >
      {children}
    </FavoritesContext.Provider>
  );
};
export const useFavorites = () => {
  const context = useContext(FavoritesContext);
  if (context === undefined) {
    throw new Error('useFavorites must be used within a FavoritesProvider');
  }
  return context;
};
</file>

<file path="src/context/OrderContext.tsx">
import React, { createContext, useContext, useState, ReactNode } from 'react';
import { CartItem } from './CartContext';
import { useAuth } from './AuthContext';
import { Order } from '../types/Order';
export interface Order {
  id: string;
  items: CartItem[];
  total: number;
  status: 'pending' | 'confirmed' | 'preparing' | 'ready' | 'completed' | 'cancelled';
  createdAt: string;
  tableNumber?: string;
  userId?: string;
  restaurantId: string;
  venueId: string;
  specialInstructions?: string;
}
interface OrderContextType {
  orders: Order[];
  currentOrder: Order | null;
  createOrder: (items: CartItem[], total: number, tableNumber?: string, specialInstructions?: string) => Promise<Order>;
  getOrderHistory: () => Promise<Order[]>;
  cancelOrder: (orderId: string) => Promise<boolean>;
  loading: boolean;
  error: string | null;
  setCurrentOrder: (order: Order | null) => void;
  orderHistory: Order[];
  addToOrderHistory: (order: Order) => void;
}
const OrderContext = createContext<OrderContextType | undefined>(undefined);
export const useOrders = (): OrderContextType => {
  const context = useContext(OrderContext);
  if (!context) {
    throw new Error('useOrders must be used within an OrderProvider');
  }
  return context;
};
export const OrderProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [orders, setOrders] = useState<Order[]>([]);
  const [currentOrder, setCurrentOrder] = useState<Order | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [orderHistory, setOrderHistory] = useState<Order[]>([]);
  const { user } = useAuth();
  // Simulate restaurant and venue IDs (in a real app these would come from a configuration or current selection)
  const restaurantId = "restaurant-1";
  const venueId = "venue-1";
  const createOrder = async (
    items: CartItem[], 
    total: number, 
    tableNumber?: string,
    specialInstructions?: string
  ): Promise<Order> => {
    setLoading(true);
    setError(null);
    try {
      // In a real app, this would be an API call
      const newOrder: Order = {
        id: `order-${Date.now()}`,
        items: [...items],
        total,
        status: 'pending',
        createdAt: new Date().toISOString(),
        tableNumber,
        userId: user?.id,
        restaurantId,
        venueId,
        specialInstructions
      };
      // Simulate API delay
      await new Promise(resolve => setTimeout(resolve, 1000));
      // Save to local storage for persistence
      const savedOrders = localStorage.getItem('orders');
      const parsedOrders = savedOrders ? JSON.parse(savedOrders) : [];
      const updatedOrders = [...parsedOrders, newOrder];
      localStorage.setItem('orders', JSON.stringify(updatedOrders));
      setOrders(updatedOrders);
      setCurrentOrder(newOrder);
      addToOrderHistory(newOrder);
      return newOrder;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to create order';
      setError(errorMessage);
      throw new Error(errorMessage);
    } finally {
      setLoading(false);
    }
  };
  const getOrderHistory = async (): Promise<Order[]> => {
    setLoading(true);
    setError(null);
    try {
      // In a real app, this would be an API call filtered by user ID
      // Simulate API delay
      await new Promise(resolve => setTimeout(resolve, 500));
      const savedOrders = localStorage.getItem('orders');
      const parsedOrders = savedOrders ? JSON.parse(savedOrders) : [];
      // Filter by current user if logged in
      const userOrders = user?.id
        ? parsedOrders.filter((order: Order) => order.userId === user.id)
        : parsedOrders;
      setOrders(userOrders);
      setOrderHistory(userOrders);
      return userOrders;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch order history';
      setError(errorMessage);
      throw new Error(errorMessage);
    } finally {
      setLoading(false);
    }
  };
  const cancelOrder = async (orderId: string): Promise<boolean> => {
    setLoading(true);
    setError(null);
    try {
      // In a real app, this would be an API call
      // Simulate API delay
      await new Promise(resolve => setTimeout(resolve, 800));
      const savedOrders = localStorage.getItem('orders');
      const parsedOrders = savedOrders ? JSON.parse(savedOrders) : [];
      const updatedOrders = parsedOrders.map((order: Order) => 
        order.id === orderId 
          ? { ...order, status: 'cancelled' } 
          : order
      );
      localStorage.setItem('orders', JSON.stringify(updatedOrders));
      setOrders(updatedOrders);
      // Update current order if it's the one being cancelled
      if (currentOrder?.id === orderId) {
        setCurrentOrder({ ...currentOrder, status: 'cancelled' });
      }
      setOrderHistory(prevHistory => prevHistory.filter(o => o.id !== orderId));
      return true;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to cancel order';
      setError(errorMessage);
      throw new Error(errorMessage);
    } finally {
      setLoading(false);
    }
  };
  const addToOrderHistory = (order: Order) => {
    setOrderHistory(prevHistory => {
      // Prevent duplicates
      if (prevHistory.some(o => o.id === order.id)) {
        return prevHistory.map(o => o.id === order.id ? order : o);
      }
      return [...prevHistory, order];
    });
  };
  const value = {
    orders,
    currentOrder,
    createOrder,
    getOrderHistory,
    cancelOrder,
    loading,
    error,
    setCurrentOrder,
    orderHistory,
    addToOrderHistory
  };
  return <OrderContext.Provider value={value}>{children}</OrderContext.Provider>;
};
export default OrderContext;
</file>

<file path="src/data/orders/.gitkeep">

</file>

<file path="src/data/restaurants/.gitkeep">

</file>

<file path="src/data/users/.gitkeep">

</file>

<file path="src/data/users/users.json">
[
  {
    "id": "user_1",
    "name": "Demo User",
    "email": "user@example.com",
    "password": "hashed_password_123",
    "loyaltyPoints": 250,
    "orders": ["order_1", "order_2"],
    "createdAt": "2023-08-15T12:00:00.000Z",
    "preferences": {
      "notifications": true,
      "darkMode": true,
      "language": "en"
    },
    "address": {
      "street": "123 Main St",
      "city": "New York",
      "zipCode": "10001"
    },
    "favorites": ["item_1", "item_3"],
    "rewardLevel": "gold",
    "phoneNumber": "+1234567890"
  },
  {
    "id": "user_2", 
    "name": "John Doe",
    "email": "john@example.com",
    "password": "hashed_password_456",
    "loyaltyPoints": 150,
    "orders": ["order_3"],
    "createdAt": "2023-09-20T10:30:00.000Z",
    "preferences": {
      "notifications": true,
      "darkMode": false,
      "language": "en"
    },
    "address": {
      "street": "456 Oak Ave",
      "city": "Los Angeles", 
      "zipCode": "90001"
    },
    "favorites": ["item_2"],
    "rewardLevel": "silver",
    "phoneNumber": "+1987654321"
  }
]
</file>

<file path="src/data/categories-data.json">
[
  
  {
    "id": "promotions",
    "name": "PROMOTIONS",
    "image": "https://images.pexels.com/photos/2983101/pexels-photo-2983101.jpeg",
    "imageSearchTerm": "restaurant promotion deal",
    "subCategories": ["Daily Deals", "Happy Hour", "Combo Offers", "Special Events"]
  },
  {
    "id": "food",
    "name": "FOOD",
    "image": "https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg",
    "imageSearchTerm": "gourmet food platter",
    "subCategories": [
      "NOODLES",
      "FRIED SIDES",
      "SALADS",
      "SUSHI PLATTERS",
      "SUSHI ROLLS",
      "SLIDERS, BURGERS & SANDWICHES",
      "HOTDOGS",
      "MEXICAN TREAT",
      "DESSERTS"
    ]
  },
  {
    "id": "cinema_snacks",
    "name": "CINEMA SNACKS",
    "image": "https://images.pexels.com/photos/614117/pexels-photo-614117.jpeg",
    "imageSearchTerm": "cinema snacks popcorn nachos",
    "subCategories": ["Popcorn", "Nachos", "Candy", "Pretzels", "Soft Drinks"]
  },
  {
    "id": "mocktails",
    "name": "MOCKTAILS & FIZZ DRINKS",
    "image": "https://images.pexels.com/photos/602750/pexels-photo-602750.jpeg",
    "imageSearchTerm": "colorful mocktails bar",
    "subCategories": ["Virgin Cocktails", "Smoothies", "Shakes", "Sparkling Drinks"]
  },
  {
    "id": "beers",
    "name": "BEERS",
    "image": "https://images.pexels.com/photos/1552630/pexels-photo-1552630.jpeg",
    "imageSearchTerm": "craft beer selection",
    "subCategories": ["Draft Beers", "Bottled Beers", "Craft Beers", "Import Beers"]
  },
  {
    "id": "drinks",
    "name": "DRINKS",
    "image": "https://images.pexels.com/photos/3020919/pexels-photo-3020919.jpeg",
    "imageSearchTerm": "refreshing drinks variety",
    "subCategories": ["Coffee", "Tea", "Juices", "Soft Drinks", "Energy Drinks"]
  },
  {
    "id": "cocktails",
    "name": "COCKTAILS & ALCOHOLIC BEVERAGES",
    "image": "https://images.pexels.com/photos/1170598/pexels-photo-1170598.jpeg",
    "imageSearchTerm": "classic cocktails bar setting",
    "subCategories": ["Signature Cocktails", "Classic Cocktails", "Spirits", "Liqueurs"]
  },
  {
    "id": "wine",
    "name": "WINE LIST",
    "image": "https://images.pexels.com/photos/3019019/pexels-photo-3019019.jpeg",
    "imageSearchTerm": "wine bottles cellar",
    "subCategories": ["Red Wine", "White Wine", "RosÃ©", "Sparkling Wine", "Champagne"]
  }
]
</file>

<file path="src/data/combined-menu-items-fixed.json">
{
  "items": [
    {
      "id": "noodles-1",
      "name": "Pad Thai",
      "description": "Classic Thai stir-fried rice noodles with egg, tofu, bean sprouts and crushed peanuts",
      "price": 16.99,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "NOODLES",
      "featured": true,
      "popular": true,
      "tags": ["thai", "spicy", "vegetarian option"],
      "modifiers": [
        {
          "name": "Protein",
          "type": "single-select",
          "required": true,
          "options": [
            { "name": "Tofu", "price": 0 },
            { "name": "Chicken", "price": 2.00 },
            { "name": "Shrimp", "price": 4.00 },
            { "name": "Beef", "price": 3.00 }
          ]
        }
      ]
    },
    {
      "id": "noodles-2",
      "name": "Ramen Bowl",
      "description": "Rich miso broth with fresh ramen noodles, soft-boiled egg, char siu pork and green onions",
      "price": 18.99,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "NOODLES",
      "featured": false,
      "popular": true,
      "tags": ["japanese", "soup", "comfort food"]
    },
    {
      "id": "noodles-3",
      "name": "Udon Stir Fry",
      "description": "Thick udon noodles stir-fried with seasonal vegetables and choice of protein in a savory sauce",
      "price": 17.50,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "NOODLES",
      "featured": false,
      "popular": false,
      "tags": ["japanese", "stir fry"]
    },
    {
      "id": "noodles-4",
      "name": "Pho Bo",
      "description": "Vietnamese beef noodle soup with rice noodles, thinly sliced beef, bean sprouts and fresh herbs",
      "price": 16.50,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "NOODLES",
      "featured": true,
      "popular": false,
      "tags": ["vietnamese", "soup", "beef"]
    },
    {
      "id": "sides-1",
      "name": "Truffle Fries",
      "description": "Crispy french fries tossed in truffle oil and parmesan, with garlic aioli",
      "price": 8.99,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "FRIED SIDES",
      "featured": true,
      "popular": true,
      "tags": ["vegetarian", "truffle", "shareable"]
    },
    {
      "id": "hotdog-1",
      "name": "Classic Hot Dog",
      "description": "All-beef hot dog with ketchup, mustard, relish and onions on a soft bun",
      "price": 8.99,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "HOTDOGS",
      "featured": true,
      "popular": true,
      "tags": ["classic", "beef"]
    },
    {
      "id": "mocktail-1",
      "name": "Virgin Mojito",
      "description": "Fresh lime, mint, sugar and soda water - a refreshing classic without alcohol",
      "price": 7.99,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Virgin Cocktails",
      "featured": true,
      "popular": true,
      "tags": ["refreshing", "mint", "citrus"]
    },
    {
      "id": "red-1",
      "name": "Cabernet Sauvignon",
      "description": "Full-bodied red wine with notes of black currant, cedar, and vanilla",
      "price": 14.00,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "wine",
      "categoryId": "wine",
      "subcategory": "Red Wine",
      "featured": true,
      "popular": true,
      "tags": ["dry", "full-bodied", "red"]
    },
    {
      "id": "daily-1",
      "name": "Monday Burger Special",
      "description": "Get any burger with fries and a drink at a special combo price",
      "price": 19.99,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Daily Deals",
      "featured": true,
      "popular": true,
      "tags": ["special", "combo", "value"]
    },
    {
      "id": "daily-2",
      "name": "Taco Tuesday",
      "description": "All tacos at half price every Tuesday",
      "price": 6.50,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Daily Deals",
      "featured": true,
      "popular": true,
      "tags": ["special", "value", "mexican"]
    },
    {
      "id": "daily-3",
      "name": "Wing Wednesday",
      "description": "All-you-can-eat wings for a fixed price",
      "price": 22.99,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Daily Deals",
      "featured": false,
      "popular": true,
      "tags": ["special", "wings", "unlimited"]
    },
    {
      "id": "daily-4",
      "name": "Pizza & Pasta Thursday",
      "description": "Buy any pizza, get a pasta dish at half price",
      "price": 24.99,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Daily Deals",
      "featured": false,
      "popular": false,
      "tags": ["special", "combo", "italian"]
    },
    {
      "id": "happy-1",
      "name": "Beer Bucket",
      "description": "Five domestic beers for the price of four",
      "price": 20.00,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Happy Hour",
      "featured": true,
      "popular": true,
      "tags": ["drinks", "beer", "value"]
    },
    {
      "id": "happy-2",
      "name": "Cocktail Flight",
      "description": "Sample four of our signature cocktails in smaller portions",
      "price": 18.00,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Happy Hour",
      "featured": false,
      "popular": true,
      "tags": ["drinks", "cocktails", "sampling"]
    },
    {
      "id": "signature-1",
      "name": "House Old Fashioned",
      "description": "Bourbon, bitters, sugar, and orange peel - our take on the classic",
      "price": 12.00,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "cocktails",
      "categoryId": "cocktails",
      "subcategory": "Signature Cocktails",
      "featured": true,
      "popular": true,
      "tags": ["bourbon", "strong", "classic"]
    },
    {
      "id": "coffee-1",
      "name": "Espresso",
      "description": "Rich, concentrated coffee served in a small cup",
      "price": 3.50,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "drinks",
      "categoryId": "drinks",
      "subcategory": "Coffee",
      "featured": true,
      "popular": true,
      "tags": ["caffeine", "strong", "hot"]
    }
  ]
}
</file>

<file path="src/data/combined-menu-items.json">
{
  "items": [
    {
      "id": "noodles-1",
      "name": "Pad Thai",
      "description": "Classic Thai stir-fried rice noodles with egg, tofu, bean sprouts and crushed peanuts",
      "price": 16.99,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "NOODLES",
      "featured": true,
      "popular": true,
      "tags": ["thai", "spicy", "vegetarian option"],
      "modifiers": [
        {
          "name": "Protein",
          "type": "single-select",
          "required": true,
          "options": [
            { "name": "Tofu", "price": 0 },
            { "name": "Chicken", "price": 2.00 },
            { "name": "Shrimp", "price": 4.00 },
            { "name": "Beef", "price": 3.00 }
          ]
        }
      ]
    },
    {
      "id": "noodles-2",
      "name": "Ramen Bowl",
      "description": "Rich miso broth with fresh ramen noodles, soft-boiled egg, char siu pork and green onions",
      "price": 18.99,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "NOODLES",
      "featured": false,
      "popular": true,
      "tags": ["japanese", "soup", "comfort food"],
      "modifiers": [
        {
          "name": "Broth",
          "type": "single-select",
          "required": true,
          "options": [
            { "name": "Miso", "price": 0 },
            { "name": "Tonkotsu", "price": 0 },
            { "name": "Shoyu", "price": 0 }
          ]
        }
      ]
    },
    {
      "id": "noodles-3",
      "name": "Udon Stir Fry",
      "description": "Thick udon noodles stir-fried with seasonal vegetables and choice of protein in a savory sauce",
      "price": 17.50,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "NOODLES",
      "featured": false,
      "popular": false,
      "tags": ["japanese", "stir fry"]
    },
    {
      "id": "noodles-4",
      "name": "Pho Bo",
      "description": "Vietnamese beef noodle soup with rice noodles, thinly sliced beef, bean sprouts and fresh herbs",
      "price": 16.50,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "NOODLES",
      "featured": true,
      "popular": false,
      "tags": ["vietnamese", "soup", "beef"]
    },
    {
      "id": "sides-1",
      "name": "Truffle Fries",
      "description": "Crispy french fries tossed in truffle oil and parmesan, with garlic aioli",
      "price": 8.99,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "FRIED SIDES",
      "featured": true,
      "popular": true,
      "tags": ["vegetarian", "truffle", "shareable"]
    },
    {
      "id": "sides-2",
      "name": "Calamari Fritti",
      "description": "Lightly battered and fried squid rings served with lemon aioli and marinara sauce",
      "price": 14.50,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "FRIED SIDES",
      "featured": false,
      "popular": true,
      "tags": ["seafood", "appetizer"]
    },
    {
      "id": "sides-3",
      "name": "Mozzarella Sticks",
      "description": "Breaded and fried mozzarella cheese sticks with marinara dipping sauce",
      "price": 9.99,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "FRIED SIDES",
      "featured": false,
      "popular": false,
      "tags": ["vegetarian", "cheese", "appetizer"]
    },
    {
      "id": "sides-4",
      "name": "Buffalo Wings",
      "description": "Crispy chicken wings tossed in spicy buffalo sauce with blue cheese dip and celery sticks",
      "price": 13.99,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "FRIED SIDES",
      "featured": true,
      "popular": true,
      "tags": ["spicy", "chicken", "shareable"]
    },
    {
      "id": "salad-1",
      "name": "Caesar Salad",
      "description": "Crisp romaine lettuce, garlic croutons, parmesan and creamy caesar dressing",
      "price": 12.50,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SALADS",
      "featured": true,
      "popular": true,
      "tags": ["classic", "vegetarian option"]
    },
    {
      "id": "salad-2",
      "name": "Greek Salad",
      "description": "Fresh cucumbers, tomatoes, red onion, kalamata olives, and feta cheese with herb vinaigrette",
      "price": 13.99,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SALADS",
      "featured": false,
      "popular": false,
      "tags": ["vegetarian", "mediterranean"]
    },
    {
      "id": "salad-3",
      "name": "Quinoa Power Bowl",
      "description": "Protein-rich quinoa with roasted seasonal vegetables, avocado and lemon tahini dressing",
      "price": 15.50,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SALADS",
      "featured": true,
      "popular": false,
      "tags": ["vegan", "gluten-free", "healthy"]
    },
    {
      "id": "salad-4",
      "name": "Cobb Salad",
      "description": "Mixed greens with grilled chicken, bacon, hard-boiled egg, avocado, tomato and blue cheese",
      "price": 16.99,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SALADS",
      "featured": false,
      "popular": true,
      "tags": ["protein", "classic", "hearty"]
    },
    {
      "id": "sushi-platter-1",
      "name": "Sashimi Deluxe",
      "description": "Chef's selection of 15 pieces of premium fish sashimi with wasabi and pickled ginger",
      "price": 28.99,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI PLATTERS",
      "featured": true,
      "popular": true,
      "tags": ["raw", "seafood", "japanese"]
    },
    {
      "id": "sushi-platter-2",
      "name": "Nigiri Assortment",
      "description": "12 pieces of hand-pressed sushi rice topped with fresh fish and seafood",
      "price": 24.50,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI PLATTERS",
      "featured": false,
      "popular": true,
      "tags": ["japanese", "traditional"]
    },
    {
      "id": "sushi-platter-3",
      "name": "Maki Combo",
      "description": "Assortment of 24 pieces of maki rolls including California, Spicy Tuna, and Philadelphia rolls",
      "price": 32.99,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI PLATTERS",
      "featured": true,
      "popular": false,
      "tags": ["shareable", "japanese", "variety"]
    },
    {
      "id": "sushi-platter-4",
      "name": "Chef's Special Platter",
      "description": "Premium selection of nigiri, sashimi and specialty rolls curated by our head sushi chef",
      "price": 45.00,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI PLATTERS",
      "featured": true,
      "popular": true,
      "tags": ["premium", "japanese", "special"]
    },
    {
      "id": "roll-1",
      "name": "California Roll",
      "description": "Crab, avocado and cucumber wrapped in nori and rice with sesame seeds",
      "price": 8.99,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI ROLLS",
      "featured": false,
      "popular": true,
      "tags": ["classic", "beginner friendly"]
    },
    {
      "id": "roll-2",
      "name": "Spicy Tuna Roll",
      "description": "Fresh tuna mixed with spicy mayo and cucumber wrapped in nori and rice",
      "price": 10.50,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI ROLLS",
      "featured": true,
      "popular": true,
      "tags": ["spicy", "popular"]
    },
    {
      "id": "roll-3",
      "name": "Dragon Roll",
      "description": "Eel and cucumber inside, topped with avocado and eel sauce",
      "price": 14.99,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI ROLLS",
      "featured": true,
      "popular": false,
      "tags": ["specialty", "cooked option"]
    },
    {
      "id": "roll-4",
      "name": "Rainbow Roll",
      "description": "California roll topped with assorted slices of fresh fish and avocado",
      "price": 15.50,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI ROLLS",
      "featured": false,
      "popular": true,
      "tags": ["colorful", "variety"]
    },
    {
      "id": "burger-1",
      "name": "Classic Cheeseburger",
      "description": "Juicy beef patty with cheddar cheese, lettuce, tomato, and special sauce on a brioche bun",
      "price": 14.99,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SLIDERS, BURGERS & SANDWICHES",
      "featured": true,
      "popular": true,
      "tags": ["beef", "classic"]
    },
    {
      "id": "burger-2",
      "name": "Mushroom Swiss Burger",
      "description": "Beef patty topped with sautÃ©ed mushrooms, Swiss cheese and truffle aioli",
      "price": 16.50,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SLIDERS, BURGERS & SANDWICHES",
      "featured": false,
      "popular": false,
      "tags": ["beef", "mushroom", "truffle"]
    },
    {
      "id": "burger-3",
      "name": "Veggie Burger",
      "description": "House-made plant-based patty with avocado, sprouts, and vegan chipotle mayo",
      "price": 15.99,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SLIDERS, BURGERS & SANDWICHES",
      "featured": true,
      "popular": false,
      "tags": ["vegetarian", "plant-based", "healthy"]
    },
    {
      "id": "burger-4",
      "name": "BBQ Bacon Burger",
      "description": "Angus beef patty with crispy bacon, cheddar, onion rings, and smoky BBQ sauce",
      "price": 17.99,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SLIDERS, BURGERS & SANDWICHES",
      "featured": false,
      "popular": true,
      "tags": ["beef", "bacon", "bbq", "smoky"]
    }
  ]
}
{
  "items": [
    {
      "id": "hotdog-1",
      "name": "Classic Hot Dog",
      "description": "All-beef hot dog with ketchup, mustard, relish and onions on a soft bun",
      "price": 8.99,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "HOTDOGS",
      "featured": true,
      "popular": true,
      "tags": ["classic", "beef"]
    },
    {
      "id": "hotdog-2",
      "name": "Chicago-Style Dog",
      "description": "All-beef hot dog with mustard, relish, onion, tomato, pickle, sport peppers, and celery salt",
      "price": 10.50,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "HOTDOGS",
      "featured": false,
      "popular": false,
      "tags": ["regional", "loaded"]
    },
    {
      "id": "hotdog-3",
      "name": "Chili Cheese Dog",
      "description": "Hot dog smothered in beef chili, cheddar cheese, and diced onions",
      "price": 11.99,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "HOTDOGS",
      "featured": true,
      "popular": true,
      "tags": ["spicy", "cheese", "hearty"]
    },
    {
      "id": "hotdog-4",
      "name": "Vegan Hot Dog",
      "description": "Plant-based hot dog with avocado, jalapeÃ±os, and vegan aioli",
      "price": 9.99,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "HOTDOGS",
      "featured": false,
      "popular": false,
      "tags": ["vegan", "plant-based"]
    },
    {
      "id": "mexican-1",
      "name": "Street Tacos",
      "description": "Three corn tortillas with your choice of protein, onion, cilantro, and lime",
      "price": 12.99,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "MEXICAN TREAT",
      "featured": true,
      "popular": true,
      "tags": ["authentic", "customizable"]
    },
    {
      "id": "mexican-2",
      "name": "Chicken Quesadilla",
      "description": "Grilled flour tortilla filled with marinated chicken, melted cheese, and pico de gallo",
      "price": 14.50,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "MEXICAN TREAT",
      "featured": false,
      "popular": true,
      "tags": ["cheese", "chicken", "grilled"]
    },
    {
      "id": "mexican-3",
      "name": "Loaded Nachos",
      "description": "Crispy tortilla chips layered with refried beans, queso, guacamole, jalapeÃ±os, and sour cream",
      "price": 13.99,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "MEXICAN TREAT",
      "featured": true,
      "popular": false,
      "tags": ["shareable", "spicy option"]
    },
    {
      "id": "mexican-4",
      "name": "Beef Burrito",
      "description": "Large flour tortilla filled with seasoned ground beef, rice, beans, cheese, and pico de gallo",
      "price": 15.99,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "MEXICAN TREAT",
      "featured": false,
      "popular": true,
      "tags": ["beef", "hearty", "filling"]
    },
    {
      "id": "dessert-1",
      "name": "Chocolate Lava Cake",
      "description": "Warm chocolate cake with a molten center, served with vanilla ice cream",
      "price": 8.99,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "DESSERTS",
      "featured": true,
      "popular": true,
      "tags": ["chocolate", "warm", "ice cream"]
    },
    {
      "id": "dessert-2",
      "name": "New York Cheesecake",
      "description": "Classic creamy cheesecake with graham cracker crust and berry compote",
      "price": 9.50,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "DESSERTS",
      "featured": false,
      "popular": true,
      "tags": ["creamy", "classic", "berries"]
    },
    {
      "id": "dessert-3",
      "name": "Tiramisu",
      "description": "Italian coffee-flavored dessert with layers of mascarpone and ladyfingers",
      "price": 8.99,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "DESSERTS",
      "featured": true,
      "popular": false,
      "tags": ["coffee", "italian", "creamy"]
    },
    {
      "id": "dessert-4",
      "name": "CrÃ¨me BrÃ»lÃ©e",
      "description": "Silky vanilla custard with caramelized sugar crust",
      "price": 9.99,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "DESSERTS",
      "featured": false,
      "popular": false,
      "tags": ["french", "vanilla", "caramel"]
    },
    {
      "id": "daily-1",
      "name": "Monday Burger Special",
      "description": "Get any burger with fries and a drink at a special combo price",
      "price": 19.99,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Daily Deals",
      "featured": true,
      "popular": true,
      "tags": ["special", "combo", "value"]
    },
    {
      "id": "daily-2",
      "name": "Taco Tuesday",
      "description": "All tacos at half price every Tuesday",
      "price": 6.50,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Daily Deals",
      "featured": true,
      "popular": true,
      "tags": ["special", "value", "mexican"]
    },
    {
      "id": "daily-3",
      "name": "Wing Wednesday",
      "description": "All-you-can-eat wings for a fixed price",
      "price": 22.99,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Daily Deals",
      "featured": false,
      "popular": true,
      "tags": ["special", "wings", "unlimited"]
    },
    {
      "id": "daily-4",
      "name": "Pizza & Pasta Thursday",
      "description": "Buy any pizza, get a pasta dish at half price",
      "price": 24.99,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Daily Deals",
      "featured": false,
      "popular": false,
      "tags": ["special", "combo", "italian"]
    },
    {
      "id": "happy-1",
      "name": "Beer Bucket",
      "description": "Five domestic beers for the price of four",
      "price": 20.00,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Happy Hour",
      "featured": true,
      "popular": true,
      "tags": ["drinks", "beer", "value"]
    },
    {
      "id": "happy-2",
      "name": "Cocktail Flight",
      "description": "Sample four of our signature cocktails in smaller portions",
      "price": 18.00,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Happy Hour",
      "featured": false,
      "popular": true,
      "tags": ["drinks", "cocktails", "sampling"]
    },
    {
      "id": "happy-3",
      "name": "Half-Price Appetizers",
      "description": "All appetizers are half price during happy hour 4-6pm",
      "price": 6.50,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Happy Hour",
      "featured": true,
      "popular": false,
      "tags": ["appetizers", "value", "food"]
    },
    {
      "id": "happy-4",
      "name": "Wine Wednesday",
      "description": "All wine bottles at half price on Wednesdays",
      "price": 25.00,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Happy Hour",
      "featured": false,
      "popular": true,
      "tags": ["wine", "value", "drinks"]
    },
    {
      "id": "combo-1",
      "name": "Family Feast",
      "description": "Meal for four with appetizers, main courses, sides, and desserts",
      "price": 89.99,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Combo Offers",
      "featured": true,
      "popular": true,
      "tags": ["family", "combo", "value"]
    },
    {
      "id": "combo-2",
      "name": "Date Night Special",
      "description": "Two entrees, a shared appetizer, and a bottle of wine",
      "price": 65.00,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Combo Offers",
      "featured": true,
      "popular": false,
      "tags": ["couple", "romantic", "combo"]
    },
    {
      "id": "combo-3",
      "name": "Lunch Express",
      "description": "Soup or salad, main course, and a soft drink - ready in 15 minutes",
      "price": 16.99,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Combo Offers",
      "featured": false,
      "popular": true,
      "tags": ["lunch", "quick", "value"]
    },
    {
      "id": "combo-4",
      "name": "Weekend Brunch",
      "description": "Brunch entree with unlimited mimosas or bloody marys",
      "price": 29.99,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Combo Offers",
      "featured": false,
      "popular": true,
      "tags": ["brunch", "weekend", "drinks"]
    },
    {
      "id": "event-1",
      "name": "New Year's Eve Dinner",
      "description": "Five-course meal with champagne toast at midnight",
      "price": 125.00,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Special Events",
      "featured": true,
      "popular": true,
      "tags": ["holiday", "special", "premium"]
    },
    {
      "id": "event-2",
      "name": "Valentine's Day Package",
      "description": "Romantic dinner for two with wine pairing and dessert",
      "price": 150.00,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Special Events",
      "featured": false,
      "popular": true,
      "tags": ["romantic", "special", "holiday"]
    },
    {
      "id": "event-3",
      "name": "Mother's Day Brunch",
      "description": "Special brunch buffet with complimentary mimosa for moms",
      "price": 45.00,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Special Events",
      "featured": true,
      "popular": false,
      "tags": ["holiday", "brunch", "special"]
    },
    {
      "id": "event-4",
      "name": "Private Dining Package",
      "description": "Custom menu for private events and celebrations",
      "price": 85.00,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Special Events",
      "featured": false,
      "popular": true,
      "tags": ["private", "custom", "celebration"]
    }
  ]
}
{
  "items": [
    {
      "id": "mocktail-1",
      "name": "Virgin Mojito",
      "description": "Fresh lime, mint, sugar and soda water - a refreshing classic without alcohol",
      "price": 7.99,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Virgin Cocktails",
      "featured": true,
      "popular": true,
      "tags": ["refreshing", "mint", "citrus"]
    },
    {
      "id": "mocktail-2",
      "name": "Strawberry Daiquiri Mocktail",
      "description": "Blended strawberries, lime juice, and ice for a fruity frozen treat",
      "price": 8.50,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Virgin Cocktails",
      "featured": false,
      "popular": true,
      "tags": ["fruity", "frozen", "sweet"]
    },
    {
      "id": "mocktail-3",
      "name": "PiÃ±a Colada Mocktail",
      "description": "Coconut cream, pineapple juice, and ice blended to tropical perfection",
      "price": 9.50,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Virgin Cocktails",
      "featured": true,
      "popular": false,
      "tags": ["tropical", "creamy", "coconut"]
    },
    {
      "id": "mocktail-4",
      "name": "Virgin Sangria",
      "description": "Mixture of fruit juices with fresh fruit pieces and a splash of soda",
      "price": 8.99,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Virgin Cocktails",
      "featured": false,
      "popular": true,
      "tags": ["fruity", "refreshing", "colorful"]
    },
    {
      "id": "smoothie-1",
      "name": "Berry Blast",
      "description": "Mixed berries, banana, yogurt and honey blended with ice",
      "price": 7.50,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Smoothies",
      "featured": true,
      "popular": true,
      "tags": ["berries", "healthy", "sweet"]
    },
    {
      "id": "smoothie-2",
      "name": "Green Machine",
      "description": "Spinach, kale, green apple, banana, and almond milk for an energizing boost",
      "price": 8.99,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Smoothies",
      "featured": false,
      "popular": false,
      "tags": ["healthy", "green", "detox"]
    },
    {
      "id": "smoothie-3",
      "name": "Tropical Paradise",
      "description": "Mango, pineapple, papaya, and coconut water for an island-inspired treat",
      "price": 8.50,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Smoothies",
      "featured": true,
      "popular": true,
      "tags": ["tropical", "fruity", "sweet"]
    },
    {
      "id": "smoothie-4",
      "name": "Protein Powerhouse",
      "description": "Banana, peanut butter, chocolate protein powder, and almond milk for a post-workout boost",
      "price": 9.99,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Smoothies",
      "featured": false,
      "popular": false,
      "tags": ["protein", "filling", "fitness"]
    },
    {
      "id": "shake-1",
      "name": "Classic Chocolate Shake",
      "description": "Creamy vanilla ice cream blended with chocolate syrup, topped with whipped cream",
      "price": 6.99,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Shakes",
      "featured": true,
      "popular": true,
      "tags": ["chocolate", "dessert", "classic"]
    },
    {
      "id": "shake-2",
      "name": "Strawberry Shortcake",
      "description": "Vanilla ice cream blended with fresh strawberries and pieces of pound cake",
      "price": 7.50,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Shakes",
      "featured": false,
      "popular": true,
      "tags": ["strawberry", "dessert", "sweet"]
    },
    {
      "id": "shake-3",
      "name": "Cookies & Cream",
      "description": "Vanilla ice cream blended with chocolate cookie pieces and topped with cookie crumbs",
      "price": 7.99,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Shakes",
      "featured": true,
      "popular": false,
      "tags": ["cookies", "dessert", "sweet"]
    },
    {
      "id": "shake-4",
      "name": "Salted Caramel",
      "description": "Caramel ice cream blended with salted caramel sauce, topped with whipped cream and pretzel pieces",
      "price": 8.50,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Shakes",
      "featured": false,
      "popular": true,
      "tags": ["caramel", "sweet-salty", "dessert"]
    },
    {
      "id": "sparkling-1",
      "name": "Italian Soda",
      "description": "Club soda with your choice of flavored syrup and a splash of cream",
      "price": 5.99,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Sparkling Drinks",
      "featured": true,
      "popular": true,
      "tags": ["customizable", "sweet", "refreshing"]
    },
    {
      "id": "sparkling-2",
      "name": "Cucumber Mint Spritzer",
      "description": "Fresh cucumber, mint, lime, and sparkling water for a cool, refreshing drink",
      "price": 6.50,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Sparkling Drinks",
      "featured": false,
      "popular": false,
      "tags": ["refreshing", "herbal", "light"]
    },
    {
      "id": "sparkling-3",
      "name": "Berry Sparkler",
      "description": "Mixed berry purÃ©e topped with sparkling water and fresh berries",
      "price": 7.50,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Sparkling Drinks",
      "featured": true,
      "popular": false,
      "tags": ["berries", "fruity", "colorful"]
    },
    {
      "id": "sparkling-4",
      "name": "Ginger Fizz",
      "description": "Fresh ginger syrup, lemon juice, and sparkling water with a hint of mint",
      "price": 6.99,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Sparkling Drinks",
      "featured": false,
      "popular": true,
      "tags": ["spicy", "refreshing", "digestive"]
    },
    {
      "id": "draft-1",
      "name": "House Lager",
      "description": "Our signature crisp, clean lager with subtle malt flavor",
      "price": 7.00,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "beers",
      "categoryId": "beers",
      "subcategory": "Draft Beers",
      "featured": true,
      "popular": true,
      "tags": ["lager", "refreshing", "house brew"]
    },
    {
      "id": "draft-2",
      "name": "IPA",
      "description": "Hoppy India Pale Ale with citrus and pine notes",
      "price": 8.00,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "beers",
      "categoryId": "beers",
      "subcategory": "Draft Beers",
      "featured": false,
      "popular": true,
      "tags": ["hoppy", "bitter", "aromatic"]
    },
    {
      "id": "draft-3",
      "name": "Wheat Beer",
      "description": "Smooth, light-bodied wheat beer with hints of banana and clove",
      "price": 7.50,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "beers",
      "categoryId": "beers",
      "subcategory": "Draft Beers",
      "featured": true,
      "popular": false,
      "tags": ["wheat", "light", "refreshing"]
    },
    {
      "id": "draft-4",
      "name": "Seasonal Brew",
      "description": "Rotating tap featuring our brewmaster's seasonal creation",
      "price": 8.50,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "beers",
      "categoryId": "beers",
      "subcategory": "Draft Beers",
      "featured": false,
      "popular": true,
      "tags": ["seasonal", "limited", "special"]
    }
  ]
}
{
  "items": [
    {
      "id": "red-1",
      "name": "Cabernet Sauvignon",
      "description": "Full-bodied red wine with notes of black currant, cedar, and vanilla",
      "price": 14.00,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "wine",
      "categoryId": "wine",
      "subcategory": "Red Wine",
      "featured": true,
      "popular": true,
      "tags": ["dry", "full-bodied", "red"]
    },
    {
      "id": "red-2",
      "name": "Pinot Noir",
      "description": "Medium-bodied red wine with notes of cherry, raspberry, and earthy undertones",
      "price": 16.00,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "wine",
      "categoryId": "wine",
      "subcategory": "Red Wine",
      "featured": false,
      "popular": true,
      "tags": ["medium-bodied", "fruity", "red"]
    },
    {
      "id": "red-3",
      "name": "Merlot",
      "description": "Smooth red wine with notes of plum, black cherry, and chocolate",
      "price": 13.00,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "wine",
      "categoryId": "wine",
      "subcategory": "Red Wine",
      "featured": true,
      "popular": false,
      "tags": ["smooth", "fruity", "red"]
    },
    {
      "id": "red-4",
      "name": "Malbec",
      "description": "Bold red wine with notes of blackberry, plum, and a hint of tobacco",
      "price": 15.00,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "wine",
      "categoryId": "wine",
      "subcategory": "Red Wine",
      "featured": false,
      "popular": true,
      "tags": ["bold", "rich", "red"]
    },
    {
      "id": "white-1",
      "name": "Chardonnay",
      "description": "Medium to full-bodied white wine with notes of apple, pear, and vanilla",
      "price": 13.00,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "wine",
      "categoryId": "wine",
      "subcategory": "White Wine",
      "featured": true,
      "popular": true,
      "tags": ["dry", "oaked", "white"]
    },
    {
      "id": "white-2",
      "name": "Sauvignon Blanc",
      "description": "Crisp white wine with notes of grapefruit, gooseberry, and fresh grass",
      "price": 12.00,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "wine",
      "categoryId": "wine",
      "subcategory": "White Wine",
      "featured": false,
      "popular": false,
      "tags": ["crisp", "acidic", "white"]
    },
    {
      "id": "white-3",
      "name": "Pinot Grigio",
      "description": "Light-bodied white wine with notes of citrus, apple, and pear",
      "price": 12.00,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "wine",
      "categoryId": "wine",
      "subcategory": "White Wine",
      "featured": true,
      "popular": true,
      "tags": ["light", "refreshing", "white"]
    },
    {
      "id": "white-4",
      "name": "Riesling",
      "description": "Aromatic white wine with notes of peach, apricot, and honey",
      "price": 14.00,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "wine",
      "categoryId": "wine",
      "subcategory": "White Wine",
      "featured": false,
      "popular": false,
      "tags": ["aromatic", "sweet", "white"]
    },
    {
      "id": "signature-1",
      "name": "House Old Fashioned",
      "description": "Bourbon, bitters, sugar, and orange peel - our take on the classic",
      "price": 12.00,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "cocktails",
      "categoryId": "cocktails",
      "subcategory": "Signature Cocktails",
      "featured": true,
      "popular": true,
      "tags": ["bourbon", "strong", "classic"]
    },
    {
      "id": "signature-2",
      "name": "Berry Bliss",
      "description": "Vodka, fresh berries, lime, and mint - sweet and refreshing",
      "price": 14.00,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "cocktails",
      "categoryId": "cocktails",
      "subcategory": "Signature Cocktails",
      "featured": false,
      "popular": true,
      "tags": ["vodka", "fruity", "refreshing"]
    },
    {
      "id": "signature-3",
      "name": "Smoky JalapeÃ±o Margarita",
      "description": "Mezcal, lime, agave, and jalapeÃ±o for a spicy-smoky twist",
      "price": 15.00,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "cocktails",
      "categoryId": "cocktails",
      "subcategory": "Signature Cocktails",
      "featured": true,
      "popular": false,
      "tags": ["mezcal", "spicy", "smoky"]
    },
    {
      "id": "signature-4",
      "name": "Cucumber Elderflower Spritz",
      "description": "Gin, elderflower liqueur, cucumber, and sparkling water - light and floral",
      "price": 13.00,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "cocktails",
      "categoryId": "cocktails",
      "subcategory": "Signature Cocktails",
      "featured": false,
      "popular": true,
      "tags": ["gin", "floral", "refreshing"]
    },
    {
      "id": "classic-1",
      "name": "Negroni",
      "description": "Equal parts gin, Campari, and sweet vermouth with an orange twist",
      "price": 12.00,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "cocktails",
      "categoryId": "cocktails",
      "subcategory": "Classic Cocktails",
      "featured": true,
      "popular": true,
      "tags": ["gin", "bitter", "strong"]
    },
    {
      "id": "classic-2",
      "name": "Manhattan",
      "description": "Rye whiskey, sweet vermouth, and bitters with a cherry garnish",
      "price": 13.00,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "cocktails",
      "categoryId": "cocktails",
      "subcategory": "Classic Cocktails",
      "featured": false,
      "popular": true,
      "tags": ["whiskey", "strong", "classic"]
    },
    {
      "id": "classic-3",
      "name": "Mojito",
      "description": "White rum, fresh lime, mint, sugar, and soda water - a Cuban classic",
      "price": 11.00,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "cocktails",
      "categoryId": "cocktails",
      "subcategory": "Classic Cocktails",
      "featured": true,
      "popular": true,
      "tags": ["rum", "mint", "refreshing"]
    },
    {
      "id": "classic-4",
      "name": "Cosmopolitan",
      "description": "Vodka, cranberry, lime, and orange liqueur - perfectly balanced",
      "price": 12.00,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "cocktails",
      "categoryId": "cocktails",
      "subcategory": "Classic Cocktails",
      "featured": false,
      "popular": false,
      "tags": ["vodka", "cranberry", "fruity"]
    },
    {
      "id": "coffee-1",
      "name": "Espresso",
      "description": "Rich, concentrated coffee served in a small cup",
      "price": 3.50,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "drinks",
      "categoryId": "drinks",
      "subcategory": "Coffee",
      "featured": true,
      "popular": true,
      "tags": ["caffeine", "strong", "hot"]
    },
    {
      "id": "coffee-2",
      "name": "Cappuccino",
      "description": "Espresso with equal parts steamed milk and milk foam",
      "price": 4.50,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "drinks",
      "categoryId": "drinks",
      "subcategory": "Coffee",
      "featured": false,
      "popular": true,
      "tags": ["milk", "creamy", "hot"]
    },
    {
      "id": "coffee-3",
      "name": "Cold Brew",
      "description": "Smooth, less acidic coffee steeped overnight and served cold",
      "price": 5.00,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "drinks",
      "categoryId": "drinks",
      "subcategory": "Coffee",
      "featured": true,
      "popular": false,
      "tags": ["cold", "smooth", "strong"]
    },
    {
      "id": "coffee-4",
      "name": "Mocha",
      "description": "Espresso with chocolate syrup and steamed milk, topped with whipped cream",
      "price": 5.50,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "drinks",
      "categoryId": "drinks",
      "subcategory": "Coffee",
      "featured": false,
      "popular": true,
      "tags": ["chocolate", "sweet", "hot"]
    },
    {
      "id": "tea-1",
      "name": "English Breakfast",
      "description": "Robust black tea blend - the perfect morning cup",
      "price": 3.00,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "drinks",
      "categoryId": "drinks",
      "subcategory": "Tea",
      "featured": true,
      "popular": true,
      "tags": ["black tea", "caffeine", "hot"]
    },
    {
      "id": "tea-2",
      "name": "Green Tea",
      "description": "Delicate Japanese green tea with a light, grassy flavor",
      "price": 3.50,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "drinks",
      "categoryId": "drinks",
      "subcategory": "Tea",
      "featured": false,
      "popular": true,
      "tags": ["green tea", "light", "antioxidants"]
    },
    {
      "id": "tea-3",
      "name": "Chamomile",
      "description": "Soothing herbal tea with floral notes and calming properties",
      "price": 3.50,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "drinks",
      "categoryId": "drinks",
      "subcategory": "Tea",
      "featured": true,
      "popular": false,
      "tags": ["herbal", "caffeine-free", "relaxing"]
    },
    {
      "id": "tea-4",
      "name": "Chai Latte",
      "description": "Spiced black tea with steamed milk and aromatic spices",
      "price": 4.50,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "drinks",
      "categoryId": "drinks",
      "subcategory": "Tea",
      "featured": false,
      "popular": true,
      "tags": ["spiced", "creamy", "hot"]
    }
  ]
}
</file>

<file path="src/data/menu-data.json">
{
  "categories": [
    {
      "id": "burger",
      "name": "Burgers",
      "image": "https://images.unsplash.com/photo-1568901346375-23c9450c58cd",
      "restaurantId": "rest1"
    },
    {
      "id": "pizza",
      "name": "Pizza",
      "image": "https://images.unsplash.com/photo-1565299624946-b28f40a0ae38",
      "restaurantId": "rest1"
    },
    {
      "id": "fries",
      "name": "Fries",
      "image": "https://images.unsplash.com/photo-1630384060421-cb20d0e0649d",
      "restaurantId": "rest1"
    },
    {
      "id": "chicken",
      "name": "Chicken",
      "image": "https://images.unsplash.com/photo-1562967914-608f82629710",
      "restaurantId": "rest1"
    },
    {
      "id": "curry",
      "name": "Curry",
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "restaurantId": "rest1"
    },
    {
      "id": "desserts",
      "name": "Desserts",
      "image": "https://images.unsplash.com/photo-1551024506-0bccd828d307",
      "restaurantId": "rest1"
    },
    {
      "id": "drinks",
      "name": "Drinks",
      "image": "https://images.unsplash.com/photo-1551024709-8f23befc6f87",
      "restaurantId": "rest1"
    },
    {
      "id": "pasta",
      "name": "Pasta",
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "restaurantId": "rest1"
    }
  ]
}
</file>

<file path="src/data/menu-items-complete-final.json">
{
  "items": [
    {
      "id": "red-1",
      "name": "Cabernet Sauvignon",
      "description": "Full-bodied red wine with notes of black currant, cedar, and vanilla",
      "price": 14.00,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "wine",
      "categoryId": "wine",
      "subcategory": "Red Wine",
      "featured": true,
      "popular": true,
      "tags": ["dry", "full-bodied", "red"]
    },
    {
      "id": "red-2",
      "name": "Pinot Noir",
      "description": "Medium-bodied red wine with notes of cherry, raspberry, and earthy undertones",
      "price": 16.00,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "wine",
      "categoryId": "wine",
      "subcategory": "Red Wine",
      "featured": false,
      "popular": true,
      "tags": ["medium-bodied", "fruity", "red"]
    },
    {
      "id": "red-3",
      "name": "Merlot",
      "description": "Smooth red wine with notes of plum, black cherry, and chocolate",
      "price": 13.00,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "wine",
      "categoryId": "wine",
      "subcategory": "Red Wine",
      "featured": true,
      "popular": false,
      "tags": ["smooth", "fruity", "red"]
    },
    {
      "id": "red-4",
      "name": "Malbec",
      "description": "Bold red wine with notes of blackberry, plum, and a hint of tobacco",
      "price": 15.00,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "wine",
      "categoryId": "wine",
      "subcategory": "Red Wine",
      "featured": false,
      "popular": true,
      "tags": ["bold", "rich", "red"]
    },
    {
      "id": "white-1",
      "name": "Chardonnay",
      "description": "Medium to full-bodied white wine with notes of apple, pear, and vanilla",
      "price": 13.00,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "wine",
      "categoryId": "wine",
      "subcategory": "White Wine",
      "featured": true,
      "popular": true,
      "tags": ["dry", "oaked", "white"]
    },
    {
      "id": "white-2",
      "name": "Sauvignon Blanc",
      "description": "Crisp white wine with notes of grapefruit, gooseberry, and fresh grass",
      "price": 12.00,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "wine",
      "categoryId": "wine",
      "subcategory": "White Wine",
      "featured": false,
      "popular": false,
      "tags": ["crisp", "acidic", "white"]
    },
    {
      "id": "white-3",
      "name": "Pinot Grigio",
      "description": "Light-bodied white wine with notes of citrus, apple, and pear",
      "price": 12.00,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "wine",
      "categoryId": "wine",
      "subcategory": "White Wine",
      "featured": true,
      "popular": true,
      "tags": ["light", "refreshing", "white"]
    },
    {
      "id": "white-4",
      "name": "Riesling",
      "description": "Aromatic white wine with notes of peach, apricot, and honey",
      "price": 14.00,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "wine",
      "categoryId": "wine",
      "subcategory": "White Wine",
      "featured": false,
      "popular": false,
      "tags": ["aromatic", "sweet", "white"]
    },
    {
      "id": "signature-1",
      "name": "House Old Fashioned",
      "description": "Bourbon, bitters, sugar, and orange peel - our take on the classic",
      "price": 12.00,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "cocktails",
      "categoryId": "cocktails",
      "subcategory": "Signature Cocktails",
      "featured": true,
      "popular": true,
      "tags": ["bourbon", "strong", "classic"]
    },
    {
      "id": "signature-2",
      "name": "Berry Bliss",
      "description": "Vodka, fresh berries, lime, and mint - sweet and refreshing",
      "price": 14.00,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "cocktails",
      "categoryId": "cocktails",
      "subcategory": "Signature Cocktails",
      "featured": false,
      "popular": true,
      "tags": ["vodka", "fruity", "refreshing"]
    },
    {
      "id": "signature-3",
      "name": "Smoky JalapeÃ±o Margarita",
      "description": "Mezcal, lime, agave, and jalapeÃ±o for a spicy-smoky twist",
      "price": 15.00,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "cocktails",
      "categoryId": "cocktails",
      "subcategory": "Signature Cocktails",
      "featured": true,
      "popular": false,
      "tags": ["mezcal", "spicy", "smoky"]
    },
    {
      "id": "signature-4",
      "name": "Cucumber Elderflower Spritz",
      "description": "Gin, elderflower liqueur, cucumber, and sparkling water - light and floral",
      "price": 13.00,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "cocktails",
      "categoryId": "cocktails",
      "subcategory": "Signature Cocktails",
      "featured": false,
      "popular": true,
      "tags": ["gin", "floral", "refreshing"]
    },
    {
      "id": "classic-1",
      "name": "Negroni",
      "description": "Equal parts gin, Campari, and sweet vermouth with an orange twist",
      "price": 12.00,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "cocktails",
      "categoryId": "cocktails",
      "subcategory": "Classic Cocktails",
      "featured": true,
      "popular": true,
      "tags": ["gin", "bitter", "strong"]
    },
    {
      "id": "classic-2",
      "name": "Manhattan",
      "description": "Rye whiskey, sweet vermouth, and bitters with a cherry garnish",
      "price": 13.00,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "cocktails",
      "categoryId": "cocktails",
      "subcategory": "Classic Cocktails",
      "featured": false,
      "popular": true,
      "tags": ["whiskey", "strong", "classic"]
    },
    {
      "id": "classic-3",
      "name": "Mojito",
      "description": "White rum, fresh lime, mint, sugar, and soda water - a Cuban classic",
      "price": 11.00,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "cocktails",
      "categoryId": "cocktails",
      "subcategory": "Classic Cocktails",
      "featured": true,
      "popular": true,
      "tags": ["rum", "mint", "refreshing"]
    },
    {
      "id": "classic-4",
      "name": "Cosmopolitan",
      "description": "Vodka, cranberry, lime, and orange liqueur - perfectly balanced",
      "price": 12.00,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "cocktails",
      "categoryId": "cocktails",
      "subcategory": "Classic Cocktails",
      "featured": false,
      "popular": false,
      "tags": ["vodka", "cranberry", "fruity"]
    },
    {
      "id": "coffee-1",
      "name": "Espresso",
      "description": "Rich, concentrated coffee served in a small cup",
      "price": 3.50,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "drinks",
      "categoryId": "drinks",
      "subcategory": "Coffee",
      "featured": true,
      "popular": true,
      "tags": ["caffeine", "strong", "hot"]
    },
    {
      "id": "coffee-2",
      "name": "Cappuccino",
      "description": "Espresso with equal parts steamed milk and milk foam",
      "price": 4.50,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "drinks",
      "categoryId": "drinks",
      "subcategory": "Coffee",
      "featured": false,
      "popular": true,
      "tags": ["milk", "creamy", "hot"]
    },
    {
      "id": "coffee-3",
      "name": "Cold Brew",
      "description": "Smooth, less acidic coffee steeped overnight and served cold",
      "price": 5.00,
      "image": "https://images.pexels.com/photos/1470720/pexels-photo-1470720.jpeg",
      "category": "drinks",
      "categoryId": "drinks",
      "subcategory": "Coffee",
      "featured": true,
      "popular": false,
      "tags": ["cold", "smooth", "strong"]
    },
    {
      "id": "coffee-4",
      "name": "Mocha",
      "description": "Espresso with chocolate syrup and steamed milk, topped with whipped cream",
      "price": 5.50,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "drinks",
      "categoryId": "drinks",
      "subcategory": "Coffee",
      "featured": false,
      "popular": true,
      "tags": ["chocolate", "sweet", "hot"]
    },
    {
      "id": "tea-1",
      "name": "English Breakfast",
      "description": "Robust black tea blend - the perfect morning cup",
      "price": 3.00,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "drinks",
      "categoryId": "drinks",
      "subcategory": "Tea",
      "featured": true,
      "popular": true,
      "tags": ["black tea", "caffeine", "hot"]
    },
    {
      "id": "tea-2",
      "name": "Green Tea",
      "description": "Delicate Japanese green tea with a light, grassy flavor",
      "price": 3.50,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "drinks",
      "categoryId": "drinks",
      "subcategory": "Tea",
      "featured": false,
      "popular": true,
      "tags": ["green tea", "light", "antioxidants"]
    },
    {
      "id": "tea-3",
      "name": "Chamomile",
      "description": "Soothing herbal tea with floral notes and calming properties",
      "price": 3.50,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "drinks",
      "categoryId": "drinks",
      "subcategory": "Tea",
      "featured": true,
      "popular": false,
      "tags": ["herbal", "caffeine-free", "relaxing"]
    },
    {
      "id": "tea-4",
      "name": "Chai Latte",
      "description": "Spiced black tea with steamed milk and aromatic spices",
      "price": 4.50,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "drinks",
      "categoryId": "drinks",
      "subcategory": "Tea",
      "featured": false,
      "popular": true,
      "tags": ["spiced", "creamy", "hot"]
    }
  ]
}
</file>

<file path="src/data/menu-items-complete-part2.json">
{
  "items": [
    {
      "id": "hotdog-1",
      "name": "Classic Hot Dog",
      "description": "All-beef hot dog with ketchup, mustard, relish and onions on a soft bun",
      "price": 8.99,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "HOTDOGS",
      "featured": true,
      "popular": true,
      "tags": ["classic", "beef"]
    },
    {
      "id": "hotdog-2",
      "name": "Chicago-Style Dog",
      "description": "All-beef hot dog with mustard, relish, onion, tomato, pickle, sport peppers, and celery salt",
      "price": 10.50,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "HOTDOGS",
      "featured": false,
      "popular": false,
      "tags": ["regional", "loaded"]
    },
    {
      "id": "hotdog-3",
      "name": "Chili Cheese Dog",
      "description": "Hot dog smothered in beef chili, cheddar cheese, and diced onions",
      "price": 11.99,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "HOTDOGS",
      "featured": true,
      "popular": true,
      "tags": ["spicy", "cheese", "hearty"]
    },
    {
      "id": "hotdog-4",
      "name": "Vegan Hot Dog",
      "description": "Plant-based hot dog with avocado, jalapeÃ±os, and vegan aioli",
      "price": 9.99,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "HOTDOGS",
      "featured": false,
      "popular": false,
      "tags": ["vegan", "plant-based"]
    },
    {
      "id": "mexican-1",
      "name": "Street Tacos",
      "description": "Three corn tortillas with your choice of protein, onion, cilantro, and lime",
      "price": 12.99,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "MEXICAN TREAT",
      "featured": true,
      "popular": true,
      "tags": ["authentic", "customizable"]
    },
    {
      "id": "mexican-2",
      "name": "Chicken Quesadilla",
      "description": "Grilled flour tortilla filled with marinated chicken, melted cheese, and pico de gallo",
      "price": 14.50,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "MEXICAN TREAT",
      "featured": false,
      "popular": true,
      "tags": ["cheese", "chicken", "grilled"]
    },
    {
      "id": "mexican-3",
      "name": "Loaded Nachos",
      "description": "Crispy tortilla chips layered with refried beans, queso, guacamole, jalapeÃ±os, and sour cream",
      "price": 13.99,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "MEXICAN TREAT",
      "featured": true,
      "popular": false,
      "tags": ["shareable", "spicy option"]
    },
    {
      "id": "mexican-4",
      "name": "Beef Burrito",
      "description": "Large flour tortilla filled with seasoned ground beef, rice, beans, cheese, and pico de gallo",
      "price": 15.99,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "MEXICAN TREAT",
      "featured": false,
      "popular": true,
      "tags": ["beef", "hearty", "filling"]
    },
    {
      "id": "dessert-1",
      "name": "Chocolate Lava Cake",
      "description": "Warm chocolate cake with a molten center, served with vanilla ice cream",
      "price": 8.99,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "DESSERTS",
      "featured": true,
      "popular": true,
      "tags": ["chocolate", "warm", "ice cream"]
    },
    {
      "id": "dessert-2",
      "name": "New York Cheesecake",
      "description": "Classic creamy cheesecake with graham cracker crust and berry compote",
      "price": 9.50,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "DESSERTS",
      "featured": false,
      "popular": true,
      "tags": ["creamy", "classic", "berries"]
    },
    {
      "id": "dessert-3",
      "name": "Tiramisu",
      "description": "Italian coffee-flavored dessert with layers of mascarpone and ladyfingers",
      "price": 8.99,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "DESSERTS",
      "featured": true,
      "popular": false,
      "tags": ["coffee", "italian", "creamy"]
    },
    {
      "id": "dessert-4",
      "name": "CrÃ¨me BrÃ»lÃ©e",
      "description": "Silky vanilla custard with caramelized sugar crust",
      "price": 9.99,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "DESSERTS",
      "featured": false,
      "popular": false,
      "tags": ["french", "vanilla", "caramel"]
    },
    {
      "id": "daily-1",
      "name": "Monday Burger Special",
      "description": "Get any burger with fries and a drink at a special combo price",
      "price": 19.99,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Daily Deals",
      "featured": true,
      "popular": true,
      "tags": ["special", "combo", "value"]
    },
    {
      "id": "daily-2",
      "name": "Taco Tuesday",
      "description": "All tacos at half price every Tuesday",
      "price": 6.50,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Daily Deals",
      "featured": true,
      "popular": true,
      "tags": ["special", "value", "mexican"]
    },
    {
      "id": "daily-3",
      "name": "Wing Wednesday",
      "description": "All-you-can-eat wings for a fixed price",
      "price": 22.99,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Daily Deals",
      "featured": false,
      "popular": true,
      "tags": ["special", "wings", "unlimited"]
    },
    {
      "id": "daily-4",
      "name": "Pizza & Pasta Thursday",
      "description": "Buy any pizza, get a pasta dish at half price",
      "price": 24.99,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Daily Deals",
      "featured": false,
      "popular": false,
      "tags": ["special", "combo", "italian"]
    },
    {
      "id": "happy-1",
      "name": "Beer Bucket",
      "description": "Five domestic beers for the price of four",
      "price": 20.00,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Happy Hour",
      "featured": true,
      "popular": true,
      "tags": ["drinks", "beer", "value"]
    },
    {
      "id": "happy-2",
      "name": "Cocktail Flight",
      "description": "Sample four of our signature cocktails in smaller portions",
      "price": 18.00,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Happy Hour",
      "featured": false,
      "popular": true,
      "tags": ["drinks", "cocktails", "sampling"]
    },
    {
      "id": "happy-3",
      "name": "Half-Price Appetizers",
      "description": "All appetizers are half price during happy hour 4-6pm",
      "price": 6.50,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Happy Hour",
      "featured": true,
      "popular": false,
      "tags": ["appetizers", "value", "food"]
    },
    {
      "id": "happy-4",
      "name": "Wine Wednesday",
      "description": "All wine bottles at half price on Wednesdays",
      "price": 25.00,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Happy Hour",
      "featured": false,
      "popular": true,
      "tags": ["wine", "value", "drinks"]
    },
    {
      "id": "combo-1",
      "name": "Family Feast",
      "description": "Meal for four with appetizers, main courses, sides, and desserts",
      "price": 89.99,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Combo Offers",
      "featured": true,
      "popular": true,
      "tags": ["family", "combo", "value"]
    },
    {
      "id": "combo-2",
      "name": "Date Night Special",
      "description": "Two entrees, a shared appetizer, and a bottle of wine",
      "price": 65.00,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Combo Offers",
      "featured": true,
      "popular": false,
      "tags": ["couple", "romantic", "combo"]
    },
    {
      "id": "combo-3",
      "name": "Lunch Express",
      "description": "Soup or salad, main course, and a soft drink - ready in 15 minutes",
      "price": 16.99,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Combo Offers",
      "featured": false,
      "popular": true,
      "tags": ["lunch", "quick", "value"]
    },
    {
      "id": "combo-4",
      "name": "Weekend Brunch",
      "description": "Brunch entree with unlimited mimosas or bloody marys",
      "price": 29.99,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Combo Offers",
      "featured": false,
      "popular": true,
      "tags": ["brunch", "weekend", "drinks"]
    },
    {
      "id": "event-1",
      "name": "New Year's Eve Dinner",
      "description": "Five-course meal with champagne toast at midnight",
      "price": 125.00,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Special Events",
      "featured": true,
      "popular": true,
      "tags": ["holiday", "special", "premium"]
    },
    {
      "id": "event-2",
      "name": "Valentine's Day Package",
      "description": "Romantic dinner for two with wine pairing and dessert",
      "price": 150.00,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Special Events",
      "featured": false,
      "popular": true,
      "tags": ["romantic", "special", "holiday"]
    },
    {
      "id": "event-3",
      "name": "Mother's Day Brunch",
      "description": "Special brunch buffet with complimentary mimosa for moms",
      "price": 45.00,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Special Events",
      "featured": true,
      "popular": false,
      "tags": ["holiday", "brunch", "special"]
    },
    {
      "id": "event-4",
      "name": "Private Dining Package",
      "description": "Custom menu for private events and celebrations",
      "price": 85.00,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "promotions",
      "categoryId": "promotions",
      "subcategory": "Special Events",
      "featured": false,
      "popular": true,
      "tags": ["private", "custom", "celebration"]
    }
  ]
}
</file>

<file path="src/data/menu-items-complete-part3.json">
{
  "items": [
    {
      "id": "mocktail-1",
      "name": "Virgin Mojito",
      "description": "Fresh lime, mint, sugar and soda water - a refreshing classic without alcohol",
      "price": 7.99,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Virgin Cocktails",
      "featured": true,
      "popular": true,
      "tags": ["refreshing", "mint", "citrus"]
    },
    {
      "id": "mocktail-2",
      "name": "Strawberry Daiquiri Mocktail",
      "description": "Blended strawberries, lime juice, and ice for a fruity frozen treat",
      "price": 8.50,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Virgin Cocktails",
      "featured": false,
      "popular": true,
      "tags": ["fruity", "frozen", "sweet"]
    },
    {
      "id": "mocktail-3",
      "name": "PiÃ±a Colada Mocktail",
      "description": "Coconut cream, pineapple juice, and ice blended to tropical perfection",
      "price": 9.50,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Virgin Cocktails",
      "featured": true,
      "popular": false,
      "tags": ["tropical", "creamy", "coconut"]
    },
    {
      "id": "mocktail-4",
      "name": "Virgin Sangria",
      "description": "Mixture of fruit juices with fresh fruit pieces and a splash of soda",
      "price": 8.99,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Virgin Cocktails",
      "featured": false,
      "popular": true,
      "tags": ["fruity", "refreshing", "colorful"]
    },
    {
      "id": "smoothie-1",
      "name": "Berry Blast",
      "description": "Mixed berries, banana, yogurt and honey blended with ice",
      "price": 7.50,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Smoothies",
      "featured": true,
      "popular": true,
      "tags": ["berries", "healthy", "sweet"]
    },
    {
      "id": "smoothie-2",
      "name": "Green Machine",
      "description": "Spinach, kale, green apple, banana, and almond milk for an energizing boost",
      "price": 8.99,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Smoothies",
      "featured": false,
      "popular": false,
      "tags": ["healthy", "green", "detox"]
    },
    {
      "id": "smoothie-3",
      "name": "Tropical Paradise",
      "description": "Mango, pineapple, papaya, and coconut water for an island-inspired treat",
      "price": 8.50,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Smoothies",
      "featured": true,
      "popular": true,
      "tags": ["tropical", "fruity", "sweet"]
    },
    {
      "id": "smoothie-4",
      "name": "Protein Powerhouse",
      "description": "Banana, peanut butter, chocolate protein powder, and almond milk for a post-workout boost",
      "price": 9.99,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Smoothies",
      "featured": false,
      "popular": false,
      "tags": ["protein", "filling", "fitness"]
    },
    {
      "id": "shake-1",
      "name": "Classic Chocolate Shake",
      "description": "Creamy vanilla ice cream blended with chocolate syrup, topped with whipped cream",
      "price": 6.99,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Shakes",
      "featured": true,
      "popular": true,
      "tags": ["chocolate", "dessert", "classic"]
    },
    {
      "id": "shake-2",
      "name": "Strawberry Shortcake",
      "description": "Vanilla ice cream blended with fresh strawberries and pieces of pound cake",
      "price": 7.50,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Shakes",
      "featured": false,
      "popular": true,
      "tags": ["strawberry", "dessert", "sweet"]
    },
    {
      "id": "shake-3",
      "name": "Cookies & Cream",
      "description": "Vanilla ice cream blended with chocolate cookie pieces and topped with cookie crumbs",
      "price": 7.99,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Shakes",
      "featured": true,
      "popular": false,
      "tags": ["cookies", "dessert", "sweet"]
    },
    {
      "id": "shake-4",
      "name": "Salted Caramel",
      "description": "Caramel ice cream blended with salted caramel sauce, topped with whipped cream and pretzel pieces",
      "price": 8.50,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Shakes",
      "featured": false,
      "popular": true,
      "tags": ["caramel", "sweet-salty", "dessert"]
    },
    {
      "id": "sparkling-1",
      "name": "Italian Soda",
      "description": "Club soda with your choice of flavored syrup and a splash of cream",
      "price": 5.99,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Sparkling Drinks",
      "featured": true,
      "popular": true,
      "tags": ["customizable", "sweet", "refreshing"]
    },
    {
      "id": "sparkling-2",
      "name": "Cucumber Mint Spritzer",
      "description": "Fresh cucumber, mint, lime, and sparkling water for a cool, refreshing drink",
      "price": 6.50,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Sparkling Drinks",
      "featured": false,
      "popular": false,
      "tags": ["refreshing", "herbal", "light"]
    },
    {
      "id": "sparkling-3",
      "name": "Berry Sparkler",
      "description": "Mixed berry purÃ©e topped with sparkling water and fresh berries",
      "price": 7.50,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Sparkling Drinks",
      "featured": true,
      "popular": false,
      "tags": ["berries", "fruity", "colorful"]
    },
    {
      "id": "sparkling-4",
      "name": "Ginger Fizz",
      "description": "Fresh ginger syrup, lemon juice, and sparkling water with a hint of mint",
      "price": 6.99,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "mocktails",
      "categoryId": "mocktails",
      "subcategory": "Sparkling Drinks",
      "featured": false,
      "popular": true,
      "tags": ["spicy", "refreshing", "digestive"]
    },
    {
      "id": "draft-1",
      "name": "House Lager",
      "description": "Our signature crisp, clean lager with subtle malt flavor",
      "price": 7.00,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "beers",
      "categoryId": "beers",
      "subcategory": "Draft Beers",
      "featured": true,
      "popular": true,
      "tags": ["lager", "refreshing", "house brew"]
    },
    {
      "id": "draft-2",
      "name": "IPA",
      "description": "Hoppy India Pale Ale with citrus and pine notes",
      "price": 8.00,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "beers",
      "categoryId": "beers",
      "subcategory": "Draft Beers",
      "featured": false,
      "popular": true,
      "tags": ["hoppy", "bitter", "aromatic"]
    },
    {
      "id": "draft-3",
      "name": "Wheat Beer",
      "description": "Smooth, light-bodied wheat beer with hints of banana and clove",
      "price": 7.50,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "beers",
      "categoryId": "beers",
      "subcategory": "Draft Beers",
      "featured": true,
      "popular": false,
      "tags": ["wheat", "light", "refreshing"]
    },
    {
      "id": "draft-4",
      "name": "Seasonal Brew",
      "description": "Rotating tap featuring our brewmaster's seasonal creation",
      "price": 8.50,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "beers",
      "categoryId": "beers",
      "subcategory": "Draft Beers",
      "featured": false,
      "popular": true,
      "tags": ["seasonal", "limited", "special"]
    }
  ]
}
</file>

<file path="src/data/menu-items-complete.json">
{
  "items": [
    {
      "id": "noodles-1",
      "name": "Pad Thai",
      "description": "Classic Thai stir-fried rice noodles with egg, tofu, bean sprouts and crushed peanuts",
      "price": 16.99,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "NOODLES",
      "featured": true,
      "popular": true,
      "tags": ["thai", "spicy", "vegetarian option"],
      "modifiers": [
        {
          "name": "Protein",
          "type": "single-select",
          "required": true,
          "options": [
            { "name": "Tofu", "price": 0 },
            { "name": "Chicken", "price": 2.00 },
            { "name": "Shrimp", "price": 4.00 },
            { "name": "Beef", "price": 3.00 }
          ]
        }
      ]
    },
    {
      "id": "noodles-2",
      "name": "Ramen Bowl",
      "description": "Rich miso broth with fresh ramen noodles, soft-boiled egg, char siu pork and green onions",
      "price": 18.99,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "NOODLES",
      "featured": false,
      "popular": true,
      "tags": ["japanese", "soup", "comfort food"],
      "modifiers": [
        {
          "name": "Broth",
          "type": "single-select",
          "required": true,
          "options": [
            { "name": "Miso", "price": 0 },
            { "name": "Tonkotsu", "price": 0 },
            { "name": "Shoyu", "price": 0 }
          ]
        }
      ]
    },
    {
      "id": "noodles-3",
      "name": "Udon Stir Fry",
      "description": "Thick udon noodles stir-fried with seasonal vegetables and choice of protein in a savory sauce",
      "price": 17.50,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "NOODLES",
      "featured": false,
      "popular": false,
      "tags": ["japanese", "stir fry"]
    },
    {
      "id": "noodles-4",
      "name": "Pho Bo",
      "description": "Vietnamese beef noodle soup with rice noodles, thinly sliced beef, bean sprouts and fresh herbs",
      "price": 16.50,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "NOODLES",
      "featured": true,
      "popular": false,
      "tags": ["vietnamese", "soup", "beef"]
    },
    {
      "id": "sides-1",
      "name": "Truffle Fries",
      "description": "Crispy french fries tossed in truffle oil and parmesan, with garlic aioli",
      "price": 8.99,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "FRIED SIDES",
      "featured": true,
      "popular": true,
      "tags": ["vegetarian", "truffle", "shareable"]
    },
    {
      "id": "sides-2",
      "name": "Calamari Fritti",
      "description": "Lightly battered and fried squid rings served with lemon aioli and marinara sauce",
      "price": 14.50,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "FRIED SIDES",
      "featured": false,
      "popular": true,
      "tags": ["seafood", "appetizer"]
    },
    {
      "id": "sides-3",
      "name": "Mozzarella Sticks",
      "description": "Breaded and fried mozzarella cheese sticks with marinara dipping sauce",
      "price": 9.99,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "FRIED SIDES",
      "featured": false,
      "popular": false,
      "tags": ["vegetarian", "cheese", "appetizer"]
    },
    {
      "id": "sides-4",
      "name": "Buffalo Wings",
      "description": "Crispy chicken wings tossed in spicy buffalo sauce with blue cheese dip and celery sticks",
      "price": 13.99,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "FRIED SIDES",
      "featured": true,
      "popular": true,
      "tags": ["spicy", "chicken", "shareable"]
    },
    {
      "id": "salad-1",
      "name": "Caesar Salad",
      "description": "Crisp romaine lettuce, garlic croutons, parmesan and creamy caesar dressing",
      "price": 12.50,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SALADS",
      "featured": true,
      "popular": true,
      "tags": ["classic", "vegetarian option"]
    },
    {
      "id": "salad-2",
      "name": "Greek Salad",
      "description": "Fresh cucumbers, tomatoes, red onion, kalamata olives, and feta cheese with herb vinaigrette",
      "price": 13.99,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SALADS",
      "featured": false,
      "popular": false,
      "tags": ["vegetarian", "mediterranean"]
    },
    {
      "id": "salad-3",
      "name": "Quinoa Power Bowl",
      "description": "Protein-rich quinoa with roasted seasonal vegetables, avocado and lemon tahini dressing",
      "price": 15.50,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SALADS",
      "featured": true,
      "popular": false,
      "tags": ["vegan", "gluten-free", "healthy"]
    },
    {
      "id": "salad-4",
      "name": "Cobb Salad",
      "description": "Mixed greens with grilled chicken, bacon, hard-boiled egg, avocado, tomato and blue cheese",
      "price": 16.99,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SALADS",
      "featured": false,
      "popular": true,
      "tags": ["protein", "classic", "hearty"]
    },
    {
      "id": "sushi-platter-1",
      "name": "Sashimi Deluxe",
      "description": "Chef's selection of 15 pieces of premium fish sashimi with wasabi and pickled ginger",
      "price": 28.99,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI PLATTERS",
      "featured": true,
      "popular": true,
      "tags": ["raw", "seafood", "japanese"]
    },
    {
      "id": "sushi-platter-2",
      "name": "Nigiri Assortment",
      "description": "12 pieces of hand-pressed sushi rice topped with fresh fish and seafood",
      "price": 24.50,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI PLATTERS",
      "featured": false,
      "popular": true,
      "tags": ["japanese", "traditional"]
    },
    {
      "id": "sushi-platter-3",
      "name": "Maki Combo",
      "description": "Assortment of 24 pieces of maki rolls including California, Spicy Tuna, and Philadelphia rolls",
      "price": 32.99,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI PLATTERS",
      "featured": true,
      "popular": false,
      "tags": ["shareable", "japanese", "variety"]
    },
    {
      "id": "sushi-platter-4",
      "name": "Chef's Special Platter",
      "description": "Premium selection of nigiri, sashimi and specialty rolls curated by our head sushi chef",
      "price": 45.00,
      "image": "/lovable-uploads/3a7894a7-444c-4b24-88cf-c09a08fe27a9.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI PLATTERS",
      "featured": true,
      "popular": true,
      "tags": ["premium", "japanese", "special"]
    },
    {
      "id": "roll-1",
      "name": "California Roll",
      "description": "Crab, avocado and cucumber wrapped in nori and rice with sesame seeds",
      "price": 8.99,
      "image": "/lovable-uploads/e66c6a9e-63eb-4bd4-a5d0-61c8a2bce69b.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI ROLLS",
      "featured": false,
      "popular": true,
      "tags": ["classic", "beginner friendly"]
    },
    {
      "id": "roll-2",
      "name": "Spicy Tuna Roll",
      "description": "Fresh tuna mixed with spicy mayo and cucumber wrapped in nori and rice",
      "price": 10.50,
      "image": "/lovable-uploads/9ad0e17d-9c30-426a-b36c-11c3e8e5e0a5.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI ROLLS",
      "featured": true,
      "popular": true,
      "tags": ["spicy", "popular"]
    },
    {
      "id": "roll-3",
      "name": "Dragon Roll",
      "description": "Eel and cucumber inside, topped with avocado and eel sauce",
      "price": 14.99,
      "image": "/lovable-uploads/41f72dea-25ec-4be3-98ec-8a24aba5b54d.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI ROLLS",
      "featured": true,
      "popular": false,
      "tags": ["specialty", "cooked option"]
    },
    {
      "id": "roll-4",
      "name": "Rainbow Roll",
      "description": "California roll topped with assorted slices of fresh fish and avocado",
      "price": 15.50,
      "image": "/lovable-uploads/6f5e2fa0-aae5-4b1d-b109-d17950f3202f.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI ROLLS",
      "featured": false,
      "popular": true,
      "tags": ["colorful", "variety"]
    },
    {
      "id": "burger-1",
      "name": "Classic Cheeseburger",
      "description": "Juicy beef patty with cheddar cheese, lettuce, tomato, and special sauce on a brioche bun",
      "price": 14.99,
      "image": "/lovable-uploads/16dcc478-46ec-4824-864c-814524dc52ae.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SLIDERS, BURGERS & SANDWICHES",
      "featured": true,
      "popular": true,
      "tags": ["beef", "classic"]
    },
    {
      "id": "burger-2",
      "name": "Mushroom Swiss Burger",
      "description": "Beef patty topped with sautÃ©ed mushrooms, Swiss cheese and truffle aioli",
      "price": 16.50,
      "image": "/lovable-uploads/4286559a-2d42-42fc-9bca-5fba323d3cb7.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SLIDERS, BURGERS & SANDWICHES",
      "featured": false,
      "popular": false,
      "tags": ["beef", "mushroom", "truffle"]
    },
    {
      "id": "burger-3",
      "name": "Veggie Burger",
      "description": "House-made plant-based patty with avocado, sprouts, and vegan chipotle mayo",
      "price": 15.99,
      "image": "/lovable-uploads/38df3812-eaa8-4ddc-986b-1da63f216fef.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SLIDERS, BURGERS & SANDWICHES",
      "featured": true,
      "popular": false,
      "tags": ["vegetarian", "plant-based", "healthy"]
    },
    {
      "id": "burger-4",
      "name": "BBQ Bacon Burger",
      "description": "Angus beef patty with crispy bacon, cheddar, onion rings, and smoky BBQ sauce",
      "price": 17.99,
      "image": "/lovable-uploads/9f429efa-68ea-4053-829c-5c6add92b336.png",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SLIDERS, BURGERS & SANDWICHES",
      "featured": false,
      "popular": true,
      "tags": ["beef", "bacon", "bbq", "smoky"]
    }
  ]
}
</file>

<file path="src/data/menu-items.json">
{
  "items": [
    {
      "id": "noodles-1",
      "name": "Pad Thai",
      "description": "Classic Thai stir-fried rice noodles with egg, tofu, bean sprouts and crushed peanuts",
      "price": 16.99,
      "image": "https://images.pexels.com/photos/1639562/pexels-photo-1639562.jpeg",
      "category": "food",
      "categoryId": "food",
      "subcategory": "NOODLES",
      "featured": true,
      "popular": true,
      "tags": ["thai", "spicy", "vegetarian option"],
      "modifiers": [
        {
          "name": "Protein",
          "type": "single-select",
          "required": true,
          "options": [
            { "name": "Tofu", "price": 0 },
            { "name": "Chicken", "price": 2.00 },
            { "name": "Shrimp", "price": 4.00 },
            { "name": "Beef", "price": 3.00 }
          ]
        }
      ]
    },
    {
      "id": "2",
      "name": "Classic Cheeseburger",
      "description": "Juicy beef patty with cheddar cheese, lettuce, tomato, and special sauce on a toasted bun.",
      "price": 12.99,
      "image": "/placeholder.svg",
      "imageSearchTerm": "classic cheeseburger beef",
      "category": "food",
      "restaurantId": "rest1",
      "featured": true,
      "popular": true,
      "nutritionInfo": { "calories": 650 },
      "preparationTime": "10-12 min",
      "tags": ["beef", "cheese"],
      "modifiers": [
        {
          "name": "Cooking Preference",
          "type": "single-select",
          "required": true,
          "options": [
            { "name": "Rare", "price": 0 },
            { "name": "Medium Rare", "price": 0 },
            { "name": "Medium", "price": 0 },
            { "name": "Medium Well", "price": 0 },
            { "name": "Well Done", "price": 0 }
          ]
        },
        {
          "name": "Add-ons",
          "type": "multi-select",
          "required": false,
          "options": [
            { "name": "Bacon", "price": 2.00 },
            { "name": "Extra Cheese", "price": 1.50 },
            { "name": "Avocado", "price": 1.75 },
            { "name": "Fried Egg", "price": 1.50 }
          ]
        }
      ]
    },
    {
      "id": "3",
      "name": "Margherita Pizza",
      "description": "Classic pizza with tomato sauce, fresh mozzarella, basil leaves, and a drizzle of olive oil.",
      "price": 14.99,
      "image": "/placeholder.svg",
      "imageSearchTerm": "margherita pizza italian",
      "category": "food",
      "restaurantId": "rest1",
      "featured": false,
      "popular": true,
      "nutritionInfo": { "calories": 550 },
      "preparationTime": "15-20 min",
      "tags": ["vegetarian", "classic"],
      "modifiers": [
        {
          "name": "Size",
          "type": "single-select",
          "required": true,
          "options": [
            { "name": "Medium (12\")", "price": 0 },
            { "name": "Large (14\")", "price": 3.00 },
            { "name": "Extra Large (16\")", "price": 5.00 }
          ]
        },
        {
          "name": "Extra Toppings",
          "type": "multi-select",
          "required": false,
          "options": [
            { "name": "Pepperoni", "price": 2.50 },
            { "name": "Mushrooms", "price": 1.50 },
            { "name": "Onions", "price": 1.00 },
            { "name": "Olives", "price": 1.50 },
            { "name": "Extra Cheese", "price": 2.00 }
          ]
        },
        {
          "name": "Crust Options",
          "type": "single-select",
          "required": false,
          "options": [
             { "name": "Thin Crust", "price": 0 },
             { "name": "Stuffed Crust", "price": 2.50 }
          ]
        }
      ]
    },
    {
      "id": "4",
      "name": "Truffle French Fries",
      "description": "Crispy fries tossed with truffle oil, parmesan cheese, and fresh parsley.",
      "price": 8.99,
      "image": "/placeholder.svg",
      "imageSearchTerm": "truffle french fries gourmet",
      "category": "food",
      "restaurantId": "rest1",
      "featured": true,
      "popular": false,
      "nutritionInfo": { "calories": 420 },
      "preparationTime": "8-10 min",
      "tags": ["vegetarian", "truffle"]
    },
    {
      "id": "5",
      "name": "Spicy Chicken Wings",
      "description": "Crispy fried chicken wings tossed in a tangy and spicy buffalo sauce, served with blue cheese dip.",
      "price": 13.99,
      "image": "/placeholder.svg",
      "imageSearchTerm": "spicy chicken wings buffalo",
      "category": "food",
      "restaurantId": "rest1",
      "featured": false,
      "popular": true,
      "nutritionInfo": { "calories": 480 },
      "preparationTime": "12-15 min",
      "tags": ["spicy", "chicken"]
    },
    {
      "id": "6",
      "name": "Spaghetti Carbonara",
      "description": "Classic Italian pasta with a creamy egg sauce, crispy pancetta, pecorino cheese, and black pepper.",
      "price": 16.99,
      "image": "/placeholder.svg",
      "imageSearchTerm": "spaghetti carbonara italian pasta",
      "category": "food",
      "restaurantId": "rest1",
      "featured": true,
      "popular": true,
      "nutritionInfo": { "calories": 620 },
      "preparationTime": "12-15 min",
      "tags": ["italian", "creamy"]
    },
    {
      "id": "7",
      "name": "Chocolate Lava Cake",
      "description": "Warm, rich chocolate cake with a gooey molten chocolate center, served with vanilla ice cream.",
      "price": 9.99,
      "image": "/placeholder.svg",
      "imageSearchTerm": "chocolate lava cake dessert",
      "category": "food",
      "restaurantId": "rest1",
      "featured": true,
      "popular": false,
      "nutritionInfo": { "calories": 380 },
      "preparationTime": "12-15 min",
      "tags": ["dessert", "chocolate"]
    },
    {
      "id": "11",
      "name": "Pad Thai Noodles",
      "description": "Stir-fried rice noodles with shrimp, tofu, egg, bean sprouts, peanuts, and lime.",
      "price": 15.50,
      "image": "/placeholder.svg",
      "imageSearchTerm": "pad thai noodles thai food",
      "category": "food",
      "restaurantId": "rest1"
    },
    {
      "id": "12",
      "name": "Caesar Salad",
      "description": "Crisp romaine lettuce, garlic croutons, shaved parmesan cheese, and creamy Caesar dressing.",
      "price": 11.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "caesar salad classic",
      "category": "food",
      "restaurantId": "rest1"
    },
    {
      "id": "18",
      "name": "California Roll",
      "description": "Sushi roll with imitation crab, avocado, cucumber, and sesame seeds.",
      "price": 9.50,
      "image": "/placeholder.svg",
      "imageSearchTerm": "california roll sushi",
      "category": "food",
      "restaurantId": "rest1"
    },
    {
      "id": "8",
      "name": "Fresh Berry Smoothie",
      "description": "A blend of fresh strawberries, blueberries, raspberries, yogurt, and a touch of honey.",
      "price": 7.99,
      "image": "/placeholder.svg",
      "imageSearchTerm": "fresh berry smoothie healthy",
      "category": "drinks",
      "restaurantId": "rest1",
      "featured": false,
      "popular": true,
      "nutritionInfo": { "calories": 180 },
      "preparationTime": "5-7 min",
      "tags": ["healthy", "refreshing"]
    },
    {
      "id": "15",
      "name": "Espresso",
      "description": "A strong, concentrated shot of freshly brewed coffee.",
      "price": 3.50,
      "image": "/placeholder.svg",
      "imageSearchTerm": "espresso coffee shot",
      "category": "drinks",
      "restaurantId": "rest1"
    },
    {
      "id": "19",
      "name": "Latte",
      "description": "Smooth espresso combined with steamed milk and a light layer of foam.",
      "price": 4.50,
      "image": "/placeholder.svg",
      "imageSearchTerm": "latte coffee milk",
      "category": "drinks",
      "restaurantId": "rest1"
    },
    {
      "id": "20",
      "name": "Green Tea",
      "description": "Hot brewed Japanese sencha green tea.",
      "price": 3.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "green tea hot drink",
      "category": "drinks",
      "restaurantId": "rest1"
    },
    {
      "id": "21",
      "name": "Orange Juice",
      "description": "100% pure, freshly squeezed orange juice.",
      "price": 5.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "orange juice fresh",
      "category": "drinks",
      "restaurantId": "rest1"
    },
    {
      "id": "9",
      "name": "Draft Lager",
      "description": "A crisp and refreshing draft lager beer.",
      "price": 6.50,
      "image": "/placeholder.svg",
      "imageSearchTerm": "draft lager beer",
      "category": "beers",
      "restaurantId": "rest1"
    },
    {
      "id": "10",
      "name": "Bottled IPA",
      "description": "A hoppy and aromatic India Pale Ale in a bottle.",
      "price": 7.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "bottled IPA beer",
      "category": "beers",
      "restaurantId": "rest1"
    },
    {
      "id": "22",
      "name": "Stout",
      "description": "A dark, rich, and creamy stout beer with notes of coffee and chocolate.",
      "price": 7.50,
      "image": "/placeholder.svg",
      "imageSearchTerm": "stout beer dark",
      "category": "beers",
      "restaurantId": "rest1"
    },
    {
      "id": "23",
      "name": "Pilsner",
      "description": "A light, crisp, and refreshing pilsner beer.",
      "price": 6.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "pilsner beer light",
      "category": "beers",
      "restaurantId": "rest1"
    },
    {
      "id": "24",
      "name": "Wheat Beer",
      "description": "A cloudy German-style wheat beer with notes of banana and clove.",
      "price": 7.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "wheat beer hefeweizen",
      "category": "beers",
      "restaurantId": "rest1"
    },
    {
      "id": "13",
      "name": "Large Popcorn",
      "description": "A large bucket of warm, buttery cinema-style popcorn.",
      "price": 8.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "large popcorn cinema snack",
      "category": "cinema_snacks",
      "restaurantId": "rest1"
    },
    {
      "id": "25",
      "name": "Nachos with Cheese",
      "description": "Crispy tortilla chips served with warm, gooey cheese sauce.",
      "price": 9.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "nachos cheese cinema",
      "category": "cinema_snacks",
      "restaurantId": "rest1"
    },
    {
      "id": "26",
      "name": "Candy Bar",
      "description": "Choose from a selection of popular chocolate candy bars.",
      "price": 3.50,
      "image": "/placeholder.svg",
      "imageSearchTerm": "candy bar chocolate cinema",
      "category": "cinema_snacks",
      "restaurantId": "rest1"
    },
    {
      "id": "27",
      "name": "Pretzel Bites",
      "description": "Warm, soft pretzel bites served with a side of cheese dip.",
      "price": 6.50,
      "image": "/placeholder.svg",
      "imageSearchTerm": "pretzel bites snack",
      "category": "cinema_snacks",
      "restaurantId": "rest1"
    },
    {
      "id": "28",
      "name": "Soda Cup",
      "description": "A large cup for self-serve fountain soda.",
      "price": 4.50,
      "image": "/placeholder.svg",
      "imageSearchTerm": "soda cup fountain drink",
      "category": "cinema_snacks",
      "restaurantId": "rest1"
    },
    {
      "id": "14",
      "name": "Virgin Mojito",
      "description": "A refreshing non-alcoholic mix of mint, lime, sugar, and soda water.",
      "price": 8.50,
      "image": "/placeholder.svg",
      "imageSearchTerm": "virgin mojito mocktail",
      "category": "mocktails",
      "restaurantId": "rest1"
    },
    {
      "id": "29",
      "name": "Shirley Temple",
      "description": "A classic mocktail made with ginger ale, grenadine, and a cherry.",
      "price": 7.50,
      "image": "/placeholder.svg",
      "imageSearchTerm": "shirley temple mocktail",
      "category": "mocktails",
      "restaurantId": "rest1"
    },
    {
      "id": "30",
      "name": "Virgin Strawberry Daiquiri",
      "description": "A sweet and tangy blended mocktail with strawberries and lime.",
      "price": 9.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "virgin strawberry daiquiri mocktail",
      "category": "mocktails",
      "restaurantId": "rest1"
    },
    {
      "id": "31",
      "name": "Virgin Pina Colada",
      "description": "A creamy, tropical blend of pineapple juice and coconut cream.",
      "price": 9.50,
      "image": "/placeholder.svg",
      "imageSearchTerm": "virgin pina colada mocktail",
      "category": "mocktails",
      "restaurantId": "rest1"
    },
    {
      "id": "32",
      "name": "Fruit Punch",
      "description": "A refreshing mix of various fruit juices.",
      "price": 7.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "fruit punch mocktail",
      "category": "mocktails",
      "restaurantId": "rest1"
    },
    {
      "id": "16",
      "name": "Old Fashioned",
      "description": "A classic cocktail made with whiskey, sugar, bitters, and an orange peel.",
      "price": 14.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "old fashioned cocktail whiskey",
      "category": "cocktails",
      "restaurantId": "rest1"
    },
    {
      "id": "33",
      "name": "Margarita",
      "description": "A popular cocktail with tequila, lime juice, and triple sec, served with a salt rim.",
      "price": 12.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "margarita cocktail tequila",
      "category": "cocktails",
      "restaurantId": "rest1"
    },
    {
      "id": "34",
      "name": "Mojito",
      "description": "A refreshing Cuban cocktail with white rum, sugar, lime juice, soda water, and mint.",
      "price": 13.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "mojito cocktail rum",
      "category": "cocktails",
      "restaurantId": "rest1"
    },
    {
      "id": "35",
      "name": "Negroni",
      "description": "An iconic Italian cocktail made with gin, Campari, and sweet vermouth.",
      "price": 15.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "negroni cocktail gin",
      "category": "cocktails",
      "restaurantId": "rest1"
    },
    {
      "id": "36",
      "name": "Cosmopolitan",
      "description": "A stylish cocktail with vodka, triple sec, cranberry juice, and lime juice.",
      "price": 13.50,
      "image": "/placeholder.svg",
      "imageSearchTerm": "cosmopolitan cocktail vodka",
      "category": "cocktails",
      "restaurantId": "rest1"
    },
    {
      "id": "17",
      "name": "Pinot Noir (Glass)",
      "description": "A glass of smooth, light-bodied red wine with notes of cherry and raspberry.",
      "price": 12.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "pinot noir red wine glass",
      "category": "wine",
      "restaurantId": "rest1"
    },
    {
      "id": "37",
      "name": "Sauvignon Blanc (Glass)",
      "description": "A glass of crisp, dry white wine with citrus and herbal notes.",
      "price": 11.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "sauvignon blanc white wine glass",
      "category": "wine",
      "restaurantId": "rest1"
    },
    {
      "id": "38",
      "name": "Cabernet Sauvignon (Glass)",
      "description": "A glass of full-bodied red wine with dark fruit flavors and hints of oak.",
      "price": 13.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "cabernet sauvignon red wine glass",
      "category": "wine",
      "restaurantId": "rest1"
    },
    {
      "id": "39",
      "name": "RosÃ© (Bottle)",
      "description": "A bottle of dry rosÃ© wine, perfect for sharing.",
      "price": 40.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "rose wine bottle",
      "category": "wine",
      "restaurantId": "rest1"
    },
    {
      "id": "40",
      "name": "Prosecco (Bottle)",
      "description": "A bottle of Italian sparkling wine with notes of green apple and pear.",
      "price": 45.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "prosecco sparkling wine bottle",
      "category": "wine",
      "restaurantId": "rest1"
    },
    {
      "id": "41",
      "name": "Chardonnay (Bottle)",
      "description": "A bottle of medium-bodied white wine, often with notes of apple, citrus, and oak.",
      "price": 42.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "chardonnay white wine bottle",
      "category": "wine",
      "restaurantId": "rest1"
    },
    {
      "id": "42",
      "name": "Merlot (Bottle)",
      "description": "A bottle of smooth, medium-bodied red wine with plum and black cherry flavors.",
      "price": 38.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "merlot red wine bottle",
      "category": "wine",
      "restaurantId": "rest1"
    },
    {
      "id": "43",
      "name": "Malbec (Bottle)",
      "description": "A bottle of full-bodied Argentinian red wine known for its dark fruit and spice notes.",
      "price": 44.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "malbec red wine bottle argentina",
      "category": "wine",
      "restaurantId": "rest1"
    },
    {
      "id": "44",
      "name": "Pinot Grigio (Glass)",
      "description": "A glass of light, crisp white wine with pear and citrus notes.",
      "price": 10.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "pinot grigio white wine glass",
      "category": "wine",
      "restaurantId": "rest1"
    },
    {
      "id": "45",
      "name": "Champagne (Bottle)",
      "description": "A bottle of celebratory French sparkling wine.",
      "price": 75.00,
      "image": "/placeholder.svg",
      "imageSearchTerm": "champagne sparkling wine bottle france",
      "category": "wine",
      "restaurantId": "rest1"
    }
  ]
}
</file>

<file path="src/data/new-menu-items-part2.json">
{
  "items": [
    {
      "id": "burger-1",
      "name": "Classic Cheeseburger",
      "description": "Juicy beef patty with cheddar cheese, lettuce, tomato, and special sauce on a brioche bun",
      "price": 14.99,
      "image": "https://images.pexels.com/photos/1639557/pexels-photo-1639557.jpeg",
      "imageSearchTerm": "cheeseburger",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SLIDERS, BURGERS & SANDWICHES",
      "featured": true,
      "popular": true,
      "tags": ["beef", "classic"]
    },
    {
      "id": "burger-2",
      "name": "Mushroom Swiss Burger",
      "description": "Beef patty topped with sautÃ©ed mushrooms, Swiss cheese and truffle aioli",
      "price": 16.50,
      "image": "https://images.pexels.com/photos/1639562/pexels-photo-1639562.jpeg",
      "imageSearchTerm": "mushroom swiss burger",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SLIDERS, BURGERS & SANDWICHES",
      "featured": false,
      "popular": false,
      "tags": ["beef", "mushroom", "truffle"]
    },
    {
      "id": "burger-3",
      "name": "Veggie Burger",
      "description": "House-made plant-based patty with avocado, sprouts, and vegan chipotle mayo",
      "price": 15.99,
      "image": "https://images.pexels.com/photos/1640774/pexels-photo-1640774.jpeg",
      "imageSearchTerm": "veggie burger",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SLIDERS, BURGERS & SANDWICHES",
      "featured": true,
      "popular": false,
      "tags": ["vegetarian", "plant-based", "healthy"]
    },
    {
      "id": "burger-4",
      "name": "BBQ Bacon Burger",
      "description": "Angus beef patty with crispy bacon, cheddar, onion rings, and smoky BBQ sauce",
      "price": 17.99,
      "image": "https://source.unsplash.com/random/300x200/?bbq-bacon-burger",
      "imageSearchTerm": "bbq bacon burger",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SLIDERS, BURGERS & SANDWICHES",
      "featured": false,
      "popular": true,
      "tags": ["beef", "bacon", "bbq", "smoky"]
    },
    {
      "id": "sandwich-1",
      "name": "Club Sandwich",
      "description": "Triple-decker sandwich with turkey, bacon, lettuce, tomato, and mayo on toasted bread",
      "price": 13.99,
      "image": "https://source.unsplash.com/random/300x200/?club-sandwich",
      "imageSearchTerm": "club sandwich",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SLIDERS, BURGERS & SANDWICHES",
      "featured": false,
      "popular": true,
      "tags": ["classic", "turkey", "bacon"]
    },
    {
      "id": "hotdog-1",
      "name": "Classic Hot Dog",
      "description": "All-beef hot dog with ketchup, mustard, relish and onions on a soft bun",
      "price": 8.99,
      "image": "https://source.unsplash.com/random/300x200/?hot-dog",
      "imageSearchTerm": "classic hot dog",
      "category": "food",
      "categoryId": "food",
      "subcategory": "HOTDOGS",
      "featured": true,
      "popular": true,
      "tags": ["classic", "beef"]
    },
    {
      "id": "hotdog-2",
      "name": "Chicago-Style Dog",
      "description": "All-beef hot dog with mustard, relish, onion, tomato, pickle, sport peppers, and celery salt",
      "price": 10.50,
      "image": "https://source.unsplash.com/random/300x200/?chicago-hotdog",
      "imageSearchTerm": "chicago style hot dog",
      "category": "food",
      "categoryId": "food",
      "subcategory": "HOTDOGS",
      "featured": false,
      "popular": false,
      "tags": ["regional", "loaded"]
    },
    {
      "id": "hotdog-3",
      "name": "Chili Cheese Dog",
      "description": "Hot dog smothered in beef chili, cheddar cheese, and diced onions",
      "price": 11.99,
      "image": "https://source.unsplash.com/random/300x200/?chili-cheese-dog",
      "imageSearchTerm": "chili cheese hot dog",
      "category": "food",
      "categoryId": "food",
      "subcategory": "HOTDOGS",
      "featured": true,
      "popular": true,
      "tags": ["spicy", "cheese", "hearty"]
    },
    {
      "id": "hotdog-4",
      "name": "Vegan Hot Dog",
      "description": "Plant-based hot dog with avocado, jalapeÃ±os, and vegan aioli",
      "price": 9.99,
      "image": "https://source.unsplash.com/random/300x200/?vegan-hotdog",
      "imageSearchTerm": "vegan hot dog",
      "category": "food",
      "categoryId": "food",
      "subcategory": "HOTDOGS",
      "featured": false,
      "popular": false,
      "tags": ["vegan", "plant-based"]
    },
    {
      "id": "mexican-1",
      "name": "Street Tacos",
      "description": "Three corn tortillas with your choice of protein, onion, cilantro, and lime",
      "price": 12.99,
      "image": "https://source.unsplash.com/random/300x200/?street-tacos",
      "imageSearchTerm": "street tacos",
      "category": "food",
      "categoryId": "food",
      "subcategory": "MEXICAN TREAT",
      "featured": true,
      "popular": true,
      "tags": ["authentic", "customizable"]
    },
    {
      "id": "mexican-2",
      "name": "Chicken Quesadilla",
      "description": "Grilled flour tortilla filled with marinated chicken, melted cheese, and pico de gallo",
      "price": 14.50,
      "image": "https://source.unsplash.com/random/300x200/?quesadilla",
      "imageSearchTerm": "chicken quesadilla",
      "category": "food",
      "categoryId": "food",
      "subcategory": "MEXICAN TREAT",
      "featured": false,
      "popular": true,
      "tags": ["cheese", "chicken", "grilled"]
    },
    {
      "id": "mexican-3",
      "name": "Loaded Nachos",
      "description": "Crispy tortilla chips layered with refried beans, queso, guacamole, jalapeÃ±os, and sour cream",
      "price": 13.99,
      "image": "https://source.unsplash.com/random/300x200/?loaded-nachos",
      "imageSearchTerm": "loaded nachos",
      "category": "food",
      "categoryId": "food",
      "subcategory": "MEXICAN TREAT",
      "featured": true,
      "popular": false,
      "tags": ["shareable", "spicy option"]
    },
    {
      "id": "mexican-4",
      "name": "Beef Burrito",
      "description": "Large flour tortilla filled with seasoned ground beef, rice, beans, cheese, and pico de gallo",
      "price": 15.99,
      "image": "https://source.unsplash.com/random/300x200/?beef-burrito",
      "imageSearchTerm": "beef burrito",
      "category": "food",
      "categoryId": "food",
      "subcategory": "MEXICAN TREAT",
      "featured": false,
      "popular": true,
      "tags": ["beef", "hearty", "filling"]
    },
    {
      "id": "dessert-1",
      "name": "Chocolate Lava Cake",
      "description": "Warm chocolate cake with a molten center, served with vanilla ice cream",
      "price": 8.99,
      "image": "https://source.unsplash.com/random/300x200/?chocolate-lava-cake",
      "imageSearchTerm": "chocolate lava cake",
      "category": "food",
      "categoryId": "food",
      "subcategory": "DESSERTS",
      "featured": true,
      "popular": true,
      "tags": ["chocolate", "warm", "ice cream"]
    },
    {
      "id": "dessert-2",
      "name": "New York Cheesecake",
      "description": "Classic creamy cheesecake with graham cracker crust and berry compote",
      "price": 9.50,
      "image": "https://source.unsplash.com/random/300x200/?cheesecake",
      "imageSearchTerm": "new york cheesecake",
      "category": "food",
      "categoryId": "food",
      "subcategory": "DESSERTS",
      "featured": false,
      "popular": true,
      "tags": ["creamy", "classic", "berries"]
    },
    {
      "id": "dessert-3",
      "name": "Tiramisu",
      "description": "Italian coffee-flavored dessert with layers of mascarpone and ladyfingers",
      "price": 8.99,
      "image": "https://source.unsplash.com/random/300x200/?tiramisu",
      "imageSearchTerm": "tiramisu dessert",
      "category": "food",
      "categoryId": "food",
      "subcategory": "DESSERTS",
      "featured": true,
      "popular": false,
      "tags": ["coffee", "italian", "creamy"]
    },
    {
      "id": "dessert-4",
      "name": "CrÃ¨me BrÃ»lÃ©e",
      "description": "Silky vanilla custard with caramelized sugar crust",
      "price": 9.99,
      "image": "https://source.unsplash.com/random/300x200/?creme-brulee",
      "imageSearchTerm": "creme brulee",
      "category": "food",
      "categoryId": "food",
      "subcategory": "DESSERTS",
      "featured": false,
      "popular": false,
      "tags": ["french", "vanilla", "caramel"]
    }
  ]
}
</file>

<file path="src/data/new-menu-items.json">
{
  "items": [
    {
      "id": "noodles-1",
      "name": "Pad Thai",
      "description": "Classic Thai stir-fried rice noodles with egg, tofu, bean sprouts and crushed peanuts",
      "price": 16.99,
      "image": "https://source.unsplash.com/random/300x200/?pad-thai",
      "imageSearchTerm": "pad thai noodles",
      "category": "food",
      "categoryId": "food",
      "subcategory": "NOODLES",
      "featured": true,
      "popular": true,
      "tags": ["thai", "spicy", "vegetarian option"]
    },
    {
      "id": "noodles-2",
      "name": "Ramen Bowl",
      "description": "Rich miso broth with fresh ramen noodles, soft-boiled egg, char siu pork and green onions",
      "price": 18.99,
      "image": "https://source.unsplash.com/random/300x200/?ramen",
      "imageSearchTerm": "ramen bowl",
      "category": "food",
      "categoryId": "food",
      "subcategory": "NOODLES",
      "featured": false,
      "popular": true,
      "tags": ["japanese", "soup", "comfort food"]
    },
    {
      "id": "noodles-3",
      "name": "Udon Stir Fry",
      "description": "Thick udon noodles stir-fried with seasonal vegetables and choice of protein in a savory sauce",
      "price": 17.50,
      "image": "https://source.unsplash.com/random/300x200/?udon",
      "imageSearchTerm": "udon stir fry",
      "category": "food",
      "categoryId": "food",
      "subcategory": "NOODLES",
      "featured": false,
      "popular": false,
      "tags": ["japanese", "stir fry"]
    },
    {
      "id": "noodles-4",
      "name": "Pho Bo",
      "description": "Vietnamese beef noodle soup with rice noodles, thinly sliced beef, bean sprouts and fresh herbs",
      "price": 16.50,
      "image": "https://source.unsplash.com/random/300x200/?pho",
      "imageSearchTerm": "pho beef noodle soup",
      "category": "food",
      "categoryId": "food",
      "subcategory": "NOODLES",
      "featured": true,
      "popular": false,
      "tags": ["vietnamese", "soup", "beef"]
    },
    {
      "id": "sides-1",
      "name": "Truffle Fries",
      "description": "Crispy french fries tossed in truffle oil and parmesan, with garlic aioli",
      "price": 8.99,
      "image": "https://source.unsplash.com/random/300x200/?truffle-fries",
      "imageSearchTerm": "truffle fries",
      "category": "food",
      "categoryId": "food",
      "subcategory": "FRIED SIDES",
      "featured": true,
      "popular": true,
      "tags": ["vegetarian", "truffle", "shareable"]
    },
    {
      "id": "sides-2",
      "name": "Calamari Fritti",
      "description": "Lightly battered and fried squid rings served with lemon aioli and marinara sauce",
      "price": 14.50,
      "image": "https://source.unsplash.com/random/300x200/?calamari",
      "imageSearchTerm": "fried calamari",
      "category": "food",
      "categoryId": "food",
      "subcategory": "FRIED SIDES",
      "featured": false,
      "popular": true,
      "tags": ["seafood", "appetizer"]
    },
    {
      "id": "sides-3",
      "name": "Mozzarella Sticks",
      "description": "Breaded and fried mozzarella cheese sticks with marinara dipping sauce",
      "price": 9.99,
      "image": "https://source.unsplash.com/random/300x200/?mozzarella-sticks",
      "imageSearchTerm": "mozzarella sticks",
      "category": "food",
      "categoryId": "food",
      "subcategory": "FRIED SIDES",
      "featured": false,
      "popular": false,
      "tags": ["vegetarian", "cheese", "appetizer"]
    },
    {
      "id": "sides-4",
      "name": "Buffalo Wings",
      "description": "Crispy chicken wings tossed in spicy buffalo sauce with blue cheese dip and celery sticks",
      "price": 13.99,
      "image": "https://source.unsplash.com/random/300x200/?buffalo-wings",
      "imageSearchTerm": "buffalo wings",
      "category": "food",
      "categoryId": "food",
      "subcategory": "FRIED SIDES",
      "featured": true,
      "popular": true,
      "tags": ["spicy", "chicken", "shareable"]
    },
    {
      "id": "salad-1",
      "name": "Caesar Salad",
      "description": "Crisp romaine lettuce, garlic croutons, parmesan and creamy caesar dressing",
      "price": 12.50,
      "image": "https://source.unsplash.com/random/300x200/?caesar-salad",
      "imageSearchTerm": "caesar salad",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SALADS",
      "featured": true,
      "popular": true,
      "tags": ["classic", "vegetarian option"]
    },
    {
      "id": "salad-2",
      "name": "Greek Salad",
      "description": "Fresh cucumbers, tomatoes, red onion, kalamata olives, and feta cheese with herb vinaigrette",
      "price": 13.99,
      "image": "https://source.unsplash.com/random/300x200/?greek-salad",
      "imageSearchTerm": "greek salad",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SALADS",
      "featured": false,
      "popular": false,
      "tags": ["vegetarian", "mediterranean"]
    },
    {
      "id": "salad-3",
      "name": "Quinoa Power Bowl",
      "description": "Protein-rich quinoa with roasted seasonal vegetables, avocado and lemon tahini dressing",
      "price": 15.50,
      "image": "https://source.unsplash.com/random/300x200/?quinoa-bowl",
      "imageSearchTerm": "quinoa power bowl",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SALADS",
      "featured": true,
      "popular": false,
      "tags": ["vegan", "gluten-free", "healthy"]
    },
    {
      "id": "salad-4",
      "name": "Cobb Salad",
      "description": "Mixed greens with grilled chicken, bacon, hard-boiled egg, avocado, tomato and blue cheese",
      "price": 16.99,
      "image": "https://source.unsplash.com/random/300x200/?cobb-salad",
      "imageSearchTerm": "cobb salad",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SALADS",
      "featured": false,
      "popular": true,
      "tags": ["protein", "classic", "hearty"]
    },
    {
      "id": "sushi-platter-1",
      "name": "Sashimi Deluxe",
      "description": "Chef's selection of 15 pieces of premium fish sashimi with wasabi and pickled ginger",
      "price": 28.99,
      "image": "https://source.unsplash.com/random/300x200/?sashimi",
      "imageSearchTerm": "sashimi platter",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI PLATTERS",
      "featured": true,
      "popular": true,
      "tags": ["raw", "seafood", "japanese"]
    },
    {
      "id": "sushi-platter-2",
      "name": "Nigiri Assortment",
      "description": "12 pieces of hand-pressed sushi rice topped with fresh fish and seafood",
      "price": 24.50,
      "image": "https://source.unsplash.com/random/300x200/?nigiri",
      "imageSearchTerm": "nigiri sushi",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI PLATTERS",
      "featured": false,
      "popular": true,
      "tags": ["japanese", "traditional"]
    },
    {
      "id": "sushi-platter-3",
      "name": "Maki Combo",
      "description": "Assortment of 24 pieces of maki rolls including California, Spicy Tuna, and Philadelphia rolls",
      "price": 32.99,
      "image": "https://source.unsplash.com/random/300x200/?maki-rolls",
      "imageSearchTerm": "sushi maki platter",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI PLATTERS",
      "featured": true,
      "popular": false,
      "tags": ["shareable", "japanese", "variety"]
    },
    {
      "id": "sushi-platter-4",
      "name": "Chef's Special Platter",
      "description": "Premium selection of nigiri, sashimi and specialty rolls curated by our head sushi chef",
      "price": 45.00,
      "image": "https://source.unsplash.com/random/300x200/?sushi-platter",
      "imageSearchTerm": "premium sushi platter",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI PLATTERS",
      "featured": true,
      "popular": true,
      "tags": ["premium", "japanese", "special"]
    },
    {
      "id": "roll-1",
      "name": "California Roll",
      "description": "Crab, avocado and cucumber wrapped in nori and rice with sesame seeds",
      "price": 8.99,
      "image": "https://source.unsplash.com/random/300x200/?california-roll",
      "imageSearchTerm": "california roll",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI ROLLS",
      "featured": false,
      "popular": true,
      "tags": ["classic", "beginner friendly"]
    },
    {
      "id": "roll-2",
      "name": "Spicy Tuna Roll",
      "description": "Fresh tuna mixed with spicy mayo and cucumber wrapped in nori and rice",
      "price": 10.50,
      "image": "https://source.unsplash.com/random/300x200/?spicy-tuna-roll",
      "imageSearchTerm": "spicy tuna roll",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI ROLLS",
      "featured": true,
      "popular": true,
      "tags": ["spicy", "popular"]
    },
    {
      "id": "roll-3",
      "name": "Dragon Roll",
      "description": "Eel and cucumber inside, topped with avocado and eel sauce",
      "price": 14.99,
      "image": "https://source.unsplash.com/random/300x200/?dragon-roll",
      "imageSearchTerm": "dragon roll sushi",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI ROLLS",
      "featured": true,
      "popular": false,
      "tags": ["specialty", "cooked option"]
    },
    {
      "id": "roll-4",
      "name": "Rainbow Roll",
      "description": "California roll topped with assorted slices of fresh fish and avocado",
      "price": 15.50,
      "image": "https://source.unsplash.com/random/300x200/?rainbow-roll",
      "imageSearchTerm": "rainbow roll sushi",
      "category": "food",
      "categoryId": "food",
      "subcategory": "SUSHI ROLLS",
      "featured": false,
      "popular": true,
      "tags": ["colorful", "variety"]
    }
  ]
}
</file>

<file path="src/data/slider-data.json">
[
  {
    "id": "slide1",
    "imageUrl": "https://images.unsplash.com/photo-1613614207188-5df10f9bb55e?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA",
    "imageSearchTerm": "summer cocktail promotion bar",
    "title": "Summer Special Offer!",
    "description": "Get 30% off on all cocktails every Friday",
    "link": "/category/cocktails"
  },
  {
    "id": "slide2",
    "imageUrl": "https://images.unsplash.com/photo-1563379926898-05f4575a45d8?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA",
    "imageSearchTerm": "premium italian pasta dish",
    "title": "New: Premium Pasta Collection",
    "description": "Handcrafted Italian pasta with authentic sauces",
    "link": "/category/food"
  },
  {
    "id": "slide3",
    "imageUrl": "https://images.unsplash.com/photo-1565557623262-b51c2513a641?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA",
    "imageSearchTerm": "indian curry festival food",
    "title": "Curry Festival This Week",
    "description": "Explore our authentic curry selection with special prices",
    "link": "/category/food"
  },
  {
    "id": "slide4",
    "imageUrl": "https://images.unsplash.com/photo-1561651823-34feb02250e4?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA",
    "imageSearchTerm": "cinema snacks combo popcorn drink",
    "title": "Cinema Snack Combos",
    "description": "Perfect pairings for your movie night",
    "link": "/category/cinema_snacks"
  }
]
</file>

<file path="src/hooks/use-mobile.tsx">
import * as React from "react"
const MOBILE_BREAKPOINT = 768
export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)
  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])
  return !!isMobile
}
</file>

<file path="src/hooks/use-toast.ts">
import * as React from "react"
import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"
const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000
type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}
const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const
let count = 0
function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}
type ActionType = typeof actionTypes
type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }
interface State {
  toasts: ToasterToast[]
}
const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()
const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }
  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)
  toastTimeouts.set(toastId, timeout)
}
export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }
    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }
    case "DISMISS_TOAST": {
      const { toastId } = action
      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}
const listeners: Array<(state: State) => void> = []
let memoryState: State = { toasts: [] }
function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}
type Toast = Omit<ToasterToast, "id">
function toast({ ...props }: Toast) {
  const id = genId()
  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })
  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })
  return {
    id: id,
    dismiss,
    update,
  }
}
function useToast() {
  const [state, setState] = React.useState<State>(memoryState)
  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])
  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}
export { useToast, toast }
</file>

<file path="src/hooks/useOrderActions.ts">
import { useState } from 'react';
import { useOrders } from '../context/OrderContext';
import { useCart } from '../context/CartContext';
import { useRouter } from 'next/router';
interface OrderActionsState {
  isPlacingOrder: boolean;
  orderError: string | null;
  orderSuccess: boolean;
}
export const useOrderActions = () => {
  const [state, setState] = useState<OrderActionsState>({
    isPlacingOrder: false,
    orderError: null,
    orderSuccess: false
  });
  const { createOrder, cancelOrder, loading } = useOrders();
  const { items, totalPrice, clearCart } = useCart();
  const router = useRouter();
  /**
   * Place a new order with the current cart items
   */
  const placeOrder = async (tableNumber?: string, specialInstructions?: string) => {
    // Reset state
    setState({
      isPlacingOrder: true,
      orderError: null,
      orderSuccess: false
    });
    try {
      if (items.length === 0) {
        throw new Error('Your cart is empty');
      }
      // Call the createOrder function from OrderContext
      const newOrder = await createOrder(
        items,
        totalPrice,
        tableNumber,
        specialInstructions
      );
      // Clear the cart
      clearCart();
      // Update state to reflect success
      setState({
        isPlacingOrder: false,
        orderError: null,
        orderSuccess: true
      });
      // Redirect to order confirmation page
      router.push(`/orders/${newOrder.id}`);
      return newOrder;
    } catch (error) {
      // Handle errors
      const errorMessage = error instanceof Error ? error.message : 'Failed to place order';
      setState({
        isPlacingOrder: false,
        orderError: errorMessage,
        orderSuccess: false
      });
      throw error;
    }
  };
  /**
   * Cancel an existing order
   */
  const handleCancelOrder = async (orderId: string) => {
    setState({
      ...state,
      isPlacingOrder: true,
      orderError: null
    });
    try {
      await cancelOrder(orderId);
      setState({
        ...state,
        isPlacingOrder: false,
        orderSuccess: true
      });
      return true;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to cancel order';
      setState({
        ...state,
        isPlacingOrder: false,
        orderError: errorMessage
      });
      return false;
    }
  };
  /**
   * Reset the order state
   */
  const resetOrderState = () => {
    setState({
      isPlacingOrder: false,
      orderError: null,
      orderSuccess: false
    });
  };
  return {
    ...state,
    loading: state.isPlacingOrder || loading,
    placeOrder,
    cancelOrder: handleCancelOrder,
    resetOrderState
  };
};
export default useOrderActions;
</file>

<file path="src/lib/theme-config.ts">
// Theme configuration file for Order Mate Express
// This file contains all theme related settings and color variables
export const themeColors = {
  // Dark theme colors (main theme)
  dark: {
    background: '#0B0C0E',       // Night black background
    card: '#1E1F23',             // Raisin black for cards
    primary: '#464587',          // Marian blue as primary color
    secondary: '#3A3A61',        // Delft blue as secondary color
    accent: '#5C5CA9',           // Lighter marian blue as accent
    text: '#FFFFFF',             // White text
    mutedText: '#A0A0A0',        // Muted text color
    border: '#2A2A30',           // Border color
    success: '#22C55E',          // Success green
    warning: '#F59E0B',          // Warning amber
    error: '#EF4444',            // Error red
  },
  // Light theme colors (optional secondary theme)
  light: {
    background: '#FFFFFF',
    card: '#F8F8F8',
    primary: '#464587',
    secondary: '#5C5CA9',
    accent: '#3A3A61',
    text: '#111111',
    mutedText: '#555555',
    border: '#E2E2E2',
    success: '#22C55E',
    warning: '#F59E0B',
    error: '#EF4444',
  }
};
// Default image placeholders in case stock images fail
export const imagePlaceholders = {
  food: '/placeholder.svg',
  drink: '/placeholder.svg',
  promotion: '/placeholder.svg',
  category: '/placeholder.svg'
};
// Alternate stock image APIs that can be used (instead of Unsplash)
export const stockImageApis = {
  food: 'https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg',
  burger: 'https://images.pexels.com/photos/1639562/pexels-photo-1639562.jpeg',
  pizza: 'https://images.pexels.com/photos/825661/pexels-photo-825661.jpeg',
  pasta: 'https://images.pexels.com/photos/1279330/pexels-photo-1279330.jpeg',
  salad: 'https://images.pexels.com/photos/1059905/pexels-photo-1059905.jpeg',
  sushi: 'https://images.pexels.com/photos/357756/pexels-photo-357756.jpeg',
  dessert: 'https://images.pexels.com/photos/1126359/pexels-photo-1126359.jpeg',
  drink: 'https://images.pexels.com/photos/602750/pexels-photo-602750.jpeg',
  cocktail: 'https://images.pexels.com/photos/1170598/pexels-photo-1170598.jpeg',
  wine: 'https://images.pexels.com/photos/3019019/pexels-photo-3019019.jpeg',
  beer: 'https://images.pexels.com/photos/1552630/pexels-photo-1552630.jpeg',
  coffee: 'https://images.pexels.com/photos/3020919/pexels-photo-3020919.jpeg'
};
// Get a stock image based on category and fallback to default food image
export const getStockImage = (category: string): string => {
  const key = category.toLowerCase() as keyof typeof stockImageApis;
  return stockImageApis[key] || stockImageApis.food;
};
// Theme configuration
export const themeConfig = {
  colors: themeColors,
  defaultTheme: 'dark',
  borderRadius: {
    sm: '0.25rem',
    md: '0.5rem',
    lg: '1rem',
    xl: '1.5rem',
    full: '9999px',
  },
  fontSizes: {
    xs: '0.75rem',
    sm: '0.875rem',
    md: '1rem',
    lg: '1.125rem',
    xl: '1.25rem',
    '2xl': '1.5rem',
    '3xl': '1.875rem',
    '4xl': '2.25rem',
  }
};
export default themeConfig;
</file>

<file path="src/lib/utils.ts">
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"
/**
 * Combines class names from multiple sources with Tailwind CSS optimization
 * Uses clsx to handle conditional classes and twMerge to handle Tailwind conflicts
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="src/pages/Cart.tsx">
import React, { useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { useCart } from '@/context/CartContext';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Trash2, Plus, Minus, ArrowLeft, ArrowRight, CheckCircle } from 'lucide-react';
import { cn } from '@/lib/utils';
import { toast } from 'sonner';
const Cart: React.FC = () => {
  const { items, removeItem, updateQuantity, clearCart, subtotal } = useCart();
  const navigate = useNavigate();
  const [isCheckingOut, setIsCheckingOut] = useState(false);
  const [orderPlaced, setOrderPlaced] = useState(false);
  // Simulated checkout process - in a real app, you'd connect to Stripe
  const handleCheckout = () => {
    if (items.length === 0) {
      toast.error("Your cart is empty");
      return;
    }
    setIsCheckingOut(true);
    // Simulate API call delay
    setTimeout(() => {
      setOrderPlaced(true);
      clearCart();
      // Redirect to home after order confirmation
      setTimeout(() => {
        navigate('/');
        toast.success("Thank you for your order!");
      }, 3000);
    }, 2000);
  };
  if (orderPlaced) {
    return (
      <div className="container mx-auto px-4 py-16 md:py-24 text-center max-w-md animate-fade-in">
        <CheckCircle className="mx-auto h-16 w-16 text-primary mb-6" />
        <h1 className="text-3xl font-medium mb-4">Order Confirmed!</h1>
        <p className="text-muted-foreground mb-8">
          Your order has been successfully placed. You'll be redirected to the homepage shortly.
        </p>
        <div className="animate-pulse bg-primary/10 h-2 w-full rounded-full overflow-hidden">
          <div className="bg-primary h-full animate-[progress_3s_ease-in-out]"></div>
        </div>
      </div>
    );
  }
  return (
    <div className="container mx-auto px-4 py-8 md:py-12 animate-fade-in">
      <Button 
        variant="ghost" 
        onClick={() => navigate(-1)} 
        className="mb-8 pl-0 hover:pl-1 transition-all"
        disabled={isCheckingOut}
      >
        <ArrowLeft className="mr-2 h-4 w-4" /> Back
      </Button>
      <h1 className="text-3xl md:text-4xl font-medium mb-8">Your Cart</h1>
      {items.length === 0 ? (
        <div className="text-center py-16 max-w-md mx-auto">
          <h2 className="text-2xl font-medium mb-4">Your cart is empty</h2>
          <p className="text-muted-foreground mb-8">
            Looks like you haven't added any items to your cart yet.
          </p>
          <Button asChild size="lg" className="rounded-full px-8">
            <Link to="/menu">Browse Menu</Link>
          </Button>
        </div>
      ) : (
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
          <div className="lg:col-span-2 space-y-4">
            {items.map((item) => (
              <div 
                key={item.id} 
                className="flex items-stretch border border-border/50 rounded-xl overflow-hidden bg-card"
              >
                <img 
                  src={item.image} 
                  alt={item.name}
                  className="w-24 h-24 object-cover"
                />
                <div className="flex-1 p-4 flex flex-col">
                  <div className="flex justify-between">
                    <h3 className="font-medium">{item.name}</h3>
                    <p className="font-medium">${(item.price * item.quantity).toFixed(2)}</p>
                  </div>
                  <p className="text-sm text-muted-foreground mb-2">
                    ${item.price.toFixed(2)} each
                  </p>
                  {item.specialInstructions && (
                    <p className="text-sm text-muted-foreground mb-2 italic">
                      "{item.specialInstructions}"
                    </p>
                  )}
                  <div className="flex items-center justify-between mt-auto">
                    <div className="flex items-center border border-border rounded-full overflow-hidden">
                      <Button
                        variant="ghost"
                        size="icon"
                        className="rounded-none h-8 w-8 p-0"
                        onClick={() => updateQuantity(item.id, item.quantity - 1)}
                        disabled={isCheckingOut}
                      >
                        <Minus className="h-3 w-3" />
                      </Button>
                      <span className="flex-1 text-center text-sm min-w-[30px]">
                        {item.quantity}
                      </span>
                      <Button
                        variant="ghost"
                        size="icon"
                        className="rounded-none h-8 w-8 p-0"
                        onClick={() => updateQuantity(item.id, item.quantity + 1)}
                        disabled={isCheckingOut}
                      >
                        <Plus className="h-3 w-3" />
                      </Button>
                    </div>
                    <Button
                      variant="ghost"
                      size="icon"
                      className="h-8 w-8 p-0 text-muted-foreground hover:text-destructive"
                      onClick={() => removeItem(item.id)}
                      disabled={isCheckingOut}
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </div>
                </div>
              </div>
            ))}
          </div>
          <div className="lg:col-span-1">
            <div className="bg-card border border-border/50 rounded-xl p-6 sticky top-24">
              <h3 className="text-xl font-medium mb-4">Order Summary</h3>
              <div className="space-y-3 mb-6">
                <div className="flex justify-between">
                  <span className="text-muted-foreground">Subtotal</span>
                  <span>${subtotal.toFixed(2)}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-muted-foreground">Delivery Fee</span>
                  <span>${(3.99).toFixed(2)}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-muted-foreground">Tax</span>
                  <span>${(subtotal * 0.08).toFixed(2)}</span>
                </div>
                <div className="border-t border-border pt-3 flex justify-between font-medium">
                  <span>Total</span>
                  <span>${(subtotal + 3.99 + subtotal * 0.08).toFixed(2)}</span>
                </div>
              </div>
              <div className="mb-4">
                <label htmlFor="promoCode" className="block text-sm font-medium mb-2">
                  Promo Code
                </label>
                <div className="flex items-center gap-2">
                  <Input 
                    id="promoCode" 
                    placeholder="Enter code" 
                    className="flex-1"
                    disabled={isCheckingOut}
                  />
                  <Button variant="outline" disabled={isCheckingOut}>Apply</Button>
                </div>
              </div>
              <Button 
                className="w-full rounded-full" 
                size="lg"
                onClick={handleCheckout}
                disabled={isCheckingOut || items.length === 0}
              >
                {isCheckingOut ? (
                  <div className="flex items-center">
                    <div className="animate-spin h-4 w-4 mr-2 border-2 border-current border-t-transparent rounded-full"></div>
                    Processing...
                  </div>
                ) : (
                  <>
                    Checkout <ArrowRight className="ml-2 h-4 w-4" />
                  </>
                )}
              </Button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};
export default Cart;
</file>

<file path="src/pages/Favorites.tsx">
import React, { useEffect } from 'react';
import { Link } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import { useFavorites } from '@/context/FavoritesContext';
import { api } from '@/services/api';
import { MenuItem } from '@/types';
import { MenuItemCard } from '@/components/MenuItemCard';
import { Button } from '@/components/ui/button';
import { HeartOff } from 'lucide-react';
const Favorites: React.FC = () => {
  const { favorites } = useFavorites();
  const { data: menuItems, isLoading } = useQuery({
    queryKey: ['menuItems'],
    queryFn: api.getMenuItems,
  });
  const favoriteItems = menuItems?.filter((item: MenuItem) => 
    favorites.includes(item.id)
  ) || [];
  useEffect(() => {
    window.scrollTo(0, 0);
  }, []);
  if (isLoading) {
    return (
      <div className="container mx-auto px-4 py-8 md:py-12 animate-pulse">
        <h1 className="text-3xl md:text-4xl font-medium mb-8 w-48 h-10 bg-secondary rounded"></h1>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {[...Array(3)].map((_, index) => (
            <div key={index} className="h-80 bg-secondary rounded-xl"></div>
          ))}
        </div>
      </div>
    );
  }
  return (
    <div className="container mx-auto px-4 py-8 md:py-12 animate-fade-in">
      <h1 className="text-3xl md:text-4xl font-medium mb-8">Your Favorites</h1>
      {favoriteItems.length === 0 ? (
        <div className="text-center py-16 max-w-md mx-auto">
          <HeartOff className="mx-auto h-16 w-16 text-muted-foreground mb-6" />
          <h2 className="text-2xl font-medium mb-4">No favorites yet</h2>
          <p className="text-muted-foreground mb-8">
            You haven't added any items to your favorites yet. Browse our menu and click the heart icon to add items you love.
          </p>
          <Button asChild size="lg" className="rounded-full px-8">
            <Link to="/menu">Browse Menu</Link>
          </Button>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {favoriteItems.map((item: MenuItem) => (
            <MenuItemCard key={item.id} item={item} />
          ))}
        </div>
      )}
    </div>
  );
};
export default Favorites;
</file>

<file path="src/pages/Layout.tsx.backup">
import React, { useEffect } from 'react';
import { Outlet, useLocation } from 'react-router-dom';
import { TableHeader } from '@/components/TableHeader';
import { BottomNav } from '@/components/BottomNav';
import { useTableInfo } from '@/context/TableContext';
import { useTheme } from 'next-themes';

const Layout: React.FC = () => {
  const { tableNumber, setTableInfo } = useTableInfo();
  const location = useLocation();
  const { theme, setTheme } = useTheme();
  
  useEffect(() => {
    // Extract table number from URL query parameters
    const queryParams = new URLSearchParams(location.search);
    const tableParam = queryParams.get('table');
    
    if (tableParam) {
      // If table parameter exists in URL, use it
      setTableInfo(prev => ({
        ...prev,
        tableNumber: tableParam
      }));
    } else {
      // Check if we need to generate a random table number
      const storedTable = localStorage.getItem('tableInfo');
      if (!storedTable || !JSON.parse(storedTable).tableNumber) {
        const randomTable = generateRandomTableNumber();
        setTableInfo(prev => ({
          ...prev,
          tableNumber: randomTable
        }));
      }
    }
  }, [location.search, setTableInfo]);
  
  // Generate a random alphanumeric table number of length 4
  const generateRandomTableNumber = (): string => {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let result = '';
    for (let i = 0; i < 4; i++) {
      result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
  };
  
  return (
    <div className="flex flex-col min-h-screen bg-gray-50 dark:bg-gray-900">
      <TableHeader />
      <main className="flex-grow pb-20">
        <Outlet />
      </main>
      <BottomNav />
    </div>
  );
};

export default Layout;
</file>

<file path="src/pages/Menu.tsx">
import React, { useState } from 'react';
import { MenuGrid } from '@/components/menu/MenuGrid';
import { Input } from '@/components/ui/input';
import { TabsList, TabsTrigger, Tabs } from '@/components/ui/tabs';
import { Search } from 'lucide-react';
import { useLocation } from 'react-router-dom';
import { api } from '@/services/api';
import { useQuery } from '@tanstack/react-query';
import { Drawer, DrawerContent } from '@/components/ui/drawer';
import { ItemDetailDrawer } from '@/components/ItemDetailDrawer';
import { MenuItem } from '@/types/menu';
import { MenuItemCardSkeleton } from '@/components/menu/MenuItemCardSkeleton';
// Default categories if API fails
const defaultCategories = [
  { id: 'all', name: 'All' },
  { id: 'food', name: 'Food' },
  { id: 'drinks', name: 'Drinks' },
  { id: 'desserts', name: 'Desserts' },
  { id: 'promotions', name: 'Promotions' },
];
const Menu: React.FC = () => {
  const location = useLocation();
  const [searchQuery, setSearchQuery] = useState('');
  const [activeCategory, setActiveCategory] = useState('all');
  const [selectedItem, setSelectedItem] = useState<MenuItem | null>(null);
  const [isDrawerOpen, setIsDrawerOpen] = useState(false);
  // Get categories from API
  const { data: categories, isLoading: categoriesLoading } = useQuery({
    queryKey: ['categories'],
    queryFn: api.getCategories,
    placeholderData: defaultCategories
  });
  // Extract search query from URL if present
  React.useEffect(() => {
    const searchParams = new URLSearchParams(location.search);
    const queryParam = searchParams.get('search');
    if (queryParam) {
      setSearchQuery(queryParam);
    }
  }, [location.search]);
  // Handlers for item details drawer
  const handleOpenDrawer = (item: MenuItem) => {
    setSelectedItem(item);
    setIsDrawerOpen(true);
  };
  const handleCloseDrawer = () => {
    setIsDrawerOpen(false);
  };
  // Reset to top when changing category
  React.useEffect(() => {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }, [activeCategory]);
  return (
    <div className="container mx-auto px-4 py-8 md:py-12 animate-fade-in">
      <div className="text-center mb-8 md:mb-12">
        <h1 className="text-3xl font-medium mb-4">Our Menu</h1>
        <p className="text-muted-foreground">Discover our exquisite selection of dishes</p>
      </div>
      {/* Search and Categories */}
      <div className="space-y-6 mb-8">
        {/* Search Bar */}
        <div className="relative max-w-md mx-auto">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <Input
            type="search"
            placeholder="Search menu..."
            className="pl-10"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
          />
        </div>
        {/* Category Tabs */}
        <Tabs 
          value={activeCategory} 
          onValueChange={setActiveCategory}
          className="w-full"
        >
          <TabsList className="flex flex-wrap justify-center gap-2 bg-transparent">
            {categoriesLoading ? (
              // Loading skeleton for categories
              <>
                {[...Array(5)].map((_, i) => (
                  <div key={i} className="h-9 w-24 bg-muted animate-pulse rounded-md" />
                ))}
              </>
            ) : (
              categories?.map((category) => (
                <TabsTrigger 
                  key={category.id} 
                  value={category.id}
                  className="data-[state=active]:bg-marian-blue data-[state=active]:text-white"
                >
                  {category.name}
                </TabsTrigger>
              ))
            )}
          </TabsList>
        </Tabs>
      </div>
      {/* Menu Grid */}
      <MenuGrid 
        category={activeCategory} 
        searchQuery={searchQuery}
        onItemClick={handleOpenDrawer}
      />
      {/* Item Detail Drawer */}
      <Drawer open={isDrawerOpen} onOpenChange={setIsDrawerOpen}>
        <DrawerContent>
          {selectedItem && (
            <ItemDetailDrawer 
              item={selectedItem} 
              onClose={handleCloseDrawer}
            />
          )}
        </DrawerContent>
      </Drawer>
    </div>
  );
};
export default Menu;
</file>

<file path="src/pages/MenuItemDetail.tsx">
import React, { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import { api } from '@/services/api';
import { useFavorites } from '@/context/FavoritesContext';
import { useCart } from '@/context/CartContext';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Heart, ArrowLeft, Plus, Minus, ShoppingCart, Clock, Tag } from 'lucide-react';
import { cn } from '@/lib/utils';
import { toast } from 'sonner';
const MenuItemDetail: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const { isFavorite, addFavorite, removeFavorite } = useFavorites();
  const { addItem } = useCart();
  const [quantity, setQuantity] = React.useState(1);
  const [specialInstructions, setSpecialInstructions] = React.useState('');
  const [isJsonFallback, setIsJsonFallback] = useState(false);
  // Try to fetch from API first
  const { data: item, isLoading, error } = useQuery({
    queryKey: ['menuItem', id],
    queryFn: async () => {
      try {
        const apiItem = await api.getMenuItem(id!);
        return apiItem;
      } catch (err) {
        console.error("API fetch failed, falling back to JSON", err);
        setIsJsonFallback(true);
        // Fallback to JSON file
        const response = await fetch('/src/data/menu-items.json');
        if (!response.ok) throw new Error("Failed to load data");
        const data = await response.json();
        const foundItem = data.items.find((item: any) => item.id === id);
        if (!foundItem) throw new Error("Item not found");
        return foundItem;
      }
    },
    retry: false,
    enabled: !!id,
  });
  useEffect(() => {
    window.scrollTo(0, 0);
  }, [id]);
  const handleQuantityChange = (amount: number) => {
    const newQuantity = quantity + amount;
    if (newQuantity >= 1) {
      setQuantity(newQuantity);
    }
  };
  const handleAddToCart = () => {
    if (item) {
      addItem(
        item, 
        quantity, 
        undefined,
        undefined,
        specialInstructions
      );
      toast.success(`Added ${item.name} to cart`);
    }
  };
  const handleFavoriteToggle = () => {
    if (!item) return;
    if (isFavorite(item.id)) {
      removeFavorite(item.id);
      toast.info(`Removed ${item.name} from favorites`);
    } else {
      addFavorite(item.id);
      toast.success(`Added ${item.name} to favorites`);
    }
  };
  const handleBack = () => {
    navigate(-1);
  };
  // Get food image using Foodish API
  const getFoodImage = (searchTerm: string) => {
    // Use the item ID to get a deterministic image number
    const itemNum = id ? (parseInt(id.replace(/\D/g, '')) % 30) + 1 : Math.floor(Math.random() * 30) + 1;
    // Categories: biryani, burger, butter-chicken, dessert, dosa, idly, pasta, pizza, rice, samosa
    const category = searchTerm?.includes('burger') ? 'burger' : 
                     searchTerm?.includes('pasta') ? 'pasta' :
                     searchTerm?.includes('pizza') ? 'pizza' :
                     searchTerm?.includes('dessert') ? 'dessert' :
                     searchTerm?.includes('chicken') ? 'butter-chicken' :
                     searchTerm?.includes('rice') ? 'rice' : 'burger';
    return `https://foodish-api.herokuapp.com/images/${category}/${category}${itemNum}.jpg`;
  };
  if (isLoading) {
    return (
      <div className="container mx-auto px-4 py-6 mt-14">
        <div className="animate-pulse">
          <div className="h-6 w-24 bg-gray-200 rounded mb-6"></div>
          <div className="h-64 w-full bg-gray-200 rounded-xl mb-6"></div>
          <div className="h-8 w-3/4 bg-gray-200 rounded mb-3"></div>
          <div className="h-6 w-1/4 bg-gray-200 rounded mb-4"></div>
          <div className="h-24 w-full bg-gray-200 rounded mb-6"></div>
          <div className="flex space-x-2 mb-6">
            <div className="h-6 w-16 bg-gray-200 rounded"></div>
            <div className="h-6 w-16 bg-gray-200 rounded"></div>
          </div>
          <div className="h-32 w-full bg-gray-200 rounded mb-6"></div>
          <div className="h-12 w-full bg-gray-200 rounded"></div>
        </div>
      </div>
    );
  }
  if (error || !item) {
    return (
      <div className="container mx-auto px-4 py-8 mt-14 text-center">
        <h2 className="text-xl font-medium mb-4">Item not found</h2>
        <p className="text-muted-foreground mb-6">The menu item you're looking for doesn't exist or has been removed.</p>
        <Button onClick={handleBack}>Go Back</Button>
      </div>
    );
  }
  const isFav = isFavorite(item.id);
  const imageUrl = item.image || getFoodImage(item.imageSearchTerm || 'food');
  return (
    <div className="container mx-auto px-4 py-4 mt-14 animate-fade-in pb-20">
      {isJsonFallback && (
        <div className="mb-4 px-3 py-2 bg-amber-50 border border-amber-200 rounded-md text-amber-800 text-xs">
          Using locally cached data. Some features may be limited.
        </div>
      )}
      <Button 
        variant="ghost" 
        onClick={handleBack} 
        className="mb-4 pl-0 hover:pl-1 transition-all"
        size="sm"
      >
        <ArrowLeft className="mr-2 h-4 w-4" /> Back
      </Button>
      <div className="rounded-2xl overflow-hidden bg-white dark:bg-gray-800 shadow-sm">
        <div className="relative">
          <img 
            src={imageUrl}
            alt={item.name} 
            className="w-full h-60 object-cover"
            onError={(e) => {
              const target = e.target as HTMLImageElement;
              target.src = getFoodImage(item.imageSearchTerm || 'food');
            }}
          />
          <Button
            variant="outline"
            size="icon"
            className={cn(
              "absolute top-4 right-4 rounded-full bg-white/90 backdrop-blur-sm transition-colors",
              isFav ? "text-red-500 border-red-500 hover:bg-red-50" : "text-gray-500 hover:text-red-500"
            )}
            onClick={handleFavoriteToggle}
          >
            <Heart className={cn("h-5 w-5", isFav && "fill-red-500")} />
          </Button>
          {item.featured && (
            <div className="absolute top-4 left-4 bg-emerald-500 text-white px-3 py-1 text-xs font-medium rounded-full">
              Featured
            </div>
          )}
        </div>
        <div className="p-5">
          <div className="flex justify-between items-start mb-2">
            <h1 className="text-2xl font-medium">{item.name}</h1>
            <span className="text-xl font-semibold text-emerald-600 dark:text-emerald-400">
              ${item.price.toFixed(2)}
            </span>
          </div>
          <div className="flex items-center gap-4 mb-3">
            {item.nutritionInfo?.calories && (
              <div className="inline-flex items-center text-xs text-gray-500">
                <span className="mr-1 text-emerald-500">â€¢</span>
                {item.nutritionInfo.calories} kcal
              </div>
            )}
            {item.preparationTime && (
              <div className="inline-flex items-center text-xs text-gray-500">
                <Clock className="mr-1 h-3 w-3 text-emerald-500" />
                {item.preparationTime}
              </div>
            )}
            {item.rating && (
              <div className="inline-flex items-center text-xs text-gray-500">
                <span className="mr-1 text-amber-400">â˜…</span>
                {item.rating}
              </div>
            )}
          </div>
          <div className="mb-4">
            <p className="text-gray-600 dark:text-gray-300 text-sm">
              {item.description}
            </p>
          </div>
          <div className="flex flex-wrap gap-2 mb-5">
            {item.tags?.map((tag) => (
              <div 
                key={tag} 
                className="inline-flex items-center bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded-full text-xs"
              >
                <Tag className="mr-1 h-3 w-3 text-emerald-500" />
                {tag}
              </div>
            ))}
          </div>
          <div className="mb-4">
            <label htmlFor="specialInstructions" className="block text-sm font-medium mb-2">
              Special Instructions
            </label>
            <Textarea
              id="specialInstructions"
              placeholder="Any special requests or allergies?"
              className="resize-none"
              value={specialInstructions}
              onChange={(e) => setSpecialInstructions(e.target.value)}
            />
          </div>
          <div className="flex items-center justify-between mt-6">
            <div className="flex items-center border border-gray-200 dark:border-gray-700 rounded-full overflow-hidden">
              <Button
                variant="ghost"
                size="icon"
                className="rounded-none h-9 w-9"
                onClick={() => handleQuantityChange(-1)}
                disabled={quantity <= 1}
              >
                <Minus className="h-4 w-4" />
              </Button>
              <span className="w-9 text-center text-sm font-medium">{quantity}</span>
              <Button
                variant="ghost"
                size="icon"
                className="rounded-none h-9 w-9"
                onClick={() => handleQuantityChange(1)}
              >
                <Plus className="h-4 w-4" />
              </Button>
            </div>
            <Button 
              className="rounded-full bg-emerald-500 hover:bg-emerald-600 dark:bg-emerald-600 dark:hover:bg-emerald-700 px-8" 
              onClick={handleAddToCart}
            >
              Add to cart - ${(item.price * quantity).toFixed(2)}
            </Button>
          </div>
          {item.nutritionInfo && (
            <div className="mt-6 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-100 dark:border-gray-700">
              <h3 className="font-medium text-sm mb-2">Nutrition Information</h3>
              <div className="grid grid-cols-4 gap-2">
                <div className="text-center p-2">
                  <div className="text-xs text-gray-500">Protein</div>
                  <div className="font-medium">{item.nutritionInfo.protein}</div>
                </div>
                <div className="text-center p-2">
                  <div className="text-xs text-gray-500">Carbs</div>
                  <div className="font-medium">{item.nutritionInfo.carbs}</div>
                </div>
                <div className="text-center p-2">
                  <div className="text-xs text-gray-500">Fats</div>
                  <div className="font-medium">{item.nutritionInfo.fats}</div>
                </div>
                <div className="text-center p-2">
                  <div className="text-xs text-gray-500">Calories</div>
                  <div className="font-medium">{item.nutritionInfo.calories}</div>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
export default MenuItemDetail;
</file>

<file path="src/pages/MenuPage.tsx">
import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import MenuCategoryList from '@/components/MenuCategoryList';
import MenuSubcategoryList from '@/components/MenuSubcategoryList';
import MenuItemList from '@/components/MenuItemList';
import { getCategories, getSubcategories, getMenuItems, Category, Subcategory, MenuItem } from '@/api/menuService';
import { useToast } from '@/components/ui/use-toast';
const MenuPage = () => {
  const navigate = useNavigate();
  const { toast } = useToast();
  const [categories, setCategories] = useState<Category[]>([]);
  const [subcategories, setSubcategories] = useState<Subcategory[]>([]);
  const [menuItems, setMenuItems] = useState<MenuItem[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
  const [selectedSubcategory, setSelectedSubcategory] = useState<string | null>(null);
  // Example restaurant ID - should come from context/props/route params in real app
  const restaurantId = "655f142a12345678901234ff";
  // Fetch categories on component mount
  useEffect(() => {
    const fetchCategories = async () => {
      try {
        setLoading(true);
        const data = await getCategories(restaurantId);
        setCategories(data);
        setLoading(false);
      } catch (err) {
        setError('Failed to fetch categories');
        toast({
          title: "Error",
          description: "Failed to fetch menu categories. Please try again.",
          variant: "destructive"
        });
        setLoading(false);
      }
    };
    fetchCategories();
  }, [restaurantId, toast]);
  // Fetch subcategories when a category is selected
  useEffect(() => {
    const fetchSubcategories = async () => {
      if (!selectedCategory) {
        setSubcategories([]);
        return;
      }
      try {
        setLoading(true);
        const data = await getSubcategories(selectedCategory);
        setSubcategories(data);
        setLoading(false);
      } catch (err) {
        setError('Failed to fetch subcategories');
        toast({
          title: "Error",
          description: "Failed to fetch subcategories. Please try again.",
          variant: "destructive"
        });
        setLoading(false);
      }
    };
    fetchSubcategories();
  }, [selectedCategory, toast]);
  // Fetch menu items when a subcategory is selected
  useEffect(() => {
    const fetchMenuItems = async () => {
      if (!selectedCategory) {
        setMenuItems([]);
        return;
      }
      try {
        setLoading(true);
        const data = await getMenuItems(
          restaurantId, 
          selectedCategory, 
          selectedSubcategory || undefined
        );
        setMenuItems(data);
        setLoading(false);
      } catch (err) {
        setError('Failed to fetch menu items');
        toast({
          title: "Error",
          description: "Failed to fetch menu items. Please try again.",
          variant: "destructive"
        });
        setLoading(false);
      }
    };
    fetchMenuItems();
  }, [restaurantId, selectedCategory, selectedSubcategory, toast]);
  const handleCategorySelect = (categoryId: string) => {
    setSelectedCategory(categoryId);
    setSelectedSubcategory(null);
  };
  const handleSubcategorySelect = (subcategoryId: string) => {
    setSelectedSubcategory(subcategoryId);
  };
  const handleMenuItemSelect = (menuItemId: string) => {
    navigate(`/menu-item/${menuItemId}`);
  };
  const handleBackToCategories = () => {
    setSelectedCategory(null);
    setSelectedSubcategory(null);
  };
  const handleBackToSubcategories = () => {
    setSelectedSubcategory(null);
  };
  const handleAddToCart = (item: MenuItem) => {
    // In a real app, this would add the item to a cart context/state
    toast({
      title: "Added to Cart",
      description: `${item.name} has been added to your cart.`,
      variant: "default"
    });
  };
  if (error) {
    return (
      <div className="p-8 text-center">
        <p className="text-red-500 text-xl">{error}</p>
      </div>
    );
  }
  if (loading && !categories.length) {
    return (
      <div className="flex justify-center items-center p-8 min-h-[300px]">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
      </div>
    );
  }
  return (
    <div className="mt-16">
      {!selectedCategory ? (
        <MenuCategoryList 
          categories={categories} 
          onCategorySelect={handleCategorySelect} 
        />
      ) : !selectedSubcategory ? (
        <MenuSubcategoryList 
          subcategories={subcategories} 
          onSubcategorySelect={handleSubcategorySelect} 
          onBackClick={handleBackToCategories}
          categoryName={categories.find(c => c._id === selectedCategory)?.name || ''}
        />
      ) : (
        <MenuItemList 
          menuItems={menuItems} 
          onBackClick={handleBackToSubcategories}
          onAddToCart={handleAddToCart}
          subcategoryName={subcategories.find(s => s._id === selectedSubcategory)?.name || ''}
        />
      )}
    </div>
  );
};
export default MenuPage;
</file>

<file path="src/pages/NotFound.tsx">
import { useLocation } from "react-router-dom";
import { useEffect } from "react";
const NotFound = () => {
  const location = useLocation();
  useEffect(() => {
    console.error(
      "404 Error: User attempted to access non-existent route:",
      location.pathname
    );
  }, [location.pathname]);
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="text-center">
        <h1 className="text-4xl font-bold mb-4">404</h1>
        <p className="text-xl text-gray-600 mb-4">Oops! Page not found</p>
        <a href="/" className="text-blue-500 hover:text-blue-700 underline">
          Return to Home
        </a>
      </div>
    </div>
  );
};
export default NotFound;
</file>

<file path="src/services/test-order-service.ts">
import { OrderService } from './OrderService';
import { CartItem, OrderStatus } from '@/types';
// Helper to log results in a formatted way
const logResult = (title: string, data: any) => {
  console.log('\n====================');
  console.log(title);
  console.log('====================');
  console.log(JSON.stringify(data, null, 2));
};
// Function to run all tests
const runTests = async () => {
  try {
    console.log('Starting OrderService tests...');
    // Clear localStorage first to start fresh
    localStorage.clear();
    // TEST 1: Create an order
    console.log('\nTEST 1: Creating a new order...');
    const cartItems: CartItem[] = [
      {
        id: 'cart-item-1',
        menuItemId: '1',
        name: 'Dal Makhani',
        price: 30.00,
        quantity: 2,
        image: '/placeholder.svg',
        modifiers: [
          { id: 'mod1', name: 'Extra Spicy', price: 1.00 }
        ]
      },
      {
        id: 'cart-item-2',
        menuItemId: '2',
        name: 'Classic Cheeseburger',
        price: 12.99,
        quantity: 1,
        image: '/placeholder.svg'
      }
    ];
    const tableNumber = "12";
    const createdOrder = await OrderService.createOrder(cartItems, tableNumber);
    logResult('Created Order', createdOrder);
    // TEST 2: Get all orders
    console.log('\nTEST 2: Getting all orders...');
    const allOrders = await OrderService.getOrders();
    logResult('All Orders', allOrders);
    // TEST 3: Get order by ID
    console.log('\nTEST 3: Getting order by ID...');
    const orderId = createdOrder.id;
    const retrievedOrder = await OrderService.getOrderById(orderId);
    logResult('Retrieved Order', retrievedOrder);
    // TEST 4: Update order status
    console.log('\nTEST 4: Updating order status...');
    const updatedOrder = await OrderService.updateOrderStatus(orderId, OrderStatus.READY);
    logResult('Updated Order', updatedOrder);
    // TEST 5: Get active orders
    console.log('\nTEST 5: Getting active orders...');
    const activeOrders = await OrderService.getActiveOrders();
    logResult('Active Orders', activeOrders);
    // TEST 6: Create another order
    console.log('\nTEST 6: Creating another order...');
    const moreCartItems: CartItem[] = [
      {
        id: 'cart-item-3',
        menuItemId: '6',
        name: 'Spaghetti Carbonara',
        price: 16.99,
        quantity: 1,
        image: '/placeholder.svg'
      }
    ];
    const anotherOrder = await OrderService.createOrder(moreCartItems, tableNumber);
    logResult('Another Order', anotherOrder);
    // TEST 7: Complete an order
    console.log('\nTEST 7: Completing an order...');
    const completedOrder = await OrderService.updateOrderStatus(orderId, OrderStatus.COMPLETED);
    logResult('Completed Order', completedOrder);
    // TEST 8: Get completed orders
    console.log('\nTEST 8: Getting completed orders...');
    const completedOrders = await OrderService.getCompletedOrders();
    logResult('Completed Orders', completedOrders);
    // TEST 9: Cancel an order
    console.log('\nTEST 9: Cancelling an order...');
    const cancelResult = await OrderService.cancelOrder(anotherOrder.id);
    logResult('Cancel Result', cancelResult);
    // TEST 10: Verify orders after cancellation
    console.log('\nTEST 10: Getting all orders after cancellation...');
    const remainingOrders = await OrderService.getOrders();
    logResult('Remaining Orders', remainingOrders);
    console.log('\nAll tests completed successfully!');
  } catch (error) {
    console.error('Error during tests:', error);
  }
};
// Run the tests
runTests();
</file>

<file path="src/services/WebSocketService.ts">
import { toast } from 'sonner';
import { OrderStatus } from '@/types';
// This is a mock WebSocket service for demo purposes
// In a real app, this would connect to a real WebSocket server
type MessageHandler = (data: any) => void;
type StatusUpdateHandler = (orderId: string, status: OrderStatus) => void;
type ConnectionHandler = () => void;
export class WebSocketService {
  private static instance: WebSocketService;
  private connected: boolean = false;
  private messageHandlers: MessageHandler[] = [];
  private statusUpdateHandlers: StatusUpdateHandler[] = [];
  private connectionHandlers: ConnectionHandler[] = [];
  private disconnectionHandlers: ConnectionHandler[] = [];
  private reconnectInterval: number = 5000; // 5 seconds
  private reconnectTimer: NodeJS.Timeout | null = null;
  private mockSocket: any = null;
  // Singleton pattern
  public static getInstance(): WebSocketService {
    if (!WebSocketService.instance) {
      WebSocketService.instance = new WebSocketService();
    }
    return WebSocketService.instance;
  }
  // Connect to WebSocket server
  public connect(tableNumber: string): void {
    if (this.connected) return;
    // Simulate connection process
    console.log(`Connecting to WebSocket server for table ${tableNumber}...`);
    // In a real app, this would be a real WebSocket connection
    setTimeout(() => {
      this.connected = true;
      console.log('WebSocket connected successfully');
      // Notify connection handlers
      this.connectionHandlers.forEach(handler => handler());
      // Set up mock socket behavior - simulates server sending updates
      this.setupMockSocket(tableNumber);
    }, 1000);
  }
  // Disconnect from WebSocket server
  public disconnect(): void {
    if (!this.connected) return;
    console.log('Disconnecting from WebSocket...');
    // Clear mock behaviors
    if (this.mockSocket) {
      clearInterval(this.mockSocket);
      this.mockSocket = null;
    }
    // Clear reconnect timer if active
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    // Mark as disconnected
    this.connected = false;
    // Notify disconnection handlers
    this.disconnectionHandlers.forEach(handler => handler());
    console.log('WebSocket disconnected');
  }
  // Check if connected
  public isConnected(): boolean {
    return this.connected;
  }
  // Add message handler
  public onMessage(handler: MessageHandler): void {
    this.messageHandlers.push(handler);
  }
  // Add status update handler
  public onStatusUpdate(handler: StatusUpdateHandler): void {
    this.statusUpdateHandlers.push(handler);
  }
  // Add connection handler
  public onConnect(handler: ConnectionHandler): void {
    this.connectionHandlers.push(handler);
  }
  // Add disconnection handler
  public onDisconnect(handler: ConnectionHandler): void {
    this.disconnectionHandlers.push(handler);
  }
  // Remove message handler
  public removeMessageHandler(handler: MessageHandler): void {
    this.messageHandlers = this.messageHandlers.filter(h => h !== handler);
  }
  // Remove status update handler
  public removeStatusUpdateHandler(handler: StatusUpdateHandler): void {
    this.statusUpdateHandlers = this.statusUpdateHandlers.filter(h => h !== handler);
  }
  // Remove connection handler
  public removeConnectionHandler(handler: ConnectionHandler): void {
    this.connectionHandlers = this.connectionHandlers.filter(h => h !== handler);
  }
  // Remove disconnection handler
  public removeDisconnectionHandler(handler: ConnectionHandler): void {
    this.disconnectionHandlers = this.disconnectionHandlers.filter(h => h !== handler);
  }
  // Send message to server (mock implementation)
  public sendMessage(message: any): void {
    if (!this.connected) {
      console.error('Cannot send message: WebSocket not connected');
      return;
    }
    console.log('Sending message:', message);
    // In a real app, this would send a message to the server
    // For demo, we'll just simulate a response
    setTimeout(() => {
      const response = {
        type: 'ack',
        message: 'Message received',
        data: message
      };
      // Notify message handlers
      this.messageHandlers.forEach(handler => handler(response));
    }, 500);
  }
  // Set up mock socket behavior
  private setupMockSocket(tableNumber: string): void {
    // Create a list of fake orders for simulation
    const fakeOrders = [
      { id: 'order-' + (Date.now() - 600000), tableNumber }, // 10 minutes ago
      { id: 'order-' + (Date.now() - 300000), tableNumber }, // 5 minutes ago
      { id: 'order-' + Date.now(), tableNumber } // Now
    ];
    // Simulate receiving status updates randomly
    this.mockSocket = setInterval(() => {
      // Skip sometimes to make it more realistic
      if (Math.random() > 0.3) return;
      // Pick a random order and status
      const randomOrder = fakeOrders[Math.floor(Math.random() * fakeOrders.length)];
      const statuses: OrderStatus[] = ['preparing', 'ready', 'delivered', 'completed'];
      const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];
      // Create update message
      const updateMessage = {
        type: 'status_update',
        orderId: randomOrder.id,
        status: randomStatus
      };
      console.log('Received WebSocket message:', updateMessage);
      // Notify message handlers
      this.messageHandlers.forEach(handler => handler(updateMessage));
      // Notify status update handlers
      if (updateMessage.type === 'status_update') {
        this.statusUpdateHandlers.forEach(handler => 
          handler(updateMessage.orderId, updateMessage.status)
        );
        // Show toast notification
        if (updateMessage.status === 'ready') {
          toast.success(`Order ${updateMessage.orderId.slice(-4)} is ready!`);
        } else if (updateMessage.status === 'delivered') {
          toast.success(`Order ${updateMessage.orderId.slice(-4)} has been delivered!`);
        }
      }
    }, 10000); // Every 10 seconds, randomly update
  }
}
export default WebSocketService.getInstance();
</file>

<file path="src/utils/dataFetcher.ts">
import { toast } from 'sonner';
interface FetchWithFallbackOptions {
  signal?: AbortSignal;
  headers?: HeadersInit;
  method?: string;
  body?: BodyInit;
  fallbackPath: string;
  timeout?: number;
}
interface FetchWithFallbackResult<T> {
  data: T;
  isFallback: boolean;
}
/**
 * Fetch data from an API endpoint with fallback to a local JSON file
 */
export const fetchWithFallback = async <T>(
  apiUrl: string,
  options: FetchWithFallbackOptions
): Promise<FetchWithFallbackResult<T>> => {
  let isFallback = false;
  // Add timeout if not provided
  const timeoutSignal = options.timeout 
    ? AbortSignal.timeout(options.timeout) 
    : AbortSignal.timeout(5000); // 5 seconds default
  const fetchSignal = options.signal 
    ? AbortSignal.any([options.signal, timeoutSignal]) 
    : timeoutSignal;
  try {
    // Try API endpoint first
    const apiResponse = await fetch(apiUrl, {
      method: options.method || 'GET',
      headers: options.headers || {
        'Content-Type': 'application/json',
      },
      body: options.body,
      signal: fetchSignal,
    });
    if (apiResponse.ok) {
      const data = await apiResponse.json();
      return { data, isFallback: false };
    }
    throw new Error(`API request failed with status: ${apiResponse.status}`);
  } catch (error) {
    console.error(`Error fetching ${apiUrl}:`, error);
    // API request failed, fall back to local JSON
    isFallback = true;
    try {
      console.info(`Falling back to local file: ${options.fallbackPath}`);
      const fallbackResponse = await fetch(options.fallbackPath);
      if (!fallbackResponse.ok) {
        throw new Error(`Fallback request failed with status: ${fallbackResponse.status}`);
      }
      const fallbackData = await fallbackResponse.json();
      return { data: fallbackData, isFallback: true };
    } catch (fallbackError) {
      console.error(`Fallback to ${options.fallbackPath} failed:`, fallbackError);
      throw new Error(`Both API and fallback data sources failed`);
    }
  }
};
/**
 * Add data to a JSON file if API is not available
 */
export const saveDataLocally = async <T>(
  apiUrl: string, 
  data: T, 
  fallbackPath: string
): Promise<boolean> => {
  try {
    // Try API endpoint first
    const apiResponse = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
      signal: AbortSignal.timeout(5000),
    });
    if (apiResponse.ok) {
      toast.success('Data saved successfully');
      return true;
    }
    throw new Error(`API request failed with status: ${apiResponse.status}`);
  } catch (error) {
    console.error(`Error saving to ${apiUrl}:`, error);
    // In a real app, we would save to localStorage as we can't write to files directly
    // from browser. For this demo, we'll just show what would happen.
    const localStorageKey = `local_${fallbackPath.replace(/[^a-zA-Z0-9]/g, '_')}`;
    try {
      // Get existing data if any
      let existingData = [];
      const storedData = localStorage.getItem(localStorageKey);
      if (storedData) {
        existingData = JSON.parse(storedData);
      }
      // Add new data
      if (Array.isArray(existingData)) {
        existingData.push(data);
      } else {
        existingData = [data];
      }
      // Save back to localStorage
      localStorage.setItem(localStorageKey, JSON.stringify(existingData));
      toast.warning('API is unavailable. Data saved locally and will be synced when the server is back online.');
      return true;
    } catch (localSaveError) {
      console.error('Failed to save data locally:', localSaveError);
      toast.error('Failed to save data. Please try again later.');
      return false;
    }
  }
};
</file>

<file path="src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}
.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}
@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}
.card {
  padding: 2em;
}
.read-the-docs {
  color: #888;
}
</file>

<file path="src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
@keyframes slide-up {
  from {
    transform: translateY(100%);
  }
  to {
    transform: translateY(0);
  }
}
.animate-slide-up {
  animation: slide-up 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards;
}
@keyframes slide-down {
  from {
    transform: translateY(-100%);
  }
  to {
    transform: translateY(0);
  }
}
.animate-slide-down {
  animation: slide-down 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards;
}
@layer base {
  :root, html, body {
    /* Dark purple theme based on the Figma design */
    --background: 260 10% 10%; /* Dark purple-black background */
    --foreground: 0 0% 98%; /* Almost white text */
    --card: 260 12% 15%; /* Slightly lighter dark purple */
    --card-foreground: 0 0% 100%;
    --popover: 260 12% 15%; /* Same as card */
    --popover-foreground: 0 0% 100%;
    --primary: 265 50% 60%; /* Bright purple for accents/buttons */
    --primary-foreground: 0 0% 100%;
    --secondary: 260 15% 20%; /* Slightly lighter than background */
    --secondary-foreground: 0 0% 100%;
    --muted: 260 15% 25%; /* For subtle UI elements */
    --muted-foreground: 0 0% 80%; /* Lighter gray for muted text */
    --accent: 265 50% 60%; /* Same as primary */
    --accent-foreground: 0 0% 100%;
    --destructive: 0 70% 50%; /* Red for destructive actions */
    --destructive-foreground: 0 0% 100%;
    --border: 260 15% 20%; /* Subtle borders */
    --input: 260 15% 20%;
    --ring: 265 50% 60%; /* Match primary */
    --radius: 0.5rem;
    /* Custom brand colors from the Figma design */
    --purple-primary: #7B61FF; /* Brand purple for icons and buttons */
    --purple-dark: #1F1D2B; /* Main background color */
    --purple-darker: #16141F; /* Bottom nav/darker areas */
    --purple-light: #2D303E; /* Card backgrounds */
    --white: #FFFFFF;
  }
  /* Force dark mode for all elements */
  html, body {
    color-scheme: dark;
    background-color: var(--purple-dark);
    color: var(--white);
  }
  /* Add specific styling for bottom navigation */
  .bottom-nav {
    background-color: var(--purple-darker);
  }
  .bottom-nav-icon {
    color: var(--purple-primary);
  }
  /* Style subcategories to be visible */
  .subcategory-scroll {
    scrollbar-width: none;
  }
  .subcategory-scroll::-webkit-scrollbar {
    display: none;
  }
  .subcategory-button.active {
    background-color: var(--purple-primary);
    color: white;
  }
  .subcategory-button {
    border-color: var(--purple-primary);
    color: var(--purple-primary);
  }
}
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground font-sans antialiased; /* Removed dark:* here as variables handle it */
  }
  h1, h2, h3, h4, h5, h6 {
    @apply font-medium tracking-tight;
  }
  h1 {
    @apply text-4xl md:text-5xl;
  }
  h2 {
    @apply text-3xl md:text-4xl;
  }
  h3 {
    @apply text-2xl md:text-3xl;
  }
  h4 {
    @apply text-xl md:text-2xl;
  }
  p {
    @apply leading-relaxed;
  }
}
@layer components {
  .menu-category {
    @apply inline-flex items-center justify-center px-4 py-2 text-sm font-medium rounded-full transition-all;
  }
  .menu-category.active {
    @apply bg-primary text-primary-foreground dark:bg-marian-blue dark:text-primary-foreground; /* Use marian-blue for active dark */
  }
  .menu-category:not(.active) {
    @apply bg-secondary text-secondary-foreground hover:bg-secondary/80 dark:bg-card dark:text-card-foreground dark:hover:bg-card/80; /* Use card bg for inactive dark */
  }
  .product-card {
    @apply relative overflow-hidden rounded-xl transition-all duration-300 hover:shadow-lg;
  }
  .product-card img {
    @apply object-cover transition-transform duration-500 hover:scale-105;
  }
  .btn-floating {
    @apply flex h-10 w-10 items-center justify-center rounded-full shadow transition-all duration-300;
  }
  .glass {
    @apply bg-white/10 backdrop-blur-lg border border-white/20 dark:bg-black/20 dark:border-white/10;
  }
  .glassmorphism {
    @apply bg-white/10 backdrop-blur-lg border border-white/20 dark:bg-black/20 dark:border-white/10;
  }
  .active-nav-item {
    @apply relative;
  }
  .active-nav-item::after {
    @apply content-[''] absolute -bottom-1 left-1/2 transform -translate-x-1/2 w-1.5 h-1.5 bg-primary rounded-full dark:bg-marian-blue; /* Use marian-blue for active dark */
  }
}
@layer utilities {
  .no-scrollbar::-webkit-scrollbar {
    display: none;
  }
  .no-scrollbar {
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
  }
  .text-shadow {
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  }
  .text-glow {
    text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
  }
}
/* Animation classes */
.fade-enter {
  opacity: 0;
}
.fade-enter-active {
  opacity: 1;
  transition: opacity 300ms ease-in;
}
.fade-exit {
  opacity: 1;
}
.fade-exit-active {
  opacity: 0;
  transition: opacity 300ms ease-out;
}
.page-transition-enter {
  opacity: 0;
  transform: translateY(10px);
}
.page-transition-enter-active {
  opacity: 1;
  transform: translateY(0);
  transition: opacity 300ms, transform 300ms;
}
.page-transition-exit {
  opacity: 1;
  transform: translateY(0);
}
.page-transition-exit-active {
  opacity: 0;
  transform: translateY(-10px);
  transition: opacity 300ms, transform 300ms;
}
/* Custom scrollbar */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}
::-webkit-scrollbar-track {
  @apply bg-transparent;
}
::-webkit-scrollbar-thumb {
  @apply bg-muted-foreground/30 rounded-full hover:bg-muted-foreground/50;
}
</file>

<file path="src/main.tsx.backup">
import React from 'react';
import ReactDOM from 'react-dom/client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ThemeProvider } from 'next-themes';
import App from './App';
import './index.css';

// Create a new client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 1,
      staleTime: 1000 * 60 * 5, // 5 minutes
    },
  },
});

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ThemeProvider attribute="class" defaultTheme="light">
      <QueryClientProvider client={queryClient}>
        <App />
      </QueryClientProvider>
    </ThemeProvider>
  </React.StrictMode>,
);
</file>

<file path="src/main.tsx.new">
import React from 'react';
import ReactDOM from 'react-dom/client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

import App from './App';
import './index.css';

// Create a new client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 1,
      staleTime: 1000 * 60 * 5, // 5 minutes
    },
  },
});

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    
      <QueryClientProvider client={queryClient}>
        <App />
      </QueryClientProvider>
    
  </React.StrictMode>,
);
</file>

<file path="src/seed.js">
#!/usr/bin/env node
// Simple script to run the seed-data.js file
import { main } from './seed-data.js';
console.log('Starting the seeding process...');
main().catch(error => {
  console.error('Error during seeding:', error);
  process.exit(1);
});
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path=".replit">
modules = ["nodejs-20", "web"]
run = "npm run dev"

[nix]
channel = "stable-24_05"

[deployment]
run = ["sh", "-c", "npm run dev"]

[[ports]]
localPort = 8080
externalPort = 80

[[ports]]
localPort = 8081
externalPort = 8081
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/index.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
</file>

<file path="deploy-customer.sh">
#!/bin/bash
# Set error handling
set -e
# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'
# Logger functions
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}
error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR:${NC} $1"
    exit 1
}
# Check if running with sudo
if [ "$EUID" -ne 0 ]; then
    error "Please run the script with sudo"
fi
# Configuration
SOURCE_DIR="$(pwd)"
DEST_DIR="/var/www/inseat-customer"
BACKUP_DIR="/var/www/inseat-customer.backup.$(date +%Y%m%d_%H%M%S)"
# Start deployment
log "Starting deployment process..."
# Install dependencies and build
log "Installing dependencies..."
npm install || error "Failed to install dependencies"
log "Building project..."
npm run build || error "Build failed"
# Create backup of existing deployment
if [ -d "$DEST_DIR" ]; then
    log "Creating backup of existing deployment..."
    mv "$DEST_DIR" "$BACKUP_DIR" || error "Failed to create backup"
fi
# Create destination directory if it doesn't exist
log "Creating destination directory..."
mkdir -p "$DEST_DIR" || error "Failed to create destination directory"
# Copy files
log "Copying built files to destination..."
cp -r dist/* "$DEST_DIR/" || error "Failed to copy files"
# Set correct ownership and permissions
log "Setting correct permissions..."
chown -R www-data:www-data "$DEST_DIR" || error "Failed to set ownership"
chmod -R 755 "$DEST_DIR" || error "Failed to set permissions"
log "Deployment completed successfully!"
log "Files deployed to: $DEST_DIR"
# Optional: Remove backup if everything went well
read -p "Remove backup directory? (y/n) " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    rm -rf "$BACKUP_DIR" && log "Backup removed" || error "Failed to remove backup"
fi
</file>

<file path="deployment.md">
# INSEAT Customer Application Deployment Guide

This document outlines the complete deployment process for the INSEAT customer application.

## Initial Deployment

### 1. Clone the Repository
```bash
# Navigate to your project directory
cd /home/administrator/Desktop/Project

# Clone using SSH (requires SSH key setup with GitHub)
git clone git@github.com:Achievengine/INSEAT-customer.git inseat-customer
cd inseat-customer
```

### 2. Install Dependencies and Build
```bash
# Install all dependencies (including axios which is required)
npm install
npm install axios  # If not included in package.json

# Build the application
npm run build
```

### 3. Deploy to Web Server
```bash
# Create directory if it doesn't exist
sudo mkdir -p /var/www/inseat-customer

# Copy built files
sudo cp -r dist/* /var/www/inseat-customer/

# Set proper ownership
sudo chown -R www-data:www-data /var/www/inseat-customer
```

### 4. Caddy Server Configuration
```bash
# Backup existing Caddyfile
sudo cp /etc/caddy/Caddyfile /etc/caddy/Caddyfile.backup

# Add new server block to Caddyfile
sudo vim /etc/caddy/Caddyfile

# Add the following configuration:
menu.inseat.achievengine.com {
    root * /var/www/inseat-customer
    encode gzip
    try_files {path} /index.html
    
    log {
        output file /var/log/caddy/inseat-customer.log
    }
    
    file_server
}

# Reload Caddy
sudo systemctl reload caddy
```

## Updating the Application

When updates are needed, follow these steps:

1. Navigate to the project directory:
```bash
cd /home/administrator/Desktop/Project/inseat-customer
```

2. Pull the latest changes:
```bash
git pull origin main  # or your deployment branch
```

3. Install dependencies (if package.json changed):
```bash
npm install
```

4. Build the application:
```bash
npm run build
```

5. Deploy updates:
```bash
sudo cp -r dist/* /var/www/inseat-customer/
sudo chown -R www-data:www-data /var/www/inseat-customer
```

## Verification

After deployment or updates:
1. Visit https://menu.inseat.achievengine.com
2. Verify that all routes work correctly
3. Check logs for any errors:
```bash
tail -f /var/log/caddy/inseat-customer.log
```

## Troubleshooting

### Common Issues and Solutions:

1. If Caddy fails to reload:
```bash
# Check Caddy status
sudo systemctl status caddy
# Check Caddy logs
journalctl -u caddy
```

2. If the application is not accessible:
- Verify the domain DNS settings
- Check firewall rules
- Ensure Caddy is running
- Verify file permissions in /var/www/inseat-customer

3. If build fails:
- Clear npm cache: `npm cache clean --force`
- Delete node_modules and package-lock.json
- Run `npm install` again

### Rollback Procedure

If you need to rollback the Caddy configuration:
```bash
sudo cp /etc/caddy/Caddyfile.backup /etc/caddy/Caddyfile
sudo systemctl reload caddy
```

## Security Notes

- Always maintain proper file permissions
- Keep npm packages updated
- Regularly check for security updates
- Monitor application logs for suspicious activity
</file>

<file path="eslint.config.js">
import js from "@eslint/js";
import globals from "globals";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import tseslint from "typescript-eslint";
export default tseslint.config(
  { ignores: ["dist"] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ["**/*.{ts,tsx}"],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      "react-hooks": reactHooks,
      "react-refresh": reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      "react-refresh/only-export-components": [
        "warn",
        { allowConstantExport: true },
      ],
      "@typescript-eslint/no-unused-vars": "off",
    },
  }
);
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>INSEAT</title>
    <meta name="description" content="Lovable Generated Project" />
    <meta name="author" content="Lovable" />
    <meta property="og:image" content="/og-image.png" />
  </head>
  <body>
    <div id="root"></div>
    <!-- IMPORTANT: DO NOT REMOVE THIS SCRIPT TAG OR THIS VERY COMMENT! -->
    <script src="https://cdn.gpteng.co/gptengineer.js" type="module"></script>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="package.json.backup">
{
  "name": "vite_react_shadcn_ts",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:dev": "vite build --mode development",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@headlessui/react": "^2.2.0",
    "@hookform/resolvers": "^3.9.0",
    "@radix-ui/react-accordion": "^1.2.0",
    "@radix-ui/react-alert-dialog": "^1.1.1",
    "@radix-ui/react-aspect-ratio": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.0",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-collapsible": "^1.1.0",
    "@radix-ui/react-context-menu": "^2.2.1",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-hover-card": "^1.1.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-menubar": "^1.1.1",
    "@radix-ui/react-navigation-menu": "^1.2.0",
    "@radix-ui/react-popover": "^1.1.1",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-radio-group": "^1.2.0",
    "@radix-ui/react-scroll-area": "^1.1.0",
    "@radix-ui/react-select": "^2.1.1",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slider": "^1.2.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.0",
    "@radix-ui/react-tabs": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.1",
    "@radix-ui/react-toggle": "^1.1.0",
    "@radix-ui/react-toggle-group": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.4",
    "@tanstack/react-query": "^5.56.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "date-fns": "^3.6.0",
    "embla-carousel-autoplay": "^8.5.2",
    "embla-carousel-react": "^8.3.0",
    "framer-motion": "^12.6.3",
    "input-otp": "^1.2.4",
    "lucide-react": "^0.462.0",
    "next-themes": "^0.4.6",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.53.0",
    "react-resizable-panels": "^2.1.3",
    "react-router-dom": "^6.26.2",
    "recharts": "^2.12.7",
    "sonner": "^1.5.0",
    "tailwind-merge": "^2.5.2",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^0.9.3",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.0",
    "@tailwindcss/typography": "^0.5.15",
    "@types/node": "^22.5.5",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react-swc": "^3.5.0",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.9.0",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.9",
    "globals": "^15.9.0",
    "lovable-tagger": "^1.1.7",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.11",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.0.1",
    "vite": "^5.4.1"
  }
}
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="README.md">
# InSeat Menu Application

This is a menu application for the InSeat platform, allowing customers to browse and order food and drinks.

## Prerequisites

- Node.js 16+ and npm
- MongoDB running locally or a connection to a MongoDB instance

## Setup

1. Clone the repository
2. Install dependencies
```bash
npm install
```
3. Create a `.env` file with the following variables:
```
MONGO_URL=mongodb://localhost:27017/inseat
```

## Development

Run the development server:
```bash
npm run dev
```

## Seeding the Database

To populate your database with categories, subcategories, and menu items, run the seed script:
```bash
npm run seed
```

This will:
1. Connect to your MongoDB database
2. Create 8 categories (Food, Drinks, Wine, Cocktails, etc.)
3. Create subcategories for each category
4. Create menu items for each subcategory

If you need to customize the seed data, edit the `src/seed-data.js` file.

## Building for Production

```bash
npm run build
```

## Scripts

- `npm run dev` - Start development server
- `npm run build` - Build for production
- `npm run preview` - Preview production build
- `npm run lint` - Run ESLint
- `npm run seed` - Seed the database with sample data

# Welcome to your Lovable project

## Project info

**URL**: https://lovable.dev/projects/86a93476-b505-4394-a35e-278a8e1c7dbb

## How can I edit this code???

There are several ways of editing your application.

**Use Lovable**

Simply visit the [Lovable Project](https://lovable.dev/projects/86a93476-b505-4394-a35e-278a8e1c7dbb) and start prompting.

Changes made via Lovable will be committed automatically to this repo.

**Use your preferred IDE**

If you want to work locally using your own IDE, you can clone this repo and push changes. Pushed changes will also be reflected in Lovable.

The only requirement is having Node.js & npm installed - [install with nvm](https://github.com/nvm-sh/nvm#installing-and-updating)

Follow these steps:

```sh
# Step 1: Clone the repository using the project's Git URL.
git clone <YOUR_GIT_URL>

# Step 2: Navigate to the project directory.
cd <YOUR_PROJECT_NAME>

# Step 3: Install the necessary dependencies.
npm i

# Step 4: Start the development server with auto-reloading and an instant preview.
npm run dev
```

**Edit a file directly in GitHub**

- Navigate to the desired file(s).
- Click the "Edit" button (pencil icon) at the top right of the file view.
- Make your changes and commit the changes.

**Use GitHub Codespaces**

- Navigate to the main page of your repository.
- Click on the "Code" button (green button) near the top right.
- Select the "Codespaces" tab.
- Click on "New codespace" to launch a new Codespace environment.
- Edit files directly within the Codespace and commit and push your changes once you're done.

## What technologies are used for this project?

This project is built with .

- Vite
- TypeScript
- React
- shadcn-ui
- Tailwind CSS
- other libraries

## How can I deploy this project?

Simply open [Lovable](https://lovable.dev/projects/86a93476-b505-4394-a35e-278a8e1c7dbb) and click on Share -> Publish.

## I want to use a custom domain - is that possible?

We don't support custom domains (yet). If you want to deploy your project under your own domain then we recommend using Netlify. Visit our docs for more details: [Custom domains](https://docs.lovable.dev/tips-tricks/custom-domain/)
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";
export default {
	darkMode: ["class"],
	content: [
		"./pages/**/*.{ts,tsx}",
		"./components/**/*.{ts,tsx}",
		"./app/**/*.{ts,tsx}",
		"./src/**/*.{ts,tsx}",
	],
	prefix: "",
	theme: {
		container: {
			center: true,
			padding: '2rem',
			screens: {
				'2xl': '1400px'
			}
		},
		extend: {
			colors: {
				border: 'hsl(var(--border))',
				input: 'hsl(var(--input))',
				ring: 'hsl(var(--ring))',
				background: 'hsl(var(--background))',
				foreground: 'hsl(var(--foreground))',
				primary: {
					DEFAULT: 'hsl(var(--primary))',
					foreground: 'hsl(var(--primary-foreground))'
				},
				secondary: {
					DEFAULT: 'hsl(var(--secondary))',
					foreground: 'hsl(var(--secondary-foreground))'
				},
				destructive: {
					DEFAULT: 'hsl(var(--destructive))',
					foreground: 'hsl(var(--destructive-foreground))'
				},
				muted: {
					DEFAULT: 'hsl(var(--muted))',
					foreground: 'hsl(var(--muted-foreground))'
				},
				accent: {
					DEFAULT: 'hsl(var(--accent))',
					foreground: 'hsl(var(--accent-foreground))'
				},
				popover: {
					DEFAULT: 'hsl(var(--popover))',
					foreground: 'hsl(var(--popover-foreground))'
				},
				card: {
					DEFAULT: 'hsl(var(--card))',
					foreground: 'hsl(var(--card-foreground))'
				},
				sidebar: {
					DEFAULT: 'hsl(var(--sidebar-background))',
					foreground: 'hsl(var(--sidebar-foreground))',
					primary: 'hsl(var(--sidebar-primary))',
					'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
					accent: 'hsl(var(--sidebar-accent))',
					'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
					border: 'hsl(var(--sidebar-border))',
					ring: 'hsl(var(--sidebar-ring))'
				},
				        'raisin-black': '#1E1F23',
				        'night': '#0B0C0E',
				        'delft-blue': '#3A3A61',
				        'marian-blue': '#464587',
				        'white': '#FFFFFF', // Keep white for text/icons
			},
			borderRadius: {
				lg: 'var(--radius)',
				md: 'calc(var(--radius) - 2px)',
				sm: 'calc(var(--radius) - 4px)'
			},
			keyframes: {
				'accordion-down': {
					from: { height: '0' },
					to: { height: 'var(--radix-accordion-content-height)' }
				},
				'accordion-up': {
					from: { height: 'var(--radix-accordion-content-height)' },
					to: { height: '0' }
				},
				'fade-in': {
					from: { opacity: '0' },
					to: { opacity: '1' }
				},
				'fade-out': {
					from: { opacity: '1' },
					to: { opacity: '0' }
				},
				'slide-up': {
					from: { transform: 'translateY(10px)', opacity: '0' },
					to: { transform: 'translateY(0)', opacity: '1' }
				},
				'slide-down': {
					from: { transform: 'translateY(-10px)', opacity: '0' },
					to: { transform: 'translateY(0)', opacity: '1' }
				},
				float: {
					'0%, 100%': { transform: 'translateY(0)' },
					'50%': { transform: 'translateY(-5px)' }
				},
				pulse: {
					'0%, 100%': { opacity: '1' },
					'50%': { opacity: '0.8' }
				}
			},
			animation: {
				'accordion-down': 'accordion-down 0.2s ease-out',
				'accordion-up': 'accordion-up 0.2s ease-out',
				'fade-in': 'fade-in 0.3s ease-out',
				'fade-out': 'fade-out 0.3s ease-out',
				'slide-up': 'slide-up 0.4s ease-out',
				'slide-down': 'slide-down 0.4s ease-out',
				'float': 'float 3s ease-in-out infinite',
				'pulse': 'pulse 2s ease-in-out infinite'
			}
		}
	},
	plugins: [require("tailwindcss-animate")],
} satisfies Config;
</file>

<file path="test-orders.js">
// This script will simulate a basic environment for testing OrderService
// Mock localStorage for Node.js environment
const localStorageMock = (() => {
  let store = {};
  return {
    getItem: (key) => store[key] || null,
    setItem: (key, value) => {
      store[key] = value.toString();
    },
    removeItem: (key) => {
      delete store[key];
    },
    clear: () => {
      store = {};
    }
  };
})();
// Assign localStorage to global
global.localStorage = localStorageMock;
// Mock the toast notification
global.toast = {
  success: (msg) => console.log(`SUCCESS TOAST: ${msg}`),
  error: (msg) => console.log(`ERROR TOAST: ${msg}`)
};
// Types for our tests
const OrderStatus = {
  PENDING: 'pending',
  PREPARING: 'preparing',
  READY: 'ready',
  DELIVERED: 'delivered',
  COMPLETED: 'completed',
  CANCELLED: 'cancelled'
};
// Helper to log results in a formatted way
const logResult = (title, data) => {
  console.log('\n====================');
  console.log(title);
  console.log('====================');
  console.log(JSON.stringify(data, null, 2));
};
// Simulate API delay
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
// OrderService implementation
const OrderService = {
  // Create a new order
  createOrder: async (items, tableNumber) => {
    await delay(300); // Shorter delay for testing
    // Calculate order details
    const subtotal = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
    const tax = subtotal * 0.15; // Assuming 15% tax
    const total = subtotal + tax;
    // Create order object
    const order = {
      id: 'order-' + Date.now(),
      items: [...items],
      subtotal,
      tax,
      total,
      status: 'preparing',
      timestamp: new Date(),
      tableNumber
    };
    // Save to localStorage
    const existingOrdersString = localStorage.getItem('orders');
    const existingOrders = existingOrdersString ? JSON.parse(existingOrdersString) : [];
    localStorage.setItem('orders', JSON.stringify([order, ...existingOrders]));
    toast.success('Order placed successfully!');
    return order;
  },
  // Get all orders
  getOrders: async () => {
    await delay(200); // Shorter delay for testing
    const ordersString = localStorage.getItem('orders');
    return ordersString ? JSON.parse(ordersString) : [];
  },
  // Get order by ID
  getOrderById: async (orderId) => {
    await delay(200); // Shorter delay for testing
    const ordersString = localStorage.getItem('orders');
    const orders = ordersString ? JSON.parse(ordersString) : [];
    const order = orders.find(order => order.id === orderId);
    return order || null;
  },
  // Update order status
  updateOrderStatus: async (orderId, status) => {
    await delay(200); // Shorter delay for testing
    // Get orders from localStorage
    const ordersString = localStorage.getItem('orders');
    const orders = ordersString ? JSON.parse(ordersString) : [];
    // Find and update the order
    const updatedOrders = orders.map(order => {
      if (order.id === orderId) {
        return { ...order, status };
      }
      return order;
    });
    // Save updated orders
    localStorage.setItem('orders', JSON.stringify(updatedOrders));
    // Return the updated order
    const updatedOrder = updatedOrders.find(order => order.id === orderId);
    return updatedOrder || null;
  },
  // Cancel an order
  cancelOrder: async (orderId) => {
    await delay(200); // Shorter delay for testing
    // Get orders from localStorage
    const ordersString = localStorage.getItem('orders');
    const orders = ordersString ? JSON.parse(ordersString) : [];
    // Remove the order
    const updatedOrders = orders.filter(order => order.id !== orderId);
    // Check if any order was removed
    if (updatedOrders.length === orders.length) {
      toast.error('Order not found');
      return false;
    }
    // Save updated orders
    localStorage.setItem('orders', JSON.stringify(updatedOrders));
    toast.success('Order cancelled successfully');
    return true;
  },
  // Get active orders (preparing or ready status)
  getActiveOrders: async () => {
    await delay(200); // Shorter delay for testing
    const ordersString = localStorage.getItem('orders');
    const orders = ordersString ? JSON.parse(ordersString) : [];
    return orders.filter(order => 
      order.status === 'preparing' || order.status === 'ready'
    );
  },
  // Get completed orders (delivered or completed status)
  getCompletedOrders: async () => {
    await delay(200); // Shorter delay for testing
    const ordersString = localStorage.getItem('orders');
    const orders = ordersString ? JSON.parse(ordersString) : [];
    return orders.filter(order => 
      order.status === 'delivered' || order.status === 'completed'
    );
  }
};
// Run tests
const runTests = async () => {
  try {
    console.log('Starting OrderService tests...');
    // Clear localStorage first to start fresh
    localStorage.clear();
    // TEST 1: Create an order
    console.log('\nTEST 1: Creating a new order...');
    const cartItems = [
      {
        id: 'cart-item-1',
        menuItemId: '1',
        name: 'Dal Makhani',
        price: 30.00,
        quantity: 2,
        image: '/placeholder.svg',
        modifiers: [
          { id: 'mod1', name: 'Extra Spicy', price: 1.00 }
        ]
      },
      {
        id: 'cart-item-2',
        menuItemId: '2',
        name: 'Classic Cheeseburger',
        price: 12.99,
        quantity: 1,
        image: '/placeholder.svg'
      }
    ];
    const tableNumber = "12";
    const createdOrder = await OrderService.createOrder(cartItems, tableNumber);
    logResult('Created Order', createdOrder);
    // TEST 2: Get all orders
    console.log('\nTEST 2: Getting all orders...');
    const allOrders = await OrderService.getOrders();
    logResult('All Orders', allOrders);
    // TEST 3: Get order by ID
    console.log('\nTEST 3: Getting order by ID...');
    const orderId = createdOrder.id;
    const retrievedOrder = await OrderService.getOrderById(orderId);
    logResult('Retrieved Order', retrievedOrder);
    // TEST 4: Update order status
    console.log('\nTEST 4: Updating order status...');
    const updatedOrder = await OrderService.updateOrderStatus(orderId, OrderStatus.READY);
    logResult('Updated Order', updatedOrder);
    // TEST 5: Get active orders
    console.log('\nTEST 5: Getting active orders...');
    const activeOrders = await OrderService.getActiveOrders();
    logResult('Active Orders', activeOrders);
    // TEST 6: Create another order
    console.log('\nTEST 6: Creating another order...');
    const moreCartItems = [
      {
        id: 'cart-item-3',
        menuItemId: '6',
        name: 'Spaghetti Carbonara',
        price: 16.99,
        quantity: 1,
        image: '/placeholder.svg'
      }
    ];
    const anotherOrder = await OrderService.createOrder(moreCartItems, tableNumber);
    logResult('Another Order', anotherOrder);
    // TEST 7: Complete an order
    console.log('\nTEST 7: Completing an order...');
    const completedOrder = await OrderService.updateOrderStatus(orderId, OrderStatus.COMPLETED);
    logResult('Completed Order', completedOrder);
    // TEST 8: Get completed orders
    console.log('\nTEST 8: Getting completed orders...');
    const completedOrders = await OrderService.getCompletedOrders();
    logResult('Completed Orders', completedOrders);
    // TEST 9: Cancel an order
    console.log('\nTEST 9: Cancelling an order...');
    const cancelResult = await OrderService.cancelOrder(anotherOrder.id);
    logResult('Cancel Result', cancelResult);
    // TEST 10: Verify orders after cancellation
    console.log('\nTEST 10: Getting all orders after cancellation...');
    const remainingOrders = await OrderService.getOrders();
    logResult('Remaining Orders', remainingOrders);
    console.log('\nAll tests completed successfully!');
  } catch (error) {
    console.error('Error during tests:', error);
  }
};
// Run the tests
runTests();
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitAny": false,
    "noFallthroughCasesInSwitch": false,

    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "noImplicitAny": false,
    "noUnusedParameters": false,
    "skipLibCheck": true,
    "allowJs": true,
    "noUnusedLocals": false,
    "strictNullChecks": false
  }
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="docs/backend-enhancements.md">
# Backend API Enhancements Required for Menu Integration

## Overview

This document outlines the backend API changes necessary to support the enhanced menu UI with real category images, subcategory counts, and proper venue/table display in the navigation header.

## Required Endpoint Updates

### 1. Table Verification Endpoint

**Endpoint:** `GET /api/tables/{tableId}/verify`

Ensure this endpoint returns complete data including:
- Full table details (number, capacity, status)
- Comprehensive venue information
- Relationships between entities

Example response:
```json
{
  "exists": true,
  "isAvailable": true,
  "table": {
    "_id": "t123456",
    "number": "A12",
    "capacity": 4,
    "isOccupied": false,
    "isActive": true,
    "venueId": "v789012"
  },
  "venue": {
    "_id": "v789012",
    "name": "Main Dining Room",
    "description": "Our elegant main dining area with garden views",
    "restaurantId": "r345678"
  }
}
```

### 2. Menu Endpoint with Full Population

**Endpoint:** `GET /api/menus?venueId={venueId}&populate=true`

Add a `populate` parameter that enhances the response with:
- Real category images (not placeholders)
- Subcategory counts for each category
- Subsubcategory counts for advanced classification
- Full hierarchical relationships between categories, subcategories, and subsubcategories

Example response:
```json
{
  "_id": "m123456",
  "name": "Lunch Menu",
  "description": "Available 11am-3pm daily",
  "venueId": {
    "_id": "v789012",
    "name": "Main Dining Room"
  },
  "categories": [
    {
      "_id": "c111111",
      "name": "Appetizers",
      "description": "Small plates to start your meal",
      "image": "/images/categories/appetizers.jpg",
      "subCategories": ["sc222222", "sc333333"],
      "subCategoryCount": 2,
      "totalSubSubCategoryCount": 5,
      "isActive": true
    }
  ],
  "subCategories": [
    {
      "_id": "sc222222",
      "name": "Hot Appetizers",
      "description": "Served warm",
      "image": "/images/subcategories/hot-appetizers.jpg",
      "categoryId": "c111111",
      "subSubCategories": ["ssc444444", "ssc555555"],
      "isActive": true
    }
  ]
}
```

## Data Requirements

### 1. Category Images
- All categories must have real, high-quality images
- Images should be properly sized and optimized (recommended: 800x600px, <200KB)
- Provide a default image for any category missing a custom image

### 2. Subcategory Structure
- Each category must have an accurate count of its subcategories
- Each subcategory must have an accurate count of its subsubcategories
- Consistent naming and hierarchy must be maintained

### 3. Venue and Table Information
- Venue names should be properly formatted for display in the header
- Table numbers should be user-friendly (e.g., "12" not "TABLE_12_ID")
- Ensure all venue and table data is up-to-date

## Implementation Guidelines

1. Update database schema to support new fields if necessary
2. Modify the existing API endpoints to include the additional data
3. Ensure proper error handling for missing or invalid data
4. Optimize query performance for the enhanced responses
5. Add appropriate caching mechanisms for frequently accessed data

## Testing Endpoints

To test your implementation, you can use the following curl commands:

```bash
# Test table verification
curl -X GET http://localhost:3001/api/tables/[TABLE_ID]/verify

# Test menu retrieval with full population
curl -X GET http://localhost:3001/api/menus?venueId=[VENUE_ID]&populate=true
```

Please contact the frontend team if you have any questions about these requirements.
</file>

<file path="docs/menu-integration-summary.md">
# Menu Integration Implementation Summary

## Overview

We have implemented comprehensive UI enhancements for the INSEAT menu application, focusing on:

1. Displaying real category images instead of dummy placeholders
2. Showing venue name on the left edge and table name in the center of the navbar
3. Adding accurate subcategory and subsubcategory counts to the category display

## Files Modified

1. **Type Definitions**
   - `src/types/menu.ts`: Added comprehensive types for categories, subcategories, venue, and table information

2. **UI Components**
   - `src/components/TableHeader.tsx`: Updated to display venue and table information in the specified locations
   - `src/components/CategoryGrid.tsx`: Enhanced to show real images and subcategory counts with proper error handling

3. **Page Components**
   - `src/pages/Index.tsx`: Updated to properly fetch and pass venue/table information and process enhanced category data

4. **Testing**
   - `src/components/TableHeaderTest.tsx`: Created a test component to verify TableHeader functionality
   - `src/tests/menu-integration.test.tsx`: Added comprehensive tests for all the new features
   - Updated routing in `App.tsx` to include a test route

5. **Documentation**
   - `docs/backend-enhancements.md`: Documented backend API requirements
   - `docs/table-menu-integration-guide.md`: Created guide for using and testing the implementation
   - `README-menu-integration.md`: Added developer documentation
   - Updated main `README.md` with feature information

## API Enhancements

The implementation requires backend API changes to:

1. Include real category images in the menu response
2. Add subcategory and subsubcategory count information
3. Return complete venue and table information in the table verification response

## Testing

The implementation can be tested using:

1. Manual testing via the `/test/header` route with the TableHeaderTest component
2. Automated tests in `src/tests/menu-integration.test.tsx`
3. Real-world testing with actual table QR codes and API data

## Future Improvements

Potential areas for future enhancements:

1. More customization options for the TableHeader (colors, branding)
2. Enhanced image loading performance with lazy loading and caching
3. Better accessibility features for venue and table information
4. Extended test coverage for edge cases and different viewport sizes

This implementation successfully addresses all the requirements while maintaining good code quality, performance, and user experience.
</file>

<file path="docs/order-api-tests.md">
# Order API Test Requests

## Create Order (First User - Maggy)
```bash
curl -v -X POST http://localhost:3001/api/orders \
-H "Content-Type: application/json" \
-H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY4MzZlMzM0NWNjYWIxMmJlMDYxNmRhNyIsImVtYWlsIjoiZ29tZXBleGlnQG1haWxpbmF0b3IuY29tIiwicm9sZSI6ImN1c3RvbWVyIiwiaWF0IjoxNzQ4NDI3NTk5LCJleHAiOjE3NDg1MTM5OTl9.1zXH93UEjiFJaHsbjYAU4fPexJBR5z73kIeNsHo_uGg" \
-d '{
  "restaurantId": "65f456b06c9dfd001b6b1234",
  "tableId": "681a58401a12c59b214b39df",
  "items": [{
    "menuItem": "681a58901a12c59b214b3cac",
    "name": "Chocolate Drizzle Popcorn",
    "quantity": 1,
    "price": 30,
    "subtotal": 30,
    "specialInstructions": ""
  }],
  "subtotal": 30,
  "tax": 2.4,
  "tip": 0,
  "total": 33.9,
  "orderType": "DINE_IN",
  "specialInstructions": "",
  "serviceFee": 1.5,
  "status": "PENDING",
  "paymentStatus": "PENDING",
  "orderNumber": "ORD-1748427583808-158",
  "userId": "6836e3345ccab12be0616da7"
}'
```

## Register New User (Test User)
```bash
curl -v -X POST http://localhost:3001/api/customer/register \
-H "Content-Type: application/json" \
-d '{
  "email": "testuser@mailinator.com",
  "password": "Test123!@#",
  "firstName": "Test",
  "lastName": "User"
}'
```

## Create Order (Second User - Test User)
```bash
curl -v -X POST http://localhost:3001/api/orders \
-H "Content-Type: application/json" \
-H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY4MzZlOTY3NWNjYWIxMmJlMDYxNmRkOCIsImVtYWlsIjoidGVzdHVzZXJAbWFpbGluYXRvci5jb20iLCJyb2xlIjoiY3VzdG9tZXIiLCJpYXQiOjE3NDg0MjkxNTksImV4cCI6MTc0ODUxNTU1OX0.ECfJFTciMFOzJigJIuFFlz_KlvIl85RDjVC2IAOH8qA" \
-d '{
  "restaurantId": "65f456b06c9dfd001b6b1234",
  "tableId": "681a58401a12c59b214b39df",
  "items": [{
    "menuItem": "681a58901a12c59b214b3cac",
    "name": "Chocolate Drizzle Popcorn",
    "quantity": 2,
    "price": 30,
    "subtotal": 60,
    "specialInstructions": ""
  }],
  "subtotal": 60,
  "tax": 4.8,
  "tip": 0,
  "total": 67.8,
  "orderType": "DINE_IN",
  "specialInstructions": "",
  "serviceFee": 3.0,
  "status": "PENDING",
  "paymentStatus": "PENDING",
  "orderNumber": "ORD-1748429159-123",
  "userId": "6836e9675ccab12be0616dd8"
}'
```

## Get My Orders (First User - Maggy)
```bash
curl -v http://localhost:3001/api/orders/my-orders \
-H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY4MzZlMzM0NWNjYWIxMmJlMDYxNmRhNyIsImVtYWlsIjoiZ29tZXBleGlnQG1haWxpbmF0b3IuY29tIiwicm9sZSI6ImN1c3RvbWVyIiwiaWF0IjoxNzQ4NDI3NTk5LCJleHAiOjE3NDg1MTM5OTl9.1zXH93UEjiFJaHsbjYAU4fPexJBR5z73kIeNsHo_uGg"
```

## Get My Orders (Second User - Test User)
```bash
curl -v http://localhost:3001/api/orders/my-orders \
-H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY4MzZlOTY3NWNjYWIxMmJlMDYxNmRkOCIsImVtYWlsIjoidGVzdHVzZXJAbWFpbGluYXRvci5jb20iLCJyb2xlIjoiY3VzdG9tZXIiLCJpYXQiOjE3NDg0MjkxNTksImV4cCI6MTc0ODUxNTU1OX0.ECfJFTciMFOzJigJIuFFlz_KlvIl85RDjVC2IAOH8qA"
```

## Test Results Summary

### First User (Maggy)
- Successfully created order (ID: 6836e8fb5ccab12be0616dc0)
- Can view only their own order
- Order total: $33.90 (1 item)

### Second User (Test User)
- Successfully registered
- Successfully created order (ID: 6836e97d5ccab12be0616dda)
- Can view only their own order
- Order total: $67.80 (2 items)

### Notes
- Authentication working correctly
- Order filtering by user working correctly
- Minor issue: restaurantId returns null in responses


## Required Fields
For creating orders, the following fields are required:
- restaurantId
- tableId
- items (array with at least one item)
- status
- paymentStatus
- orderNumber

## Authentication
- Bearer token required for all order endpoints
- Token format: `Bearer <jwt_token>`
- Token contains user ID and role
- Tokens expire after 24 hours

## Common HTTP Status Codes
- 201: Order created successfully
- 200: Orders retrieved successfully
- 401: Invalid or missing authentication
- 400: Missing required fields
- 500: Server error

## Sample Response (Create Order)
```json
{
  "_id": "6836e8fb5ccab12be0616dc0",
  "orderNumber": "250528-8261",
  "restaurantId": null,
  "tableId": {
    "_id": "681a58401a12c59b214b39df",
    "number": "V3T017",
    "fullName": "Venue-undefined - Table V3T017"
  },
  "userId": "6836e3345ccab12be0616da7",
  "items": [{
    "menuItem": "681a58901a12c59b214b3cac",
    "name": "Chocolate Drizzle Popcorn",
    "quantity": 1,
    "price": 30,
    "subtotal": 30
  }],
  "status": "PENDING",
  "paymentStatus": "PENDING",
  "total": 33.90
}
```

## Known Issues
1. restaurantId returns null in responses despite being sent in request
2. Order numbers are auto-generated by server, ignoring client-provided values
3. Table fullName includes "undefined" in response

## TODO
- [ ] Fix restaurantId being null in responses
- [ ] Handle table name formatting better
- [ ] Add pagination to my-orders endpoint
- [ ] Add filtering by date range
</file>

<file path="docs/table-menu-integration-guide.md">
# Table Menu Integration - Implementation Guide

This guide explains the changes made to implement the enhanced menu UI with real category images and proper venue/table display.

## Key Changes

### 1. Type Definitions (`src/types/menu.ts`)
- Added comprehensive types for `Category`, `SubCategory`, `SubSubCategory`
- Added `Venue` and `Table` types
- Enhanced the `MenuItem` interface with additional fields
- Created proper relationship types between all entities

### 2. TableHeader Component (`src/components/TableHeader.tsx`)
- Updated to display venue name on the left edge
- Modified to show table name in the center
- Improved responsive design for all screen sizes

### 3. CategoryGrid Component (`src/components/CategoryGrid.tsx`)
- Enhanced to display real category images
- Updated to show subcategory counts
- Added support for displaying subsubcategory counts where available

### 4. Index Page (`src/pages/Index.tsx`)
- Updated API integration to request and process enhanced category data
- Improved handling of venue and table information
- Enhanced error handling and loading states

## Testing the Implementation

1. **Test with Real Table QR Code:**
   - Scan a valid table QR code
   - Verify venue name appears on the left of the header
   - Confirm table name shows in the center
   
2. **Test with TableHeaderTest Component:**
   - Import and use the TableHeaderTest component in a development route
   - Try different venue and table name combinations
   - Test empty values and edge cases
   - Use the component controls to verify responsive behavior

2. **Test Category Display:**
   - Verify real category images are displayed (not placeholders)
   - Check that subcategory counts are accurate
   - Confirm subsubcategory counts appear where applicable

3. **Test Navigation:**
   - Click through categories to ensure proper navigation
   - Verify that subcategories load correctly
   - Test that menu items display properly within categories

## Known Limitations

- Default fallback image is used when a category has no assigned image
- Some API responses may require further enhancement from backend team
- The subcategory counting relies on the backend implementation of proper relationships
- Long venue names may be truncated on smaller screens (by design)
- The TableHeader has been tested on common device sizes but may need adjustments for unusual viewport dimensions

## Backend Requirements

Please see `backend-enhancements.md` for the complete list of required backend changes to support this implementation.

## Component Testing

### TableHeader Testing Instructions

To verify the TableHeader implementation:

1. Use the provided `TableHeaderTest` component:
   ```tsx
   import TableHeaderTest from '@/components/TableHeaderTest';
   
   // Add to a test route
   <Route path="/test-header" element={<TableHeaderTest />} />
   ```

2. Navigate to `/test-header` in your browser

3. Test different combinations:
   - Very long venue names to verify truncation
   - Empty venue or table values
   - Various table name formats

4. Verify proper responsiveness:
   - Test on mobile, tablet, and desktop viewports
   - Ensure content remains properly aligned and visible

## Contact

For questions about these changes, please contact the frontend team.
</file>

<file path="scripts/migrateMenuData.ts">
import fs from 'fs';
import path from 'path';
import { MenuItem } from '../src/types/menu';
import { 
  migrateMenuItemsToAPI,
  fetchAllMenuDataForUI,
  fetchCategories,
  fetchSubcategories
} from '../src/services/menuDataAdapter';
// Constants
const DATA_DIR = path.join(__dirname, '..', 'src', 'data');
const MENU_ITEMS_PATH = path.join(DATA_DIR, 'menu-items-complete-final.json');
const ID_MAPPINGS_PATH = path.join(DATA_DIR, 'api-id-mappings.json');
const API_CATEGORIES_PATH = path.join(DATA_DIR, 'api-categories.json');
const MIGRATION_RESULT_PATH = path.join(DATA_DIR, 'migration-result.json');
/**
 * Read menu items from JSON file
 */
function readMenuItems(): MenuItem[] {
  try {
    console.log(`Reading menu items from ${MENU_ITEMS_PATH}`);
    const data = fs.readFileSync(MENU_ITEMS_PATH, 'utf8');
    const jsonData = JSON.parse(data);
    if (!jsonData.items || !Array.isArray(jsonData.items)) {
      throw new Error('Invalid menu items data structure');
    }
    return jsonData.items;
  } catch (error) {
    console.error('Error reading menu items:', error);
    throw error;
  }
}
/**
 * Save data to a JSON file
 */
function saveJsonToFile(data: any, filePath: string): void {
  try {
    const dirPath = path.dirname(filePath);
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf8');
    console.log(`Data saved to ${filePath}`);
  } catch (error) {
    console.error(`Error saving data to ${filePath}:`, error);
    throw error;
  }
}
/**
 * Validate the migration by checking if all items are in the API
 */
async function validateMigration(idMappings: Record<string, string>): Promise<boolean> {
  try {
    console.log('Validating migration...');
    // Fetch all menu items from the API
    const menuItems = await fetchAllMenuDataForUI();
    // Check that all mapped IDs exist in the fetched data
    const apiIds = menuItems.map(item => item.id);
    const mappedIds = Object.values(idMappings);
    const missingIds = mappedIds.filter(id => !apiIds.includes(id));
    if (missingIds.length > 0) {
      console.error(`Migration validation failed. Missing IDs: ${missingIds.join(', ')}`);
      return false;
    }
    console.log(`Migration validated successfully. All ${mappedIds.length} items found in API.`);
    return true;
  } catch (error) {
    console.error('Error validating migration:', error);
    return false;
  }
}
/**
 * Fetch and save API category structure for reference
 */
async function fetchAndSaveCategoryStructure(): Promise<void> {
  try {
    console.log('Fetching category structure from API...');
    const categories = await fetchCategories();
    const categoryStructure: Record<string, any> = {};
    for (const category of categories) {
      const subcategories = await fetchSubcategories(category._id);
      categoryStructure[category._id] = {
        name: category.name,
        subcategories: subcategories.map(sub => ({
          _id: sub._id,
          name: sub.name
        }))
      };
    }
    saveJsonToFile(categoryStructure, API_CATEGORIES_PATH);
    console.log('Category structure saved successfully.');
  } catch (error) {
    console.error('Error fetching and saving category structure:', error);
  }
}
/**
 * Main migration function
 */
async function migrateMenuData(): Promise<void> {
  try {
    console.log('Starting menu data migration...');
    // Step 1: Read existing menu items
    const menuItems = readMenuItems();
    console.log(`Read ${menuItems.length} menu items`);
    // Step 2: Migrate menu items to API
    console.log('Migrating menu items to API...');
    const idMappings = await migrateMenuItemsToAPI(menuItems);
    console.log(`Migrated ${Object.keys(idMappings).length} menu items to API`);
    // Step 3: Save ID mappings for future reference
    saveJsonToFile(idMappings, ID_MAPPINGS_PATH);
    // Step 4: Fetch and save category structure
    await fetchAndSaveCategoryStructure();
    // Step 5: Validate the migration
    const isValid = await validateMigration(idMappings);
    // Step 6: Fetch the migrated data from API and save as reference
    const migratedItems = await fetchAllMenuDataForUI();
    saveJsonToFile({
      migrationDate: new Date().toISOString(),
      migrationSuccess: isValid,
      itemCount: migratedItems.length,
      items: migratedItems
    }, MIGRATION_RESULT_PATH);
    console.log(`Migration ${isValid ? 'completed successfully' : 'completed with validation issues'}`);
    console.log(`Migrated ${migratedItems.length} items`);
  } catch (error) {
    console.error('Migration failed:', error);
    process.exit(1);
  }
}
// Run the migration
migrateMenuData()
  .then(() => {
    console.log('Migration script completed');
    process.exit(0);
  })
  .catch((error) => {
    console.error('Unhandled error in migration script:', error);
    process.exit(1);
  });
</file>

<file path="src/api/__tests__/menuService.test.ts">
import axios from 'axios';
import {
  getTableMenu,
  getCategories,
  getSubcategories,
  getMenuItems,
  getVenueById,
  getVenueMenuItems,
  getFullMenuHierarchy,
  ApiError,
  VenueNotFoundError,
  TableNotFoundError
} from '../menuService';
import { transformMenuItem, transformCategory, transformRestaurant } from '../../utils/dataTransformers';
import { MenuItem as UiMenuItem } from '../../types/menu';
// Mock axios
jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;
describe('Menu Service', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });
  describe('getTableMenu', () => {
    it('should fetch and transform table menu data correctly', async () => {
      // Mock API response with realistic data structure
      const mockApiResponse = {
        data: {
          venue: {
            _id: 'venue1',
            name: 'CINEMA CITY ARABIAN CENTRE MAIN',
            description: 'Main dining venue'
          },
          menu: {
            categories: [{
              _id: 'cat1',
              name: 'Appetizers',
              description: 'Starter dishes',
              image: 'appetizers.jpg',
              isActive: true,
              order: 1,
              restaurantId: 'rest1'
            }],
            subcategories: {
              'cat1': [{
                _id: 'subcat1',
                name: 'Salads',
                description: 'Fresh salads',
                image: 'salads.jpg',
                isActive: true,
                order: 1,
                categoryId: 'cat1'
              }]
            },
            menuItems: [{
              _id: 'item1',
              name: 'Caesar Salad',
              description: 'Fresh romaine lettuce with Caesar dressing',
              price: 12.99,
              image: 'caesar.jpg',
              categories: ['cat1'],
              subCategories: ['subcat1'],
              isAvailable: true,
              isActive: true
            }]
          }
        }
      };
      mockedAxios.get.mockResolvedValueOnce(mockApiResponse);
      const result = await getTableMenu('table1');
      // Check the transformed category
      expect(result.categories).toHaveLength(1);
      expect(result.categories[0]).toEqual({
        id: 'cat1',
        name: 'Appetizers',
        description: 'Starter dishes',
        image: 'appetizers.jpg',
        restaurantId: 'rest1',
        order: 1
      });
      // Check the transformed menu item
      expect(result.menuItems).toHaveLength(1);
      expect(result.menuItems[0]).toEqual({
        id: 'item1',
        name: 'Caesar Salad',
        description: 'Fresh romaine lettuce with Caesar dressing',
        price: 12.99,
        image: 'caesar.jpg',
        imageSearchTerm: '',
        category: 'cat1',
        categoryId: 'cat1',
        subcategory: 'subcat1',
        featured: false,
        popular: false,
        tags: []
      });
      // Verify correct URL was called
      expect(mockedAxios.get).toHaveBeenCalledWith(
        expect.stringContaining('/tables/table1/menu')
      );
    });
    it('should handle table not found error', async () => {
      // Mock API error response
      mockedAxios.get.mockRejectedValueOnce({
        response: {
          status: 404,
          data: { error: 'Table not found' }
        }
      });
      // Expect the service to throw the appropriate error
      await expect(getTableMenu('invalid-table'))
        .rejects
        .toThrow(TableNotFoundError);
    });
    it('should handle server error', async () => {
      // Mock server error
      mockedAxios.get.mockRejectedValueOnce({
        response: {
          status: 500,
          data: { error: 'Internal server error' }
        }
      });
      // Expect the service to throw ApiError with correct status
      await expect(getTableMenu('table1'))
        .rejects
        .toThrow(ApiError);
    });
    it('should handle network error', async () => {
      // Mock network error
      mockedAxios.get.mockRejectedValueOnce({
        request: {},
        message: 'Network Error'
      });
      // Expect service to throw ApiError with no response message
      await expect(getTableMenu('table1'))
        .rejects
        .toThrow('No response received from server');
    });
  });
  describe('getCategories', () => {
    it('should fetch and transform categories correctly', async () => {
      // Mock API response
      const mockApiResponse = {
        data: [
          {
            _id: 'cat1',
            name: 'Appetizers',
            description: 'Starter dishes',
            image: 'appetizers.jpg',
            isActive: true,
            order: 1,
            restaurantId: 'rest1'
          },
          {
            _id: 'cat2',
            name: 'Main Courses',
            description: 'Main dishes',
            image: 'mains.jpg',
            isActive: true,
            order: 2,
            restaurantId: 'rest1'
          }
        ]
      };
      mockedAxios.get.mockResolvedValueOnce(mockApiResponse);
      const result = await getCategories();
      // Verify correct transformation and structure
      expect(result).toHaveLength(2);
      expect(result[0]).toEqual({
        id: 'cat1',
        name: 'Appetizers',
        description: 'Starter dishes',
        image: 'appetizers.jpg',
        restaurantId: 'rest1',
        order: 1
      });
      expect(result[1]).toEqual({
        id: 'cat2',
        name: 'Main Courses',
        description: 'Main dishes',
        image: 'mains.jpg',
        restaurantId: 'rest1',
        order: 2
      });
      // Verify correct URL was called
      expect(mockedAxios.get).toHaveBeenCalledWith(
        expect.stringContaining('/categories')
      );
    });
    it('should handle empty categories response', async () => {
      // Mock empty response
      mockedAxios.get.mockResolvedValueOnce({ data: [] });
      const result = await getCategories();
      // Should return empty array
      expect(result).toEqual([]);
    });
    it('should handle API error', async () => {
      // Mock API error
      mockedAxios.get.mockRejectedValueOnce({
        response: {
          status: 500,
          data: { error: 'Server error' }
        }
      });
      // Expect appropriate error to be thrown
      await expect(getCategories())
        .rejects
        .toThrow(ApiError);
    });
  });
  describe('getSubcategories', () => {
    it('should fetch and transform subcategories correctly', async () => {
      // Mock API response
      const mockApiResponse = {
        data: [
          {
            _id: 'subcat1',
            name: 'Salads',
            description: 'Fresh salads',
            image: 'salads.jpg',
            isActive: true,
            order: 1,
            categoryId: 'cat1'
          },
          {
            _id: 'subcat2',
            name: 'Soups',
            description: 'Hot soups',
            image: 'soups.jpg',
            isActive: true,
            order: 2,
            categoryId: 'cat1'
          }
        ]
      };
      mockedAxios.get.mockResolvedValueOnce(mockApiResponse);
      const result = await getSubcategories('cat1');
      // Verify correct transformation and structure
      expect(result).toHaveLength(2);
      expect(result[0]).toEqual({
        id: 'subcat1',
        name: 'Salads',
        description: 'Fresh salads',
        image: 'salads.jpg',
        categoryId: 'cat1',
        order: 1
      });
      // Verify correct URL was called
      expect(mockedAxios.get).toHaveBeenCalledWith(
        expect.stringContaining('/categories/cat1/subcategories')
      );
    });
  });
  describe('getMenuItems', () => {
    it('should fetch and transform menu items by category', async () => {
      // Mock API response
      const mockApiResponse = {
        data: [
          {
            _id: 'item1',
            name: 'Caesar Salad',
            description: 'Fresh romaine lettuce with Caesar dressing',
            price: 12.99,
            image: 'caesar.jpg',
            categories: ['cat1'],
            subCategories: ['subcat1'],
            isAvailable: true,
            isActive: true
          },
          {
            _id: 'item2',
            name: 'Greek Salad',
            description: 'Mediterranean salad with feta cheese',
            price: 11.99,
            image: 'greek.jpg',
            categories: ['cat1'],
            subCategories: ['subcat1'],
            isAvailable: true,
            isActive: true
          }
        ]
      };
      mockedAxios.get.mockResolvedValueOnce(mockApiResponse);
      const result = await getMenuItems('cat1');
      // Verify the returned items match the UI MenuItem interface
      expect(result).toHaveLength(2);
      // First item
      expect(result[0]).toEqual({
        id: 'item1',
        name: 'Caesar Salad',
        description: 'Fresh romaine lettuce with Caesar dressing',
        price: 12.99,
        image: 'caesar.jpg',
        imageSearchTerm: '',
        category: 'cat1',
        categoryId: 'cat1',
        subcategory: 'subcat1',
        featured: false,
        popular: false,
        tags: []
      });
      // Verify the result is compatible with UiMenuItem interface
      const uiMenuItem: UiMenuItem = result[0];
      expect(uiMenuItem.id).toBe('item1');
      expect(uiMenuItem.name).toBe('Caesar Salad');
      // Verify correct URL with parameters
      expect(mockedAxios.get).toHaveBeenCalledWith(
        expect.stringContaining('/menu-items?categoryId=cat1')
      );
    });
    it('should handle subcategory filtering correctly', async () => {
      // Mock API response with subcategory filtering
      mockedAxios.get.mockResolvedValueOnce({ 
        data: [
          {
            _id: 'item1',
            name: 'Caesar Salad',
            description: 'Fresh romaine lettuce with Caesar dressing',
            price: 12.99,
            image: 'caesar.jpg',
            categories: ['cat1'],
            subCategories: ['subcat1'],
            isAvailable: true,
            isActive: true
          }
        ] 
      });
      await getMenuItems('cat1', 'subcat1');
      // Verify correct URL with both parameters
      expect(mockedAxios.get).toHaveBeenCalledWith(
        expect.stringContaining('/menu-items?categoryId=cat1&subcategoryId=subcat1')
      );
    });
    it('should handle empty menu items response', async () => {
      // Mock empty response
      mockedAxios.get.mockResolvedValueOnce({ data: [] });
      const result = await getMenuItems('cat1');
      // Should return empty array
      expect(result).toEqual([]);
    });
  });
  describe('getVenueById', () => {
    it('should fetch and transform venue data correctly', async () => {
      // Mock API response for venue
      const mockApiResponse = {
        data: {
          _id: "68187734a6d5090de7422456",
          name: "CINEMA CITY ARABIAN CENTRE",
          description: "Premier cinema dining experience",
          restaurantId: {
            _id: "rest1",
            name: "CINEMA CITY"
          }
        }
      };
      mockedAxios.get.mockResolvedValueOnce(mockApiResponse);
      const result = await getVenueById('68187734a6d5090de7422456');
      // Check transformation
      expect(result).toEqual({
        id: "68187734a6d5090de7422456",
        name: "CINEMA CITY ARABIAN CENTRE",
        description: "Premier cinema dining experience",
        restaurantId: "rest1",
        restaurantName: "CINEMA CITY"
      });
      // Verify correct URL
      expect(mockedAxios.get).toHaveBeenCalledWith(
        expect.stringContaining('/venues/68187734a6d5090de7422456')
      );
    });
    it('should handle venue not found error', async () => {
      // Mock API error for venue not found
      mockedAxios.get.mockRejectedValueOnce({
        response: {
          status: 404,
          data: { error: 'Venue not found' }
        }
      });
      // Should throw VenueNotFoundError
      await expect(getVenueById('invalid-venue'))
        .rejects
        .toThrow(VenueNotFoundError);
    });
  });
  describe('getVenueMenuItems', () => {
    it('should fetch and transform venue menu items correctly', async () => {
      // Mock API response
      const mockApiResponse = {
        data: [
          {
            _id: 'item1',
            name: 'Popcorn',
            description: 'Fresh buttered popcorn',
            price: 5.99,
            image: 'popcorn.jpg',
            categories: ['cat1'],
            isAvailable: true,
            isActive: true
          },
          {
            _id: 'item2',
            name: 'Nachos',
            description: 'Crispy nachos with cheese',
            price: 7.99,
            image: 'nachos.jpg',
            categories: ['cat1'],
            isAvailable: true,
            isActive: true
          }
        ]
      };
      mockedAxios.get.mockResolvedValueOnce(mockApiResponse);
      const result = await getVenueMenuItems('venue1');
      // Check transformation
      expect(result).toHaveLength(2);
      expect(result[0]).toEqual({
        id: 'item1',
        name: 'Popcorn',
        description: 'Fresh buttered popcorn',
        price: 5.99,
        image: 'popcorn.jpg',
        imageSearchTerm: '',
        category: 'cat1',
        categoryId: 'cat1',
        subcategory: undefined,
        featured: false,
        popular: false,
        tags: []
      });
      // Verify correct URL
      expect(mockedAxios.get).toHaveBeenCalledWith(
        expect.stringContaining('/venues/venue1/menu-items')
      );
    });
    it('should handle empty venue menu items', async () => {
      mockedAxios.get.mockResolvedValueOnce({ data: [] });
      const result = await getVenueMenuItems('venue1');
      expect(result).toEqual([]);
    });
    it('should handle venue not found error', async () => {
      mockedAxios.get.mockRejectedValueOnce({
        response: {
          status: 404,
          data: { error: 'Venue not found' }
        }
      });
      await expect(getVenueMenuItems('invalid-venue'))
        .rejects
        .toThrow(VenueNotFoundError);
    });
    it('should handle API errors', async () => {
      mockedAxios.get.mockRejectedValueOnce({
        response: {
          status: 500,
          data: { error: 'Internal server error' }
        }
      });
      await expect(getVenueMenuItems('venue1'))
        .rejects
        .toThrow(ApiError);
    });
  });
  describe('getFullMenuHierarchy', () => {
    it('should fetch and transform complete menu hierarchy for Cinema City venue', async () => {
      // Mock venue response with actual Cinema City data structure
      const mockVenueResponse = {
        data: {
          _id: "68187734a6d5090de7422456",
          name: "CINEMA CITY ARABIAN CENTRE",
          description: "Premier cinema dining venue",
          restaurantId: {
            _id: "rest1",
            name: "CINEMA CITY"
          }
        }
      };
      // Mock categories response
      const mockCategoriesResponse = {
        data: [
          {
            _id: "cat1",
            name: "Snacks",
            description: "Cinema snacks and treats",
            image: "snacks.jpg",
            isActive: true,
            order: 1
          },
          {
            _id: "cat2",
            name: "Beverages",
            description: "Refreshing drinks",
            image: "beverages.jpg",
            isActive: true,
            order: 2
          }
        ]
      };
      // Mock menu items response
      const mockMenuItemsResponse = {
        data: [
          {
            _id: "item1",
            name: "Large Popcorn",
            description: "Fresh buttered popcorn",
            price: 5.99,
            image: "popcorn.jpg",
            categories: ["cat1"],
            isAvailable: true,
            isActive: true
          },
          {
            _id: "item2",
            name: "Soft Drink",
            description: "Choice of carbonated beverages",
            price: 3.99,
            image: "drink.jpg",
            categories: ["cat2"],
            isAvailable: true,
            isActive: true
          }
        ]
      };
      // Set up mock responses in sequence
      mockedAxios.get
        .mockResolvedValueOnce(mockVenueResponse)
        .mockResolvedValueOnce(mockCategoriesResponse)
        .mockResolvedValueOnce(mockMenuItemsResponse);
      const result = await getFullMenuHierarchy("68187734a6d5090de7422456");
      // Verify restaurant data
      expect(result.restaurant).toEqual({
        id: "68187734a6d5090de7422456",
        name: "CINEMA CITY ARABIAN CENTRE",
        description: "Premier cinema dining venue",
        restaurantId: "rest1",
        restaurantName: "CINEMA CITY"
      });
      // Verify categories
      expect(result.categories).toHaveLength(2);
      expect(result.categories[0]).toEqual({
        id: "cat1",
        name: "Snacks",
        description: "Cinema snacks and treats",
        image: "snacks.jpg",
        order: 1
      });
      // Verify menu items
      expect(result.menuItems).toHaveLength(2);
      expect(result.menuItems[0]).toEqual({
        id: "item1",
        name: "Large Popcorn",
        description: "Fresh buttered popcorn",
        price: 5.99,
        image: "popcorn.jpg",
        imageSearchTerm: "",
        category: "cat1",
        categoryId: "cat1",
        subcategory: undefined,
        featured: false,
        popular: false,
        tags: []
      });
      // Verify API calls
      expect(mockedAxios.get).toHaveBeenCalledTimes(3);
      expect(mockedAxios.get).toHaveBeenCalledWith(
        expect.stringContaining('/venues/68187734a6d5090de7422456')
      );
      expect(mockedAxios.get).toHaveBeenCalledWith(
        expect.stringContaining('/categories')
      );
      expect(mockedAxios.get).toHaveBeenCalledWith(
        expect.stringContaining('/venues/68187734a6d5090de7422456/menu-items')
      );
    });
    it('should handle venue not found in hierarchy fetch', async () => {
      mockedAxios.get.mockRejectedValueOnce({
        response: {
          status: 404,
          data: { error: 'Venue not found' }
        }
      });
      await expect(getFullMenuHierarchy('invalid-venue'))
        .rejects
        .toThrow(VenueNotFoundError);
    });
    it('should handle empty menu hierarchy', async () => {
      // Mock responses for a venue with no menu items or categories
      const mockVenueResponse = {
        data: {
          _id: "68187734a6d5090de7422456",
          name: "CINEMA CITY ARABIAN CENTRE",
          restaurantId: {
            _id: "rest1",
            name: "CINEMA CITY"
          }
        }
      };
      mockedAxios.get
        .mockResolvedValueOnce(mockVenueResponse)
        .mockResolvedValueOnce({ data: [] }) // empty categories
        .mockResolvedValueOnce({ data: [] }); // empty menu items
      const result = await getFullMenuHierarchy("68187734a6d5090de7422456");
      expect(result.restaurant).toBeDefined();
      expect(result.categories).toHaveLength(0);
      expect(result.menuItems).toHaveLength(0);
    });
    it('should handle API errors during hierarchy fetch', async () => {
      // Mock venue success but categories failure
      mockedAxios.get
        .mockResolvedValueOnce({
          data: {
            _id: "68187734a6d5090de7422456",
            name: "CINEMA CITY ARABIAN CENTRE"
          }
        })
        .mockRejectedValueOnce({
          response: {
            status: 500,
            data: { error: 'Internal server error' }
          }
        });
      await expect(getFullMenuHierarchy("68187734a6d5090de7422456"))
        .rejects
        .toThrow(ApiError);
    });
  });
</file>

<file path="src/api/README.md">
# Backend API Enhancements for Menu Integration

This document outlines the necessary backend API enhancements to support the improved menu UI with real category images, subcategory counts, and venue/table display.

## API Endpoint Updates

### 1. Table Verification Endpoint

**Endpoint:** `GET /api/tables/{tableId}/verify`

Ensure this endpoint returns:
- Table information including number, capacity, and active status
- Complete venue information with name and description
- Restaurant ID for additional queries if needed

### 2. Menu Endpoint with Full Population

**Endpoint:** `GET /api/menus?venueId={venueId}&populate=true`

Update this endpoint to:
- Include real category images (not placeholder URLs)
- Add `subCategoryCount` to each category
- Provide a count of total subsubcategories per category
- Return the proper hierarchy of categories â†’ subcategories â†’ subsubcategories

### 3. Categories Population

When retrieving categories, include:
- Real image URLs for each category
- Count of subcategories under each category
- Count of menu items in each category
- Additional
</file>

<file path="src/api/test-order-auth.js">
// Test script to validate the order authentication flow
// Run this in browser console to test the authentication flow
(function testOrderAuthentication() {
  console.log('=== ORDER AUTHENTICATION TEST SCRIPT ===');
  // 1. First, test the cookie parsing
  function testCookieParsing() {
    console.log('\n--- Testing Cookie Parsing ---');
    // Mock document.cookie for testing
    const originalCookie = document.cookie;
    document.cookie = 'access_token=test_token; refresh_token=refresh; other=value';
    // Get the parsed cookies
    const cookies = window.parseCookies ? window.parseCookies() : null;
    if (!cookies) {
      console.error('âŒ parseCookies function not available globally. Add window.parseCookies = parseCookies; to orderService.ts for testing');
      return false;
    }
    console.log('Parsed cookies:', cookies);
    const success = cookies['access_token'] === 'test_token' && 
                   cookies['refresh_token'] === 'refresh' &&
                   cookies['other'] === 'value';
    console.log(success ? 'âœ… Cookie parsing working correctly' : 'âŒ Cookie parsing failed');
    // Reset the cookie
    document.cookie = originalCookie;
    return success;
  }
  // 2. Test token validation
  function testTokenValidation() {
    console.log('\n--- Testing Token Validation ---');
    // Create a test token (actual JWT structure with base64 encoded parts)
    const header = btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));
    const payload = btoa(JSON.stringify({ 
      id: '6836e3345ccab12be0616da7', 
      email: 'test@example.com',
      role: 'customer',
      exp: Math.floor(Date.now() / 1000) + 3600, // 1 hour from now
      iat: Math.floor(Date.now() / 1000)
    }));
    const signature = 'test_signature';
    const token = `${header}.${payload}.${signature}`;
    console.log('Test token generated:', token);
    // Call the validation function - if available
    if (typeof window.validateJwtToken !== 'function') {
      console.error('âŒ validateJwtToken function not exposed globally. Add window.validateJwtToken = function(token) { /* validation code */ } to orderService.ts for testing');
      return false;
    }
    const result = window.validateJwtToken(token);
    console.log('Validation result:', result);
    if (result.isAuthenticated && result.userId === '6836e3345ccab12be0616da7') {
      console.log('âœ… Token validation working correctly');
      return true;
    } else {
      console.log('âŒ Token validation failed');
      return false;
    }
  }
  // 4. Test expired token handling
  function testExpiredToken() {
    console.log('\n--- Testing Expired Token Handling ---');
    // Create an expired token
    const header = btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));
    const payload = btoa(JSON.stringify({ 
      id: '6836e3345ccab12be0616da7', 
      email: 'test@example.com',
      role: 'customer',
      exp: Math.floor(Date.now() / 1000) - 3600, // 1 hour ago
      iat: Math.floor(Date.now() / 1000) - 7200
    }));
    const signature = 'test_signature';
    const expiredToken = `${header}.${payload}.${signature}`;
    const result = window.validateJwtToken(expiredToken);
    console.log('Expired token validation result:', result);
    if (!result.isAuthenticated && result.userId === null) {
      console.log('âœ… Expired token handling working correctly');
      return true;
    } else {
      console.log('âŒ Expired token not handled correctly');
      return false;
    }
  }
  // 5. Test malformed token handling
  function testMalformedToken() {
    console.log('\n--- Testing Malformed Token Handling ---');
    const testCases = [
      { 
        name: 'Missing segments',
        token: 'header.payload'
      },
      {
        name: 'Invalid base64',
        token: 'header.@#$%^&*.signature'
      },
      {
        name: 'Missing required fields',
        token: `${btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }))}.${btoa(JSON.stringify({ 
          email: 'test@example.com'
        }))}.signature`
      },
      {
        name: 'Invalid role',
        token: `${btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }))}.${btoa(JSON.stringify({ 
          id: '6836e3345ccab12be0616da7',
          email: 'test@example.com',
          role: 'invalid_role',
          exp: Math.floor(Date.now() / 1000) + 3600
        }))}.signature`
      }
    ];
    const results = testCases.map(testCase => {
      const result = window.validateJwtToken(testCase.token);
      console.log(`Testing ${testCase.name}:`, result);
      return !result.isAuthenticated && result.userId === null;
    });
    const allPassed = results.every(Boolean);
    console.log(allPassed ? 'âœ… Malformed token handling working correctly' : 'âŒ Malformed token handling failed');
    return allPassed;
  }
  // 6. Test order payload construction
  function testOrderPayload() {
    console.log('\n--- Testing Order Payload Construction ---');
    const cartItems = [{
      id: 'test_item_1',
      menuItemId: 'test_menu_item_1',
      name: 'Test Item 1',
      price: 10,
      quantity: 1,
      getItemTotal: function() { return this.price * this.quantity; }
    }];
    const tableId = '681a58401a12c59b214b39df';
    const restaurantId = '65f456b06c9dfd001b6b1234';
    // Test authenticated payload
    const validToken = `${btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }))}.${btoa(JSON.stringify({ 
      id: '6836e3345ccab12be0616da7', 
      email: 'test@example.com',
      role: 'customer',
      exp: Math.floor(Date.now() / 1000) + 3600
    }))}.test_signature`;
    // Set up test environment
    const originalCookie = document.cookie;
    document.cookie = `access_token=${validToken}`;
    try {
      // Create order with token present
      window.createOrder(cartItems, tableId, restaurantId)
        .then(() => {
          console.log('âŒ Order creation should not succeed in test environment');
        })
        .catch(error => {
          // We expect a network error, but should see proper payload construction
          if (error.message.includes('Failed to fetch') || error.message.includes('Network Error')) {
            // Check the logged payload from console
            console.log('âœ… Order creation attempted with proper auth payload');
          } else {
            console.log('âŒ Unexpected error:', error.message);
          }
        })
        .finally(() => {
          // Reset cookie
          document.cookie = originalCookie;
          // Now test guest order payload
          window.createOrder(cartItems, tableId, restaurantId)
            .catch(error => {
              if (error.message.includes('Failed to fetch') || error.message.includes('Network Error')) {
                console.log('âœ… Guest order creation attempted with deviceId');
              } else {
                console.log('âŒ Unexpected error in guest flow:', error.message);
              }
            });
        });
      return true;
    } catch (error) {
      console.error('âŒ Error during payload test:', error);
      document.cookie = originalCookie;
      return false;
    }
  }
  // 3. Test complete authentication flow
  function testAuthFlow() {
    console.log('\n--- Testing Order Creation Authentication Flow ---');
    // Check if required functions are available
    if (typeof window.createOrder !== 'function') {
      console.error('âŒ createOrder function not exposed globally. Add window.createOrder = createOrder; to orderService.ts for testing');
      return false;
    }
    // Create a test cart
    const cartItems = [
      {
        id: 'test_item_1',
        menuItemId: 'test_menu_item_1',
        name: 'Test Item 1',
        price: 10,
        quantity: 1,
        getItemTotal: function() { return this.price * this.quantity; }
      }
    ];
    const tableId = '681a58401a12c59b214b39df';
    const restaurantId = '65f456b06c9dfd001b6b1234';
    console.log('Starting order creation test with:', { 
      cartItems, 
      tableId, 
      restaurantId,
      authPresent: Boolean(document.cookie.includes('access_token'))
    });
    // This will actually attempt to create an order, but should fail with a
    // controlled error since we're not actually submitting to the server
    window.createOrder(cartItems, tableId, restaurantId)
      .then(result => {
        console.log('âœ… Order creation returned result:', result);
      })
      .catch(error => {
        // We expect a network error, not an authentication error
        if (error.message.includes('Authentication required')) {
          console.log('âŒ Authentication check failed - redirecting to login when it should use token');
        } else if (error.message.includes('Failed to fetch') || error.message.includes('Network Error')) {
          console.log('âœ… Network error as expected, authentication flow is correct');
        } else {
          console.log('âš ï¸ Unexpected error:', error.message);
        }
      });
  }
  // Test environment setup and cleanup
  const testHelpers = {
    // Store original values
    original: {
      cookie: '',
      localStorage: new Map()
    },
    // Setup test environment
    setup() {
      console.log('\n--- Setting up test environment ---');
      // Store original values
      this.original.cookie = document.cookie;
      this.original.localStorage.clear();
      Array.from(localStorage).forEach(([key, value]) => {
        this.original.localStorage.set(key, value);
      });
      // Clear existing state
      document.cookie = '';
      localStorage.clear();
      console.log('âœ“ Test environment prepared');
    },
    // Cleanup after tests
    cleanup() {
      console.log('\n--- Cleaning up test environment ---');
      // Restore original values
      document.cookie = this.original.cookie;
      localStorage.clear();
      this.original.localStorage.forEach((value, key) => {
        localStorage.setItem(key, value);
      });
      console.log('âœ“ Original state restored');
    }
  };
  // Function to print test summary results
  function printTestSummary(results) {
    console.log('\n=== TEST RESULTS SUMMARY ===');
    console.table({
      'Cookie Parsing': {
        status: results.cookieParsing ? 'âœ… PASSED' : 'âŒ FAILED',
        details: 'Tests cookie extraction and parsing'
      },
      'Token Validation': {
        status: results.tokenValidation ? 'âœ… PASSED' : 'âŒ FAILED',
        details: 'Tests JWT token validation'
      },
      'Expired Token': {
        status: results.expiredToken ? 'âœ… PASSED' : 'âŒ FAILED',
        details: 'Tests expired token handling'
      },
      'Malformed Token': {
        status: results.malformedToken ? 'âœ… PASSED' : 'âŒ FAILED',
        details: 'Tests invalid token formats'
      },
      'Payload Validation': {
        status: results.payloadValidation ? 'âœ… PASSED' : 'âŒ FAILED',
        details: 'Tests order payload construction'
      }
    });
    const totalPassed = Object.values(results).filter(Boolean).length;
    const totalTests = Object.keys(results).length;
    console.log(`\nTest Summary: ${totalPassed}/${totalTests} tests passed`);
    return totalPassed === totalTests;
  }
  // Add detailed error reporting
  function collectTestErrors(results) {
    const errors = [];
    // Test case specific error checks
    if (!results.cookieParsing) {
      errors.push('Cookie Parsing: Failed to parse test cookies correctly');
    }
    if (!results.tokenValidation) {
      errors.push('Token Validation: JWT validation failed for valid token');
    }
    if (!results.expiredToken) {
      errors.push('Expired Token: Failed to reject expired token');
    }
    if (!results.malformedToken) {
      errors.push('Malformed Token: Failed to handle invalid token formats');
    }
    if (!results.payloadValidation) {
      errors.push('Payload Validation: Failed to construct order payload correctly');
    }
    return errors;
  }
  // Add timing info and async support
  async function runAllTests() {
    console.log('\n=== STARTING TEST SUITE ===');
    const startTime = performance.now();
    try {
      // Setup test environment
      testHelpers.setup();
      const testResults = {
        cookieParsing: await Promise.resolve(testCookieParsing()),
        tokenValidation: await Promise.resolve(testTokenValidation()),
        expiredToken: await Promise.resolve(testExpiredToken()),
        malformedToken: await Promise.resolve(testMalformedToken()),
        payloadValidation: await new Promise(resolve => {
          // Payload validation test is async, wait for completion
          testOrderPayload();
          // Give time for async operations to complete
          setTimeout(() => resolve(true), 1000);
        })
      };
      const endTime = performance.now();
      const duration = ((endTime - startTime) / 1000).toFixed(2);
      console.log(`\nTest suite completed in ${duration} seconds`);
      if (printTestSummary(testResults)) {
        console.log('\nâœ… All validation tests passed, testing complete authentication flow...');
        await new Promise(resolve => {
          testAuthFlow();
          // Wait for auth flow test to complete
          setTimeout(resolve, 1000);
        });
        console.log('\nâœ… Authentication flow test completed');
      } else {
        const errors = collectTestErrors(testResults);
        console.log('\nâŒ Some tests failed:');
        errors.forEach(error => console.log(`  - ${error}`));
        console.log('\nFix these issues before testing authentication flow');
      }
      // Add final statistics
      console.log('\n=== TEST SUITE STATISTICS ===');
      console.table({
        'Total Duration': `${duration} seconds`,
        'Tests Run': Object.keys(testResults).length,
        'Tests Passed': Object.values(testResults).filter(Boolean).length,
        'Tests Failed': Object.values(testResults).filter(r => !r).length,
        'Success Rate': `${((Object.values(testResults).filter(Boolean).length / Object.keys(testResults).length) * 100).toFixed(1)}%`
      });
    } catch (error) {
      console.error('\nâŒ Test suite failed with error:', error);
      throw error;
    } finally {
      // Always cleanup, even if tests fail
      testHelpers.cleanup();
    }
  }
  // Run the tests with proper error handling
  runAllTests().catch(error => {
    console.error('Test suite failed:', error);
  });
  console.log('\n=== TEST SCRIPT COMPLETED ===');
  console.log('To manually test the full flow:');
  console.log('1. Start the backend server');
  console.log('2. Login with valid credentials');
  console.log('3. Add items to cart');
  console.log('4. Try to place an order');
  console.log('5. Check browser network tab to confirm the request has the proper Authorization header');
})();
</file>

<file path="src/components/menu/MenuItemCard.tsx">
import React from 'react';
import { Card } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Clock, Plus } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { SharedImage } from '@/components/shared/SharedImage';
import { MenuItem } from '@/types/menu';
import { cn } from '@/lib/utils';
interface MenuItemCardProps {
  item: MenuItem;
  onClick?: () => void;
  className?: string;
  showPlusButton?: boolean;
}
export const MenuItemCard: React.FC<MenuItemCardProps> = ({ 
  item, 
  onClick, 
  className,
  showPlusButton = false 
}) => {
  // Handle click with proper propagation control and debug logging
  const handleClick = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    console.log('MenuItemCard clicked:', item.name); // Debug log
    if (onClick) {
      onClick();
    }
  };
  return (
    <Card 
      className={cn(
        "overflow-hidden h-full cursor-pointer transition-all duration-200 hover:shadow-lg group",
        "bg-[#1F1D2B] border-[#2D303E]",
        className
      )}
      onClick={handleClick}
    >
      <div className="relative">
        {/* Image container with fixed aspect ratio */}
        <div className="aspect-[4/3] overflow-hidden">
          <SharedImage
            src={item.image}
            alt={item.name}
            fallbackSearchTerm={item.imageSearchTerm || 'food'}
            className="w-full h-full object-cover transition-transform duration-300 group-hover:scale-105"
          />
        </div>
        {/* Featured badge */}
        {item.featured && (
          <div className="absolute top-2 left-2 bg-purple-600 text-white text-xs px-2 py-1 rounded-full z-10">
            Featured
          </div>
        )}
        {/* Plus button - conditionally rendered */}
        {showPlusButton && (
          <Button 
            variant="default"
            size="icon" 
            className="absolute bottom-2 right-2 h-8 w-8 rounded-full bg-purple-600 hover:bg-purple-700 shadow-md 
              transition-all duration-200 opacity-0 group-hover:opacity-100 z-10"
            onClick={(e) => {
              e.stopPropagation();
              e.preventDefault();
              console.log('Plus button clicked:', item.name); // Debug log
              if (onClick) onClick();
            }}
          >
            <Plus className="h-4 w-4" />
          </Button>
        )}
      </div>
      <div className="p-3 space-y-2 text-white">
        {/* Name and Price */}
        <div className="flex justify-between items-start mb-1">
          <h3 className="font-medium text-sm leading-tight line-clamp-1">{item.name}</h3>
          <span className="font-semibold text-sm text-purple-400 whitespace-nowrap ml-1">
            ${item.price.toFixed(2)}
          </span>
        </div>
        {/* Description - limited to 2 lines */}
        <p className="text-xs text-gray-400 line-clamp-2 min-h-[2rem]">
          {item.description || 'No description available'}
        </p>
        {/* Tags and metadata */}
        <div className="flex flex-wrap items-center justify-between gap-1 pt-1">
          <div className="flex flex-wrap gap-1">
            {item.tags && item.tags.length > 0 && item.tags.slice(0, 1).map((tag, index) => (
              <Badge 
                key={index} 
                variant="secondary" 
                className="bg-[#2D303E] text-gray-300 text-xs px-2 py-0"
              >
                {tag}
              </Badge>
            ))}
            {item.preparationTime && (
              <span className="flex items-center text-xs text-gray-400">
                <Clock className="w-3 h-3 mr-0.5" />
                {item.preparationTime}
              </span>
            )}
          </div>
          {item.popular && (
            <Badge className="bg-purple-900/40 text-purple-200 hover:bg-purple-900/60 text-xs border border-purple-600/30">
              Popular
            </Badge>
          )}
        </div>
      </div>
    </Card>
  );
};
export default MenuItemCard;
</file>

<file path="src/components/ui/loader.tsx">
import React from 'react';
import { Loader2 } from 'lucide-react';
import { cn } from '@/lib/utils';
interface LoaderProps extends React.HTMLAttributes<HTMLDivElement> {
  size?: number;
  color?: string;
  centered?: boolean;
}
export function Loader({
  size = 24,
  color,
  className,
  centered = false,
  ...props
}: LoaderProps) {
  return (
    <div 
      className={cn(
        'flex items-center justify-center',
        centered && 'w-full h-full min-h-[200px]',
        className
      )} 
      {...props}
    >
      <Loader2 
        size={size} 
        className={cn(
          'animate-spin',
          color
        )} 
      />
    </div>
  );
}
</file>

<file path="src/components/ui/spinner.tsx">
import React from 'react';
import { cn } from '@/lib/utils';
interface SpinnerProps {
  className?: string;
  size?: 'sm' | 'md' | 'lg';
}
export const Spinner = ({ className, size = 'md' }: SpinnerProps) => {
  const sizeClasses = {
    sm: 'h-4 w-4',
    md: 'h-6 w-6',
    lg: 'h-8 w-8',
  };
  return (
    <svg
      className={cn(
        'animate-spin text-gray-400 dark:text-gray-600',
        sizeClasses[size],
        className
      )}
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      aria-hidden="true"
    >
      <circle
        className="opacity-25"
        cx="12"
        cy="12"
        r="10"
        stroke="currentColor"
        strokeWidth="4"
      />
      <path
        className="opacity-75"
        fill="currentColor"
        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
      />
    </svg>
  );
};
</file>

<file path="src/components/AIChatDrawer.tsx">
import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Drawer, DrawerContent, DrawerHeader, DrawerTitle, DrawerTrigger } from '@/components/ui/drawer';
import { Wand2, X, Send } from 'lucide-react';
import { cn } from '@/lib/utils';
interface Message {
  id: string;
  text: string;
  sender: 'user' | 'ai';
  timestamp: Date;
}
export const AIChatDrawer: React.FC = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [messages, setMessages] = useState<Message[]>([
    {
      id: '1',
      text: "Hi there! I'm your AI dining assistant. How can I help you today? I can recommend dishes based on your mood, dietary preferences, or cravings!",
      sender: 'ai',
      timestamp: new Date(),
    },
  ]);
  const [inputValue, setInputValue] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const handleSendMessage = async () => {
    if (!inputValue.trim()) return;
    const userMessage: Message = {
      id: Date.now().toString(),
      text: inputValue,
      sender: 'user',
      timestamp: new Date(),
    };
    // Add user message to chat
    setMessages(prev => [...prev, userMessage]);
    setInputValue('');
    setIsLoading(true);
    try {
      // Simulate AI response (in a real app, this would be an API call)
      setTimeout(() => {
        const aiResponse: Message = {
          id: (Date.now() + 1).toString(),
          text: getAIResponse(inputValue),
          sender: 'ai',
          timestamp: new Date(),
        };
        setMessages(prev => [...prev, aiResponse]);
        setIsLoading(false);
      }, 1000);
    } catch (error) {
      console.error('Error sending message:', error);
      setIsLoading(false);
    }
  };
  const getAIResponse = (userInput: string): string => {
    const input = userInput.toLowerCase();
    if (input.includes('recommend') || input.includes('suggest') || input.includes('what should i eat')) {
      return "I'd be happy to help! Could you tell me if you're in the mood for something specific? For example, are you looking for something light, spicy, or maybe a dessert?";
    } else if (input.includes('vegetarian') || input.includes('veggie')) {
      return "I'd recommend our Mediterranean Veggie Platter or the Portobello Mushroom Burger. Both are customer favorites! Would you like to know more about either?";
    } else if (input.includes('spicy') || input.includes('hot')) {
      return "Our Spicy Buffalo Wings and Thai Curry are both excellent choices if you like some heat. How spicy would you like it on a scale of 1-10?";
    } else if (input.includes('sweet') || input.includes('dessert')) {
      return "You're in for a treat! Our Chocolate Lava Cake and Tiramisu are both amazing. The lava cake comes with vanilla ice cream - would you like to add that to your order?";
    } else if (input.includes('gluten') || input.includes('dairy') || input.includes('allerg')) {
      return "We have several gluten-free and dairy-free options available. Our staff is trained to handle food allergies - would you like me to connect you with a server to discuss your specific needs?";
    } else if (input.includes('thank') || input.includes('thanks')) {
      return "You're welcome! Is there anything else I can help you with?";
    } else if (input.includes('hello') || input.includes('hi') || input.includes('hey')) {
      return "Hello! I'm here to help you choose something delicious. What are you in the mood for today?";
    } else {
      return "That sounds interesting! Could you tell me more about what you're looking for in a meal? For example, are you in the mood for something light, hearty, or perhaps a specific cuisine?";
    }
  };
  const formatTime = (date: Date) => {
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  };
  return (
    <Drawer open={isOpen} onOpenChange={setIsOpen}>
      <DrawerTrigger asChild>
        <Button 
          variant="ghost" 
          size="icon"
          className="fixed left-6 bottom-20 h-12 w-12 rounded-full bg-purple-600 hover:bg-purple-700 text-white shadow-lg z-40 transition-all hover:scale-110"
          aria-label="AI Dining Assistant"
        >
          <Wand2 className="h-6 w-6" />
        </Button>
      </DrawerTrigger>
      <DrawerContent className="h-[80vh] max-h-[800px] bg-[#1F1D2B] border-t-2 border-purple-500/30 rounded-t-2xl">
        <div className="mx-auto w-full max-w-2xl h-full flex flex-col">
          <DrawerHeader className="px-4 pt-4 pb-2">
            <div className="flex items-center justify-between w-full">
              <DrawerTitle className="text-white text-xl font-semibold flex items-center">
                <Wand2 className="h-5 w-5 mr-2 text-purple-400" />
                AI Dining Assistant
              </DrawerTitle>
              <Button 
                variant="ghost" 
                size="icon" 
                className="h-8 w-8 text-gray-400 hover:text-white hover:bg-purple-900/30"
                onClick={() => setIsOpen(false)}
              >
                <X className="h-4 w-4" />
              </Button>
            </div>
            <p className="text-sm text-purple-300">Ask me for recommendations or dietary advice</p>
          </DrawerHeader>
          <div className="flex-1 overflow-y-auto p-4 space-y-4">
            {messages.map((message) => (
              <div 
                key={message.id} 
                className={cn(
                  'flex',
                  message.sender === 'user' ? 'justify-end' : 'justify-start'
                )}
              >
                <div 
                  className={cn(
                    'max-w-[80%] rounded-2xl px-4 py-2',
                    message.sender === 'user' 
                      ? 'bg-purple-600 text-white rounded-br-none' 
                      : 'bg-[#2D303E] text-gray-200 rounded-bl-none'
                  )}
                >
                  <p className="text-sm">{message.text}</p>
                  <p className="text-xs mt-1 opacity-60 text-right">
                    {formatTime(message.timestamp)}
                  </p>
                </div>
              </div>
            ))}
            {isLoading && (
              <div className="flex items-center space-x-2 p-2">
                <div className="w-2 h-2 rounded-full bg-purple-400 animate-bounce" style={{ animationDelay: '0ms' }} />
                <div className="w-2 h-2 rounded-full bg-purple-400 animate-bounce" style={{ animationDelay: '150ms' }} />
                <div className="w-2 h-2 rounded-full bg-purple-400 animate-bounce" style={{ animationDelay: '300ms' }} />
              </div>
            )}
          </div>
          <div className="p-4 border-t border-gray-800">
            <div className="relative">
              <input
                type="text"
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
                placeholder="Ask me for recommendations or dietary advice..."
                className="w-full bg-[#2D303E] text-white placeholder-purple-300/50 rounded-full py-3 pl-4 pr-12 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent"
                disabled={isLoading}
              />
              <Button 
                type="button" 
                variant="ghost" 
                size="icon" 
                className="absolute right-1 top-1/2 -translate-y-1/2 h-8 w-8 text-purple-400 hover:text-white hover:bg-purple-600/50"
                onClick={handleSendMessage}
                disabled={isLoading || !inputValue.trim()}
              >
                <Send className="h-4 w-4" />
              </Button>
            </div>
            <p className="text-xs text-purple-300/60 mt-2 text-center">
              Try: "What's good for someone who loves spicy food?"
            </p>
          </div>
        </div>
      </DrawerContent>
    </Drawer>
  );
};
export default AIChatDrawer;
</file>

<file path="src/components/CategoryFilter.tsx">
import React from 'react';
import { Category } from '@/types';
import { Tabs, TabsList, TabsTrigger } from '@/components/ui/tabs';
interface CategoryFilterProps {
  categories: Category[];
  selectedCategory: string;
  onSelectCategory: (categoryId: string) => void;
}
const CategoryFilter: React.FC<CategoryFilterProps> = ({
  categories,
  selectedCategory,
  onSelectCategory,
}) => {
  return (
    <Tabs 
      value={selectedCategory} 
      onValueChange={onSelectCategory}
      className="w-full"
    >
      <TabsList className="flex flex-wrap justify-start gap-2 bg-transparent overflow-x-auto">
        {categories.map((category) => (
          <TabsTrigger 
            key={category.id} 
            value={category.id}
            className="data-[state=active]:bg-primary data-[state=active]:text-white"
          >
            {category.name}
          </TabsTrigger>
        ))}
      </TabsList>
    </Tabs>
  );
};
export default CategoryFilter;
</file>

<file path="src/components/ItemDetailDrawer.tsx">
import React, { useState, useEffect, useMemo } from 'react';
import { MenuItem, CartItemModifier, MenuItemModifierGroup, ModifierOption } from '@/types';
import { Badge } from './ui/badge';
import { Button } from './ui/button';
import { DrawerClose } from './ui/drawer';
import { Clock, X, Minus, Plus, ShoppingCart, Star, Tag, Check } from 'lucide-react';
import { Checkbox } from './ui/checkbox';
import { RadioGroup, RadioGroupItem } from './ui/radio-group';
import { Label } from './ui/label';
import { useCart } from '@/context/CartContext';
import { Textarea } from './ui/textarea';
import { ScrollArea } from './ui/scroll-area';
import { cn } from '@/lib/utils';
import { toast } from 'sonner';
interface ItemDetailDrawerProps {
  item: MenuItem;
  onClose?: () => void; // Made optional since we can use DrawerClose
}
export const ItemDetailDrawer: React.FC<ItemDetailDrawerProps> = ({ item, onClose }) => {
  const { addItem } = useCart();
  // State to track selected modifiers: Key is group.name, Value is ModifierOption or ModifierOption[]
  const [selectedModifiers, setSelectedModifiers] = useState<Record<string, ModifierOption | ModifierOption[]>>({});
  const [specialInstructions, setSpecialInstructions] = useState('');
  const [quantity, setQuantity] = useState(1);
  const [isLoading, setIsLoading] = useState(false);
  const [imageLoaded, setImageLoaded] = useState(false);
  const [submitError, setSubmitError] = useState<string | null>(null);
  // Calculate total price using useMemo for efficiency
  const totalPrice = useMemo(() => {
    try {
      let calculatedPrice = item.price;
      Object.values(selectedModifiers).forEach(modOrMods => {
        if (Array.isArray(modOrMods)) {
          // Sum prices of selected options in a multi-select group
          calculatedPrice += modOrMods.reduce((sum, mod) => sum + (mod?.price || 0), 0);
        } else if (modOrMods) {
          // Add price of the selected option in a single-select group
          calculatedPrice += modOrMods.price || 0;
        }
      });
      return calculatedPrice * quantity;
    } catch (err) {
      console.error("Error calculating price:", err);
      return item.price * quantity; // Fallback to base price if calculation fails
    }
  }, [selectedModifiers, quantity, item.price]);
  // Handle modifier selection based on group type
  const handleModifierChange = (
    group: MenuItemModifierGroup,
    option: ModifierOption, // Now receiving the specific option
    checked: boolean | string // Checkbox sends boolean, RadioGroup sends value string (option.name)
  ) => {
    try {
      setSelectedModifiers(prev => {
        const newSelection = { ...prev };
        const groupName = group.name; // Use group name as key
        const currentGroupSelection = newSelection[groupName];
        if (group.type === 'multi-select') {
          const currentArray = Array.isArray(currentGroupSelection) ? currentGroupSelection : [];
          if (checked === true) {
            // Add option if checked
            newSelection[groupName] = [...currentArray, option];
          } else {
            // Remove option if unchecked
            newSelection[groupName] = currentArray.filter(o => o.name !== option.name);
            // If array becomes empty, remove the key entirely (optional, but cleaner)
            if (newSelection[groupName].length === 0) {
              delete newSelection[groupName];
            }
          }
        } else if (group.type === 'single-select') {
          // For RadioGroup, 'checked' is the value (option.name) of the selected item
          if (typeof checked === 'string' && checked === option.name) {
             // Set the selected option directly
             newSelection[groupName] = option;
          }
          // No 'else' needed as RadioGroup handles deselection implicitly by selecting another
        }
        return newSelection;
      });
    } catch (err) {
      console.error("Error updating modifiers:", err);
    }
  };
   // Set default selections for required single-select groups
   useEffect(() => {
    try {
      const defaultSelections: Record<string, ModifierOption> = {};
      item.modifiers?.forEach(group => {
        if (group.type === 'single-select' && group.required && group.options.length > 0) {
          // Select the first option by default if none is selected for this required group
          if (!selectedModifiers[group.name]) {
             defaultSelections[group.name] = group.options[0];
          }
        }
      });
      if (Object.keys(defaultSelections).length > 0) {
         setSelectedModifiers(prev => ({ ...prev, ...defaultSelections }));
      }
    } catch (err) {
      console.error("Error setting default selections:", err);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [item.modifiers]); // Run only when item modifiers change
  // Reset state when drawer closes
  useEffect(() => {
    return () => {
      // This cleanup function runs when the component unmounts
      setSelectedModifiers({});
      setSpecialInstructions('');
      setQuantity(1);
      setImageLoaded(false);
      setSubmitError(null);
    };
  }, []);
  const handleAddToCart = () => {
    setIsLoading(true);
    setSubmitError(null);
    // Simulate a small delay for better UX
    setTimeout(() => {
      try {
        // Validate required modifiers if needed
        const missingRequiredGroups = item.modifiers?.filter(group => 
          group.required && (!selectedModifiers[group.name] || 
            (Array.isArray(selectedModifiers[group.name]) && 
              (selectedModifiers[group.name] as ModifierOption[]).length === 0))
        );
        if (missingRequiredGroups && missingRequiredGroups.length > 0) {
          setSubmitError(`Please select options for: ${missingRequiredGroups.map(g => g.name).join(', ')}`);
          setIsLoading(false);
          return;
        }
        // Flatten selected modifiers into the CartItemModifier[] format
        const cartModifiers: CartItemModifier[] = [];
        Object.entries(selectedModifiers).forEach(([groupName, selection]) => {
          if (Array.isArray(selection)) {
            // Add all selections from multi-select groups
            selection.forEach(option => {
              if (option && option.name) {
                cartModifiers.push({
                  id: option.name,
                  name: option.name,
                  price: option.price || 0
                });
              }
            });
          } else if (selection && selection.name) {
            // Add single selection from single-select groups
            cartModifiers.push({
              id: selection.name,
              name: selection.name,
              price: selection.price || 0
            });
          }
        });
        addItem(
          item, // The base menu item
          quantity,
          cartModifiers.length > 0 ? cartModifiers : undefined,
          undefined, // Cooking preference removed, handle via modifiers if needed
          specialInstructions || undefined
        );
        // Show success toast
        toast.success(`${quantity} Ã— ${item.name} added to cart`);
        // Close drawer after successful add (use onClose if provided)
        if (onClose) {
          setTimeout(() => {
            onClose();
          }, 300);
        }
      } catch (error) {
        console.error('Error adding item to cart:', error);
        setSubmitError('Failed to add item to cart. Please try again.');
        toast.error('Failed to add item to cart');
      } finally {
        setIsLoading(false);
      }
    }, 500);
  };
  if (!item || !item.name) {
    return (
      <div className="flex flex-col h-full p-4 items-center justify-center">
        <p>Item information not available</p>
        <Button onClick={onClose} className="mt-4">Close</Button>
      </div>
    );
  }
  return (
    <div className="flex flex-col h-full" style={{ backgroundColor: '#1F1D2B', color: 'white' }}>
      {/* Close button - outside ScrollArea for better positioning */}
      <Button 
        variant="outline" 
        size="icon" 
        className="absolute top-4 right-4 z-10 rounded-full bg-white bg-opacity-80 backdrop-blur-sm hover:bg-opacity-100 shadow-sm"
        aria-label="Close"
        onClick={onClose}
      >
        <X className="h-5 w-5" />
      </Button>
      {/* Use ScrollArea for content scrolling within the drawer */}
      <ScrollArea className="px-1 flex-1 overflow-y-auto">
        {/* Item Image with loading state */}
        <div className="relative mb-4 -mx-1">
          <div className={cn(
            "aspect-[4/3] overflow-hidden transition-opacity duration-300",
            !imageLoaded && "animate-pulse bg-muted"
          )}>
            <img
              src={item.image || `https://source.unsplash.com/random/600x400/?${item.imageSearchTerm || 'food'}`}
              alt={item.name}
              className={cn(
                "w-full h-full object-cover transition-transform duration-500",
                imageLoaded ? "opacity-100" : "opacity-0"
              )}
              loading="lazy"
              onLoad={() => setImageLoaded(true)}
              onError={() => setImageLoaded(true)} // Also set loaded on error to remove skeleton
            />
          </div>
          {/* Featured badge */}
          {item.featured && (
            <div className="absolute top-4 left-4 bg-purple-600 text-white text-xs px-3 py-1 rounded-full">
              Featured
            </div>
          )}
        </div>
        {/* Item Name and Description */}
        <div className="mb-4 px-4">
          <div className="flex justify-between items-start mb-2">
            <h2 className="text-2xl font-semibold">{item.name}</h2>
            <span className="text-xl font-bold text-purple-600">${item.price.toFixed(2)}</span>
          </div>
          {/* Tags and metadata */}
          <div className="flex flex-wrap gap-2 mb-3">
            {item.preparationTime && (
              <Badge variant="outline" className="flex items-center gap-1">
                <Clock className="h-3 w-3" />
                {item.preparationTime}
              </Badge>
            )}
            {item.rating && (
              <Badge variant="outline" className="flex items-center gap-1 bg-amber-50 text-amber-700 border-amber-200">
                <Star className="h-3 w-3 fill-amber-500 text-amber-500" />
                {item.rating}
              </Badge>
            )}
            {item.tags && item.tags.length > 0 && item.tags.map((tag, index) => (
              <Badge key={index} variant="outline" className="flex items-center gap-1">
                <Tag className="h-3 w-3" />
                {tag}
              </Badge>
            ))}
          </div>
          <p className="text-muted-foreground text-sm">{item.description}</p>
        </div>
        {/* Divider */}
        <div className="border-t border-border mb-4 mx-4"></div>
        {/* Error message */}
        {submitError && (
          <div className="mb-4 mx-4 p-3 bg-red-100 border border-red-200 rounded-md text-red-800">
            <p className="text-sm">{submitError}</p>
          </div>
        )}
        {/* Modifier Groups */}
        {item.modifiers && item.modifiers.length > 0 && (
          <div className="mb-6 px-4 space-y-6">
            {item.modifiers.map((group) => (
              <div key={group.name} className="animation-fade-in"> 
                <h3 className="font-medium mb-3 flex items-center">
                  {group.name}
                  {group.required && <span className="text-destructive ml-1">*</span>}
                  {group.type === 'multi-select' && !group.required && (
                    <span className="text-muted-foreground text-xs ml-2 bg-muted px-2 py-0.5 rounded-full">
                      Select multiple
                    </span>
                  )}
                  {group.type === 'single-select' && !group.required && (
                    <span className="text-muted-foreground text-xs ml-2 bg-muted px-2 py-0.5 rounded-full">
                      Select one
                    </span>
                  )}
                </h3>
                {/* Render RadioGroup for single-select */}
                {group.type === 'single-select' ? (
                  <RadioGroup
                    value={(selectedModifiers[group.name] as ModifierOption)?.name} // Controlled component: value is the name of the selected option
                    onValueChange={(value) => {
                      // Find the option object corresponding to the selected value (name)
                      const selectedOption = group.options.find(opt => opt.name === value);
                      if (selectedOption) {
                        handleModifierChange(group, selectedOption, value);
                      }
                    }}
                    className="space-y-2"
                  >
                    {group.options.map(option => (
                      <div key={option.name} className="flex items-center justify-between bg-muted/50 p-3 rounded-md">
                        <div className="flex items-center gap-2">
                          <RadioGroupItem value={option.name} id={`${group.name}-${option.name}`} />
                          <Label htmlFor={`${group.name}-${option.name}`} className="cursor-pointer">{option.name}</Label>
                        </div>
                        <span className="text-sm font-medium text-purple-600">
                          {option.price > 0 ? `+$${option.price.toFixed(2)}` : (group.required ? '' : 'Included')}
                        </span>
                      </div>
                    ))}
                  </RadioGroup>
                ) : (
                // Render Checkboxes for multi-select
                <div className="space-y-2">
                  {group.options.map(option => {
                    // Determine if this checkbox option is currently selected
                    const isChecked = Array.isArray(selectedModifiers[group.name])
                                      ? (selectedModifiers[group.name] as ModifierOption[]).some(o => o.name === option.name)
                                      : false;
                    return (
                      <div key={option.name} className="flex items-center justify-between bg-muted/50 p-3 rounded-md">
                        <div className="flex items-center gap-2">
                          <Checkbox
                            id={`${group.name}-${option.name}`}
                            checked={isChecked}
                            onCheckedChange={(checked) => handleModifierChange(group, option, checked === true)}
                          />
                          <Label htmlFor={`${group.name}-${option.name}`}>{option.name}</Label>
                        </div>
                        <span className="text-sm font-medium text-purple-600">
                          {option.price > 0 ? `+$${option.price.toFixed(2)}` : 'Included'}
                        </span>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          ))}
        </div>
      )}
      {/* Special Instructions */}
      <div className="mb-6 px-4">
        <h3 className="font-medium mb-2">Special Instructions</h3>
        <Textarea
          placeholder="Any allergies or special requests? (e.g., 'no onions')"
          value={specialInstructions}
          onChange={(e) => setSpecialInstructions(e.target.value)}
          className="resize-none h-24 bg-muted/50 border-border"
        />
      </div>
      {/* Quantity Selector */}
      <div className="mb-6 px-4 flex items-center justify-between">
        <h3 className="font-medium">Quantity</h3>
        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            size="icon"
            className="h-8 w-8"
            onClick={() => setQuantity(q => Math.max(1, q - 1))}
            disabled={quantity <= 1}
            aria-label="Decrease quantity"
          >
            <Minus className="h-4 w-4" />
          </Button>
          <span className="font-medium w-8 text-center" aria-live="polite">{quantity}</span>
          <Button
            variant="outline"
            size="icon"
            className="h-8 w-8"
            onClick={() => setQuantity(q => q + 1)}
            aria-label="Increase quantity"
          >
            <Plus className="h-4 w-4" />
          </Button>
        </div>
      </div>
      </ScrollArea>
      {/* Footer with Price and Add to Cart Button - outside ScrollArea for sticky positioning */}
      <div className="sticky bottom-0 bg-background py-4 px-4 mt-auto border-t"> 
        <Button
          className="w-full bg-purple-600 hover:bg-purple-700 text-white text-lg py-6"
          onClick={handleAddToCart}
          // Disable if a required single-select group doesn't have a selection or is loading
          disabled={
            isLoading || 
            item.modifiers?.some(g => g.type === 'single-select' && g.required && !selectedModifiers[g.name])
          }
        >
          {isLoading ? (
            <div className="flex items-center justify-center">
              <div className="h-5 w-5 border-2 border-white border-t-transparent rounded-full animate-spin mr-2"></div>
              Adding to cart...
            </div>
          ) : (
            <>
              <ShoppingCart className="mr-2 h-5 w-5" />
              Add {quantity} to Cart - ${totalPrice.toFixed(2)}
            </>
          )}
        </Button>
      </div>
    </div>
  );
};
</file>

<file path="src/components/MenuItemCard.tsx">
import React, { useState } from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Plus } from 'lucide-react';
import { MenuItem } from '@/types';
import { useCart } from '@/context/CartContext';
import { toast } from 'sonner';
import { Drawer, DrawerContent, DrawerTrigger } from '@/components/ui/drawer';
import { ItemDetailDrawer } from '@/components/ItemDetailDrawer';
interface MenuItemCardProps {
  item: MenuItem;
  className?: string;
  showDetailDrawer?: boolean;
}
const MenuItemCard: React.FC<MenuItemCardProps> = ({ item, className, showDetailDrawer = true }) => {
  const { addToCart } = useCart();
  const [isOpen, setIsOpen] = useState(false);
  const handleAddToCart = (e: React.MouseEvent) => {
    e.stopPropagation();
    // Add to cart functionality
    addToCart({
      id: item._id || item.id,
      name: item.name,
      price: item.price,
      image: item.image,
      description: item.description
    });
    toast.success(`${item.name} added to cart`);
  };
  // Format price
  const formattedPrice = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
  }).format(item.price);
  return (
    <div className="relative">
      {showDetailDrawer ? (
        <Drawer open={isOpen} onOpenChange={setIsOpen}>
          <DrawerTrigger asChild>
            <Card 
              className={`overflow-hidden cursor-pointer transition-all hover:shadow-md ${className || ''}`}
            >
        <div className="relative h-40 overflow-hidden">
          <img
            src={item.image || '/placeholder-item.jpg'}
            alt={item.name}
            className="w-full h-full object-cover"
            loading="lazy"
            onError={(e) => {
              const target = e.target as HTMLImageElement;
              target.src = '/placeholder-item.jpg';
            }}
          />
          {item.featured && (
            <div className="absolute top-2 left-2 bg-primary text-white text-xs px-2 py-1 rounded-full">
              Featured
            </div>
          )}
        </div>
        <CardContent className="p-3">
          <div className="flex justify-between items-start mb-1">
            <h3 className="font-medium text-base line-clamp-1">{item.name}</h3>
            <span className="font-semibold text-sm text-primary">{formattedPrice}</span>
          </div>
          <p className="text-xs text-muted-foreground line-clamp-2 mb-2">
            {item.description}
          </p>
          <div className="flex justify-between items-center">
            {/* Display tags if available */}
            {item.tags && item.tags.length > 0 && (
              <div className="flex gap-1 flex-wrap">
                {item.tags.slice(0, 2).map((tag, index) => (
                  <span 
                    key={index}
                    className="text-xs bg-muted px-2 py-0.5 rounded-full"
                  >
                    {tag}
                  </span>
                ))}
              </div>
            )}
            {/* Add to cart button */}
            <Button 
              variant="ghost" 
              size="icon" 
              className="h-9 w-9 ml-auto rounded-full bg-purple-600 hover:bg-purple-700 shadow-md"
              onClick={handleAddToCart}
            >
              <Plus className="h-5 w-5 text-white" />
            </Button>
          </div>
        </CardContent>
      </Card>
          </DrawerTrigger>
          <DrawerContent>
            <ItemDetailDrawer item={item} onClose={() => setIsOpen(false)} />
          </DrawerContent>
        </Drawer>
      ) : (
        <Card 
          className={`overflow-hidden cursor-pointer transition-all hover:shadow-md ${className || ''}`}
          onClick={() => toast.info(`Selected: ${item.name}`)}
        >
          <div className="relative h-40 overflow-hidden">
            <img
              src={item.image || '/placeholder-item.jpg'}
              alt={item.name}
              className="w-full h-full object-cover"
              loading="lazy"
              onError={(e) => {
                const target = e.target as HTMLImageElement;
                target.src = '/placeholder-item.jpg';
              }}
            />
            {item.featured && (
              <div className="absolute top-2 left-2 bg-primary text-white text-xs px-2 py-1 rounded-full">
                Featured
              </div>
            )}
          </div>
          <CardContent className="p-3">
            <div className="flex justify-between items-start mb-1">
              <h3 className="font-medium text-base line-clamp-1">{item.name}</h3>
              <span className="font-semibold text-sm text-primary">{formattedPrice}</span>
            </div>
            <p className="text-xs text-muted-foreground line-clamp-2 mb-2">
              {item.description}
            </p>
            <div className="flex justify-between items-center">
              {/* Display tags if available */}
              {item.tags && item.tags.length > 0 && (
                <div className="flex gap-1 flex-wrap">
                  {item.tags.slice(0, 2).map((tag, index) => (
                    <span 
                      key={index}
                      className="text-xs bg-muted px-2 py-0.5 rounded-full"
                    >
                      {tag}
                    </span>
                  ))}
                </div>
              )}
              {/* Add to cart button */}
              <Button 
                variant="ghost" 
                size="icon" 
                className="h-9 w-9 ml-auto rounded-full bg-purple-600 hover:bg-purple-700 shadow-md"
                onClick={handleAddToCart}
              >
                <Plus className="h-5 w-5 text-white" />
              </Button>
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
};
export default MenuItemCard;
</file>

<file path="src/constants/index.ts">
// Constants for the application
import { API_BASE_URL as CONFIG_API_URL } from '@/config/api';
// Re-export the API URL from our centralized configuration
export const API_BASE_URL = CONFIG_API_URL;
// Other constants can be added here as needed
</file>

<file path="src/context/CartContext.tsx">
import React, { createContext, useContext, useState, useEffect } from 'react';
import { useTableInfo } from './TableContext';
import { toast } from 'sonner';
export interface CartModifier {
  id: string;
  name: string;
  price: number;
}
export interface CartItem {
  id: string;
  name: string;
  price: number;
  quantity: number;
  image?: string;
  description?: string;
  categoryId?: string;
  subcategoryId?: string;
  tableId?: string; // Associate item with a specific table
  specialInstructions?: string;
  modifiers?: CartModifier[]; 
  dateAdded: number; // Timestamp for sorting
}
interface CartContextType {
  cartItems: CartItem[];
  addToCart: (item: Omit<CartItem, 'quantity' | 'dateAdded'>) => void;
  addItem: (
    item: any,
    quantity: number,
    modifiers?: CartModifier[],
    options?: any,
    specialInstructions?: string
  ) => void;
  removeFromCart: (itemId: string) => void;
  updateQuantity: (itemId: string, quantity: number) => void;
  clearCart: () => void;
  itemCount: number;
  cartTotal: number;
}
const CartContext = createContext<CartContextType | undefined>(undefined);
export const useCart = (): CartContextType => {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error('useCart must be used within a CartProvider');
  }
  return context;
};
export const CartProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  // Get table ID from context
  const { tableId } = useTableInfo();
  const [cartItems, setCartItems] = useState<CartItem[]>(() => {
    const savedCart = localStorage.getItem('cart');
    const parsedCart = savedCart ? JSON.parse(savedCart) : [];
    // If we have a table ID, filter items to show only those for this table
    if (tableId) {
      return parsedCart.filter((item: CartItem) => 
        !item.tableId || item.tableId === tableId
      );
    }
    return parsedCart;
  });
  const [itemCount, setItemCount] = useState(0);
  const [cartTotal, setCartTotal] = useState(0);
  // When tableId changes, filter cart items to only show items for this table
  useEffect(() => {
    if (tableId) {
      const savedCart = localStorage.getItem('cart');
      if (savedCart) {
        const allItems = JSON.parse(savedCart);
        const tableItems = allItems.filter((item: CartItem) => 
          !item.tableId || item.tableId === tableId
        );
        setCartItems(tableItems);
      }
    }
  }, [tableId]);
  useEffect(() => {
    // Get all existing cart items first
    const savedCart = localStorage.getItem('cart');
    const allItems = savedCart ? JSON.parse(savedCart) : [];
    // Replace or merge items for the current table
    let updatedCart: CartItem[];
    if (tableId) {
      // Remove items for this table from the full cart
      const otherTableItems = allItems.filter((item: CartItem) => 
        item.tableId && item.tableId !== tableId
      );
      // Add the current table's items
      updatedCart = [...otherTableItems, ...cartItems];
    } else {
      updatedCart = cartItems;
    }
    // Save all cart items back to localStorage
    localStorage.setItem('cart', JSON.stringify(updatedCart));
    // Update cart count and total
    const count = cartItems.reduce((total, item) => total + item.quantity, 0);
    setItemCount(count);
    const total = cartItems.reduce((sum, item) => {
      const itemTotal = item.price * item.quantity;
      const modifiersTotal = item.modifiers 
        ? item.modifiers.reduce((mSum, modifier) => mSum + modifier.price, 0) * item.quantity
        : 0;
      return sum + itemTotal + modifiersTotal;
    }, 0);
    setCartTotal(total);
  }, [cartItems, tableId]);
  const addToCart = (item: Omit<CartItem, 'quantity' | 'dateAdded'>) => {
    try {
      setCartItems(prevItems => {
        // Generate a unique ID if item has modifiers to avoid conflicts
        const itemId = item.modifiers && item.modifiers.length > 0 
          ? `${item.id}-${Date.now()}` 
          : item.id;
        // Check if item already exists in cart
        const existingItemIndex = prevItems.findIndex(cartItem => cartItem.id === itemId);
        if (existingItemIndex >= 0) {
          // If item exists, increase quantity
          const updatedItems = [...prevItems];
          updatedItems[existingItemIndex] = {
            ...updatedItems[existingItemIndex],
            quantity: updatedItems[existingItemIndex].quantity + 1
          };
          return updatedItems;
        } else {
          // If item doesn't exist, add new item with quantity 1
          const newItem = { 
            ...item, 
            id: itemId,
            quantity: 1, 
            tableId: tableId || undefined,
            dateAdded: Date.now()
          };
          return [...prevItems, newItem];
        }
      });
      toast.success(`Added ${item.name} to cart`);
    } catch (error) {
      console.error('Error adding item to cart:', error);
      toast.error('Failed to add item to cart');
    }
  };
  // New comprehensive addItem function for use with ItemDetailDrawer
  const addItem = (
    item: any,
    quantity: number = 1,
    modifiers?: CartModifier[],
    options?: any,
    specialInstructions?: string
  ) => {
    try {
      // Generate unique ID for this specific item configuration
      const uniqueId = modifiers && modifiers.length > 0
        ? `${item.id || item._id}-${Date.now()}`
        : item.id || item._id;
      const newItem: CartItem = {
        id: uniqueId,
        name: item.name,
        price: item.price,
        image: item.image,
        description: item.description,
        quantity: quantity,
        modifiers: modifiers,
        specialInstructions: specialInstructions,
        tableId: tableId || undefined,
        dateAdded: Date.now()
      };
      setCartItems(prev => [...prev, newItem]);
      toast.success(`Added ${quantity} Ã— ${item.name} to cart`);
    } catch (error) {
      console.error('Error adding item to cart:', error);
      toast.error('Failed to add item to cart');
    }
  };
  const removeFromCart = (itemId: string) => {
    setCartItems(prevItems => prevItems.filter(item => item.id !== itemId));
  };
  const updateQuantity = (itemId: string, quantity: number) => {
    setCartItems(prevItems => 
      prevItems.map(item => 
        item.id === itemId ? { ...item, quantity } : item
      )
    );
  };
  const clearCart = () => {
    // If we have a tableId, only clear items for this table
    if (tableId) {
      // Get all cart items
      const savedCart = localStorage.getItem('cart');
      if (savedCart) {
        const allItems = JSON.parse(savedCart);
        // Keep items for other tables
        const otherTableItems = allItems.filter((item: CartItem) => 
          item.tableId && item.tableId !== tableId
        );
        localStorage.setItem('cart', JSON.stringify(otherTableItems));
      }
      // Clear local state
      setCartItems([]);
    } else {
      // Clear everything if no table ID
      localStorage.removeItem('cart');
      setCartItems([]);
    }
  };
  const value = {
    cartItems,
    addToCart,
    addItem,
    removeFromCart,
    updateQuantity,
    clearCart,
    itemCount,
    cartTotal
  };
  return <CartContext.Provider value={value}>{children}</CartContext.Provider>;
};
export default CartContext;
</file>

<file path="src/context/OrdersContext.tsx">
import React, { createContext, useContext, useState, useEffect } from 'react';
import { Order, OrdersContextType } from '@/types';
import { toast } from 'sonner';
import { fetchUserOrders, getOrderById as fetchOrderById } from '@/api/orderService';
import { useAuth } from './AuthContext';
const OrdersContext = createContext<OrdersContextType | undefined>(undefined);
export const OrdersProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [orders, setOrders] = useState<Order[]>([]);
  const { isAuthenticated, token } = useAuth();
  const [loading, setLoading] = useState(false);
  // Fetch orders when authenticated
  useEffect(() => {
    const loadOrders = async () => {
      if (!isAuthenticated || !token) return;
      try {
        setLoading(true);
        const response = await fetchUserOrders();
        // Check if response is an array (direct API response) or has an orders property
        const ordersData = Array.isArray(response) ? response : (response.orders || []);
        setOrders(ordersData);
      } catch (error) {
        console.error('Failed to fetch orders:', error);
        toast.error('Failed to load your orders');
      } finally {
        setLoading(false);
      }
    };
    loadOrders();
  }, [isAuthenticated, token]);
  const addOrder = (order: Order) => {
    setOrders(prev => [order, ...prev]);
    toast.success('Order placed successfully!');
  };
  const getOrderById = async (id: string) => {
    // First check local state
    const localOrder = orders.find(order => order._id === id);
    if (localOrder) return localOrder;
    // If not found locally and we're authenticated, try to fetch from API
    if (isAuthenticated && token) {
      try {
        const order = await fetchOrderById(id, token);
        return order;
      } catch (error) {
        console.error('Failed to fetch order details:', error);
        toast.error('Failed to load order details');
        return null;
      }
    }
    return null;
  };
  const clearOrders = () => {
    setOrders([]);
    toast.info('Order history cleared');
  };
  return (
    <OrdersContext.Provider
      value={{
        orders,
        loading,
        addOrder,
        getOrderById,
        clearOrders
      }}
    >
      {children}
    </OrdersContext.Provider>
  );
};
export const useOrders = () => {
  const context = useContext(OrdersContext);
  if (context === undefined) {
    throw new Error('useOrders must be used within an OrdersProvider');
  }
  return context;
};
</file>

<file path="src/hooks/useAuth.ts">
import { useContext } from 'react';
import { AuthContext, AuthProvider } from '@/context/AuthContext';
/**
 * Custom hook to use the auth context
 * @returns The auth context
 * @throws Error if used outside of AuthProvider
 */
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
export { AuthProvider };
export default useAuth;
</file>

<file path="src/hooks/useMenuItems.ts">
import { useState, useEffect } from 'react';
import { MenuItem } from '@/types/menu';
import { api } from '@/services/api';
export const useMenuItems = () => {
  const [items, setItems] = useState<MenuItem[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  useEffect(() => {
    const loadItems = async () => {
      try {
        setIsLoading(true);
        const menuItems = await api.getMenuItems();
        setItems(menuItems);
      } catch (err) {
        console.error('Error loading menu items:', err);
        setError(err instanceof Error ? err : new Error('Failed to load menu items'));
      } finally {
        setIsLoading(false);
      }
    };
    loadItems();
  }, []);
  return { items, isLoading, error };
};
</file>

<file path="src/hooks/useQRScanner.ts">
import { useState, useCallback } from 'react';
import { 
  getTableById,
  verifyTableStatus,
  getFullMenuHierarchy,
  getSubcategories, 
  getMenuItems,
  getVenueMenuItems,
  getVenueById,
  Table,
  Venue,
  Category,
  Subcategory,
  MenuItem,
  ApiError,
  TableNotFoundError
} from '@/api/menuService';
// Custom error types
export class TableError extends Error {
  constructor(message: string, public tableId: string) {
    super(message);
    this.name = 'TableError';
  }
}
export class VenueError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'VenueError';
  }
}
export class MenuError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'MenuError';
  }
}
// Define an interface for SubSubcategory since it's missing from menuService.ts
// We'll just use Subcategory type for now
type SubSubcategory = Subcategory;
interface QRScannerState {
  isLoading: boolean;
  error: Error | null;
  data: {
    tableData?: {
      table: Table;
      venue: Venue;
    };
    menuData?: {
      categories: Category[];
      subcategories: { [categoryId: string]: Subcategory[] };
      subsubcategories: { [subcategoryId: string]: SubSubcategory[] };
      menuItems: MenuItem[];
    };
    categoryData?: {
      subcategories: Subcategory[];
      menuItems: MenuItem[];
    };
    subcategoryData?: {
      subsubcategories: SubSubcategory[];
      menuItems: MenuItem[];
    };
    subsubcategoryData?: {
      menuItems: MenuItem[];
    };
    currentCategory?: {
      id: string;
      name: string;
    };
    currentSubcategory?: {
      id: string;
      name: string;
    };
    currentSubSubcategory?: {
      id: string;
      name: string;
    };
  };
}
export const useQRScanner = () => {
  const [state, setState] = useState<QRScannerState>({
    isLoading: false,
    error: null,
    data: {}
  });
  const handleScan = useCallback(async (tableId: string) => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    try {
      // First verify table status
      const tableStatus = await verifyTableStatus(tableId);
      if (!tableStatus.exists || !tableStatus.isAvailable || !tableStatus.venue) {
        throw new TableError(
          !tableStatus.exists ? 'Table not found' : 
          !tableStatus.isAvailable ? 'Table is not available' :
          'Venue information not found',
          tableId
        );
      }
      // Get the full menu hierarchy for the venue
      const menuHierarchy = await getFullMenuHierarchy(tableStatus.venue._id);
      const table = await getTableById(tableId);
      setState(prev => ({
        ...prev,
        isLoading: false,
        data: {
          ...prev.data,
          tableData: {
            table,
            venue: tableStatus.venue
          },
          menuData: menuHierarchy
        }
      }));
      return {
        table: { id: tableId, venue: tableStatus.venue },
        menuHierarchy
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to process QR code';
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: new Error(errorMessage)
      }));
      throw error;
    }
  }, []);
  const selectCategory = useCallback(async (categoryId: string, categoryName: string) => {
    if (!state.data.tableData?.venue) return;
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    try {
      const venue = state.data.tableData.venue;
      const restaurantId = typeof venue.restaurantId === 'string' ? 
        venue.restaurantId : 
        venue.restaurantId._id;
      const subcategories = await getSubcategories(categoryId);
      const menuItems = await getMenuItems(categoryId);
      setState(prev => ({
        ...prev,
        isLoading: false,
        data: {
          ...prev.data,
          currentCategory: { id: categoryId, name: categoryName },
          currentSubcategory: undefined,
          currentSubSubcategory: undefined,
          categoryData: {
            subcategories,
            menuItems
          }
        }
      }));
      return { categoryId, categoryName, subcategories, menuItems };
    } catch (error) {
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: new Error('Failed to load category')
      }));
      throw error;
    }
  }, [state.data.tableData]);
  const selectSubcategory = useCallback(async (subcategoryId: string, subcategoryName: string) => {
    if (!state.data.tableData?.venue || !state.data.currentCategory) return;
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    try {
      const menuItems = await getMenuItems(undefined, subcategoryId);
      // For subsubcategories, we'll just use an empty array since we don't have that endpoint
      const subsubcategories: SubSubcategory[] = [];
      setState(prev => ({
        ...prev,
        isLoading: false,
        data: {
          ...prev.data,
          currentSubcategory: { id: subcategoryId, name: subcategoryName },
          currentSubSubcategory: undefined,
          subcategoryData: {
            subsubcategories,
            menuItems
          }
        }
      }));
      return { subcategoryId, subcategoryName, subsubcategories, menuItems };
    } catch (error) {
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: new Error('Failed to load subcategory')
      }));
      throw error;
    }
  }, [state.data.tableData, state.data.currentCategory]);
  const selectSubSubcategory = useCallback(async (subsubcategoryId: string, subsubcategoryName: string) => {
    if (!state.data.tableData?.venue || !state.data.currentCategory || !state.data.currentSubcategory) return;
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    try {
      // Since we don't have a specific API for this, we'll just use the menu items API
      // In a real implementation, you'd add a specific parameter for subsubcategory
      const menuItems = await getMenuItems();
      setState(prev => ({
        ...prev,
        isLoading: false,
        data: {
          ...prev.data,
          currentSubSubcategory: { id: subsubcategoryId, name: subsubcategoryName },
          subsubcategoryData: {
            menuItems
          }
        }
      }));
      return { subsubcategoryId, subsubcategoryName, menuItems };
    } catch (error) {
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: new Error('Failed to load subsubcategory')
      }));
      throw error;
    }
  }, [state.data.tableData, state.data.currentCategory, state.data.currentSubcategory]);
  const resetError = useCallback(() => {
    setState(prev => ({ ...prev, error: null }));
  }, []);
  const resetState = useCallback(() => {
    setState({
      isLoading: false,
      error: null,
      data: {}
    });
  }, []);
  return {
    ...state,
    handleScan,
    selectCategory,
    selectSubcategory,
    selectSubSubcategory,
    resetError,
    resetState
  };
};
</file>

<file path="src/pages/CartPage.tsx">
import React, { useState } from 'react';
import { useCart } from '@/context/CartContext';
import { useAuth } from '@/context/AuthContext';
import { useTableInfo } from '@/context/TableContext';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Separator } from '@/components/ui/separator';
import { Badge } from '@/components/ui/badge';
import { ArrowLeft, X, MinusCircle, PlusCircle, ShoppingCart, ChevronRight, Loader2 } from 'lucide-react';
import { Link, useNavigate } from 'react-router-dom';
import { toast } from 'sonner';
import { ScrollArea } from '@/components/ui/scroll-area';
import { createOrder } from '@/api/orderService';
import { createStripeCheckoutSession } from '@/api/paymentService';
import { useOrders } from '@/context/OrdersContext';
const CartPage: React.FC = () => {
  const { cartItems, removeFromCart, updateQuantity, clearCart, cartTotal, itemCount } = useCart();
  const { user, token, isAuthenticated } = useAuth();
  const { tableId, restaurantName } = useTableInfo();
  const { addOrder } = useOrders();
  const navigate = useNavigate();
  const [isProcessing, setIsProcessing] = useState(false);
  const handleQuantityChange = (itemId: string, newQuantity: number) => {
    if (newQuantity > 0) {
      updateQuantity(itemId, newQuantity);
    } else {
      removeFromCart(itemId);
    }
  };
  const handlePlaceOrder = async () => {
    if (!tableId) {
      toast.error('Table information is missing. Please scan a table QR code first.');
      navigate('/scan-table');
      return;
    }
    if (!isAuthenticated || !token) {
      toast.error('Please login to place your order');
      navigate('/login', { state: { returnUrl: '/cart' } });
      return;
    }
    if (cartItems.length === 0) {
      toast.error('Your cart is empty');
      return;
    }
    setIsProcessing(true);
    try {
      // Determine restaurant ID (either from context or extract from tableId)
      const restaurantId = restaurantName === 'InSeat' 
        ? '65f456b06c9dfd001b6b1234' 
        : tableId.split('-')[0];
      // Step 1: Create the order in our system
      const orderResponse = await createOrder(
        cartItems,
        tableId,
        restaurantId,
        token
      );
      if (!orderResponse || !orderResponse._id) {
        throw new Error('Failed to create order');
      }
      // Add the order to local context
      addOrder({
        id: orderResponse._id,
        items: cartItems,
        subtotal: cartTotal,
        tax: cartTotal * 0.1,
        total: cartTotal * 1.1,
        status: 'pending',
        timestamp: new Date(orderResponse.createdAt),
        tableNumber: tableId
      });
      toast.success('Order created successfully! Redirecting to payment...');
      // Step 2: Create Stripe checkout session
      const stripeSession = await createStripeCheckoutSession(
        cartItems,
        tableId,
        restaurantId
      );
      if (!stripeSession || !stripeSession.url) {
        throw new Error('Failed to create payment session');
      }
      // Store order ID in localStorage for retrieval after payment
      localStorage.setItem('pending_order_id', orderResponse._id);
      // Clear the cart
      clearCart();
      // Redirect to Stripe checkout
      window.location.href = stripeSession.url;
    } catch (error) {
      console.error('Order creation failed:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to create your order');
      setIsProcessing(false);
    }
  };
  const formattedTotal = new Intl.NumberFormat('en-GB', {
    style: 'currency',
    currency: 'GBP'
  }).format(cartTotal);
  return (
    <div className="container mx-auto px-4 py-6 mt-16 mb-20 bg-raisin-black">
      <div className="flex justify-between items-center mb-6">
        <Link 
          to="/" 
          className="inline-flex items-center text-muted-foreground hover:text-foreground transition-colors"
        >
          <ArrowLeft className="h-4 w-4 mr-2" />
          Back to menu
        </Link>
        {cartItems.length > 0 && (
          <Button 
            variant="ghost" 
            size="sm" 
            onClick={() => {
              if (window.confirm('Are you sure you want to clear your cart?')) {
                clearCart();
                toast.success('Cart cleared');
              }
            }}
            className="text-destructive hover:text-destructive hover:bg-destructive/10"
          >
            <X className="h-4 w-4 mr-2" /> Clear cart
          </Button>
        )}
      </div>
      <div className="flex flex-col lg:flex-row gap-6">
        {/* Cart Items */}
        <div className="w-full lg:w-2/3">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center">
                <ShoppingCart className="h-5 w-5 mr-2" />
                Your Cart
                {cartItems.length > 0 && (
                  <Badge variant="secondary" className="ml-2">
                    {cartItems.length} {cartItems.length === 1 ? 'item' : 'items'}
                  </Badge>
                )}
              </CardTitle>
              <CardDescription>
                {cartItems.length === 0 
                  ? 'Your cart is empty' 
                  : 'Review your items before checkout'}
              </CardDescription>
            </CardHeader>
            {cartItems.length === 0 ? (
              <CardContent className="text-center py-10">
                <div className="flex flex-col items-center justify-center space-y-3">
                  <ShoppingCart className="h-12 w-12 text-muted-foreground" />
                  <p className="text-lg">Your cart is empty</p>
                  <p className="text-sm text-muted-foreground">
                    Looks like you haven't added any items to your cart yet.
                  </p>
                  <Button 
                    onClick={() => navigate('/')}
                    className="mt-2"
                  >
                    Browse Menu
                  </Button>
                </div>
              </CardContent>
            ) : (
              <CardContent>
                <ScrollArea className="h-[calc(100vh-350px)] pr-4">
                  <div className="space-y-4">
                    {cartItems.map((item) => (
                      <div key={item.id} className="flex items-center">
                        {item.image && (
                          <div className="h-16 w-16 rounded-md overflow-hidden mr-4 flex-shrink-0">
                            <img 
                              src={item.image} 
                              alt={item.name} 
                              className="h-full w-full object-cover"
                            />
                          </div>
                        )}
                        <div className="flex-grow">
                          <div className="flex justify-between">
                            <h3 className="font-medium">{item.name}</h3>
                            <p className="font-semibold">
                              Â£{(item.price * item.quantity).toFixed(2)}
                            </p>
                          </div>
                          <div className="flex justify-between items-center mt-2">
                            <div className="flex items-center">
                              <Button
                                variant="ghost"
                                size="icon"
                                className="h-8 w-8"
                                onClick={() => handleQuantityChange(item.id, item.quantity - 1)}
                              >
                                <MinusCircle className="h-4 w-4" />
                              </Button>
                              <span className="mx-2">{item.quantity}</span>
                              <Button
                                variant="ghost"
                                size="icon"
                                className="h-8 w-8"
                                onClick={() => handleQuantityChange(item.id, item.quantity + 1)}
                              >
                                <PlusCircle className="h-4 w-4" />
                              </Button>
                            </div>
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={() => removeFromCart(item.id)}
                              className="text-destructive hover:text-destructive hover:bg-destructive/10"
                            >
                              <X className="h-4 w-4" />
                            </Button>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                </ScrollArea>
              </CardContent>
            )}
          </Card>
        </div>
        {/* Order Summary */}
        <div className="w-full lg:w-1/3">
          <Card>
            <CardHeader>
              <CardTitle>Order Summary</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="flex justify-between">
                <span className="text-muted-foreground">Subtotal</span>
                <span>{formattedTotal}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-muted-foreground">Tax</span>
                <span>Â£0.00</span>
              </div>
              <div className="flex justify-between">
                <span className="text-muted-foreground">Delivery Fee</span>
                <span>Â£0.00</span>
              </div>
              <Separator />
              <div className="flex justify-between font-bold">
                <span>Total</span>
                <span>{formattedTotal}</span>
              </div>
            </CardContent>
            <CardFooter className="flex flex-col gap-2">
              <Button 
                onClick={handlePlaceOrder}
                className="w-full bg-delft-blue hover:bg-delft-blue/90"
                disabled={cartItems.length === 0 || isProcessing}
              >
                {isProcessing ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Processing...
                  </>
                ) : (
                  'Place Order'
                )}
              </Button>
              <Button 
                variant="outline" 
                className="w-full border-delft-blue text-delft-blue hover:bg-delft-blue/10" 
                onClick={() => navigate('/')}
              >
                Continue Shopping
              </Button>
              {!isAuthenticated && (
                <p className="text-xs text-muted-foreground text-center mt-2">
                  You need to be logged in to complete your order
                </p>
              )}
            </CardFooter>
          </Card>
          {cartItems.length > 0 && (
            <div className="mt-6">
              <Card>
                <CardHeader className="pb-3">
                  <CardTitle className="text-base">Reward Program</CardTitle>
                </CardHeader>
                <CardContent>
                  <p className="text-sm text-muted-foreground">
                    Complete this order to earn {Math.floor(cartTotal)} loyalty points!
                  </p>
                  <div className="mt-3">
                    <Button 
                      variant="outline" 
                      size="sm" 
                      className="w-full border-delft-blue text-delft-blue hover:bg-delft-blue/10"
                      onClick={() => navigate('/account')}
                    >
                      <span>View Rewards</span>
                      <ChevronRight className="h-4 w-4 ml-1" />
                    </Button>
                  </div>
                </CardContent>
              </Card>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
export default CartPage;
</file>

<file path="src/pages/Checkout.tsx">
import React, { useState, useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { useCart } from '@/context/CartContext';
import { useOrders } from '@/context/OrdersContext';
import { useTableInfo } from '@/context/TableContext';
import { useAuth } from '@/context/AuthContext';
import { Button } from '@/components/ui/button';
import { ArrowLeft, CreditCard, Loader2, User } from 'lucide-react';
import { toast } from 'sonner';
import { createOrder } from '@/api/orderService';
import { createStripeCheckoutSession } from '@/api/paymentService';
import { OrderStatus, PaymentStatus } from '@/types';
const Checkout: React.FC = () => {
  const { cartItems, clearCart } = useCart();
  const { addOrder } = useOrders();
  const { tableId, restaurantName } = useTableInfo();
  const { isAuthenticated, token, guestLogin, user } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  // Calculate subtotal from cart items
  const subtotal = cartItems.reduce((total, item) => {
    return total + (item.price * item.quantity);
  }, 0);
  const [isProcessing, setIsProcessing] = useState(false);
  const tax = subtotal * 0.1;
  const total = subtotal + tax;
  // Function to handle checkout with Stripe
  const handleStripeCheckout = async () => {
    if (!tableId) {
      toast.error('Table information is missing. Please scan a table QR code.');
      navigate('/scan-table');
      return;
    }
    // Check authentication status
    if (!isAuthenticated || !token) {
      // First check if we have a stored token
      const storedToken = localStorage.getItem('auth_token');
      if (storedToken) {
        console.log('Found stored token, trying to use it for checkout...');
        // Token exists, we'll try to use it directly in the order request
        // No need to do anything here, the token will be used in the API call
      } else {
        // Try guest login if no stored token
        const guestLoginSuccess = await guestLogin(tableId);
        if (!guestLoginSuccess) {
          toast.error('Please log in to complete your order');
          navigate('/login', { state: { returnUrl: '/checkout' } });
          return;
        }
        // Continue with checkout after successful guest login
        toast.success('Continuing as guest');
      }
    } else {
      // User is authenticated
      console.log('User is authenticated as:', user?.role);
      toast.success(`Proceeding with checkout as ${user?.role === 'customer' ? 'customer' : 'guest'}`);
    }
    setIsProcessing(true);
    try {
      // First create the order in our system
      const restaurantId = restaurantName === 'InSeat' 
        ? '65f456b06c9dfd001b6b1234' 
        : tableId.split('-')[0];
      // Create order without passing token (it will be retrieved from storage)
      const orderResponse = await createOrder(
        cartItems,
        tableId,
        restaurantId
      );
      if (!orderResponse || !orderResponse._id) {
        throw new Error('Failed to create order');
      }
      // Add the order to local context
      addOrder({
        id: orderResponse._id,
        orderNumber: orderResponse.orderNumber || `ORD-${Date.now()}`,
        items: cartItems,
        subtotal,
        tax,
        serviceFee: orderResponse.serviceFee || 0,
        tip: orderResponse.tip || 0,
        total,
        status: OrderStatus.PENDING,
        paymentStatus: orderResponse.paymentStatus || PaymentStatus.PENDING,
        timestamp: new Date(orderResponse.createdAt),
        tableId: tableId
      });
      // Create Stripe checkout session
      const stripeSession = await createStripeCheckoutSession(
        cartItems,
        tableId,
        restaurantId
      );
      if (!stripeSession || !stripeSession.url) {
        throw new Error('Failed to create payment session');
      }
      // Store order ID in localStorage for retrieval after payment
      localStorage.setItem('pending_order_id', orderResponse._id);
      // Clear the cart
      clearCart();
      // Redirect to Stripe checkout
      window.location.href = stripeSession.url;
    } catch (error) {
      console.error('Checkout failed:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to process your order');
      setIsProcessing(false);
    }
  };
  return (
    <div className="px-4 py-4 mt-16">
      <Button 
        variant="ghost" 
        onClick={() => navigate(-1)} 
        className="mb-6 pl-0"
      >
        <ArrowLeft className="mr-2 h-4 w-4" /> Back
      </Button>
      <h1 className="text-2xl font-semibold mb-6">Checkout</h1>
      <div className="mb-8 bg-night rounded-lg border border-delft-blue p-4">
        <h2 className="font-medium mb-4 text-white">Order Summary</h2>
        {cartItems.map((item) => (
          <div key={item.id} className="flex justify-between py-2 text-sm text-white">
            <div>
              <span>{item.quantity} x {item.name}</span>
              {item.modifiers && item.modifiers.length > 0 && (
                <div className="text-xs text-gray-400 ml-4">
                  {/* Check for cookingPreference property safely */}
                  {(item as any).cookingPreference && <div>â€¢ {(item as any).cookingPreference}</div>}
                  {item.modifiers.map(mod => (
                    <div key={mod.id}>â€¢ {mod.name}</div>
                  ))}
                </div>
              )}
            </div>
            <span>${(item.price * item.quantity).toFixed(2)}</span>
          </div>
        ))}
        <div className="border-t border-delft-blue/30 my-3"></div>
        <div className="flex justify-between text-sm py-2 text-white">
          <span>Subtotal</span>
          <span>${subtotal.toFixed(2)}</span>
        </div>
        <div className="flex justify-between text-sm py-2 text-white">
          <span>Tax (10%)</span>
          <span>${tax.toFixed(2)}</span>
        </div>
        <div className="flex justify-between font-medium py-2 text-white">
          <span>Total</span>
          <span>${total.toFixed(2)}</span>
        </div>
      </div>
      <div className="bg-night rounded-lg border border-delft-blue p-4 mb-8">
        <h2 className="font-medium mb-4 text-white">Secure Payment</h2>
        <p className="text-gray-400 text-sm mb-4">
          Your payment will be processed securely through Stripe. You'll be redirected to complete your payment.
        </p>
        <Button 
          onClick={handleStripeCheckout}
          className="w-full bg-delft-blue hover:bg-delft-blue/90 text-white h-12"
          disabled={isProcessing || cartItems.length === 0}
        >
          {isProcessing ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Processing...
            </>
          ) : (
            <>
              <CreditCard className="mr-2 h-4 w-4" /> Pay ${total.toFixed(2)}
            </>
          )}
        </Button>
        <div className="mt-4 flex items-center justify-center">
          <img 
            src="https://stripe.com/img/v3/home/secure-badge.svg" 
            alt="Secure payments by Stripe" 
            className="h-8"
          />
        </div>
      </div>
      <div className="text-center text-xs text-gray-400 mb-6">
        By proceeding with your payment, you agree to our Terms of Service and Privacy Policy.
      </div>
    </div>
  );
};
export default Checkout;
</file>

<file path="src/pages/PaymentCancel.tsx">
import React, { useEffect } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { Button } from '@/components/ui/button';
import { XCircle, ShoppingCart } from 'lucide-react';
import { toast } from 'sonner';
const PaymentCancel: React.FC = () => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  useEffect(() => {
    // Show toast notification that payment was cancelled
    toast.error('Payment was cancelled. Your order was not processed.');
    // Clear the pending order ID from localStorage
    localStorage.removeItem('pending_order_id');
  }, []);
  return (
    <div className="min-h-screen bg-raisin-black text-white flex flex-col items-center justify-center p-4">
      <div className="w-20 h-20 bg-destructive/20 rounded-full flex items-center justify-center mb-6">
        <XCircle className="h-10 w-10 text-destructive" />
      </div>
      <h1 className="text-2xl font-semibold mb-2 text-center">Payment Cancelled</h1>
      <p className="text-gray-400 text-center mb-8 max-w-md">
        Your payment was cancelled and your order has not been processed. You can try again or continue shopping.
      </p>
      <div className="flex flex-col gap-4 w-full max-w-xs">
        <Button 
          onClick={() => navigate('/checkout')}
          className="bg-delft-blue hover:bg-delft-blue/90 text-white"
        >
          Try Again
        </Button>
        <Button 
          variant="outline"
          onClick={() => navigate('/')}
          className="border-delft-blue text-delft-blue hover:bg-delft-blue/10"
        >
          <ShoppingCart className="h-4 w-4 mr-2" /> Continue Shopping
        </Button>
      </div>
    </div>
  );
};
export default PaymentCancel;
</file>

<file path="src/pages/Splash.tsx">
import React, { useEffect, useState } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { verifyTableStatus } from '@/api/menuService';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { useTableInfo } from '@/context/TableContext';
import { Loader2 } from 'lucide-react';
// Simple progress bar component
const ProgressBar: React.FC<{ progress: number }> = ({ progress }) => {
  return (
    <div className="w-full h-2 bg-gray-200 rounded-full overflow-hidden">
      <div 
        className="h-full bg-primary transition-all duration-300 ease-in-out"
        style={{ width: `${progress}%` }}
      />
    </div>
  );
};
const Splash: React.FC = () => {
  const [searchParams] = useSearchParams();
  const tableId = searchParams.get('table');
  const navigate = useNavigate();
  const [progress, setProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const { setTableInfo } = useTableInfo();
  useEffect(() => {
    let progressInterval: NodeJS.Timeout;
    let redirectTimeout: NodeJS.Timeout;
    const handleTableVerification = async () => {
      // Start progress animation
      progressInterval = setInterval(() => {
        setProgress(prev => {
          // Only increase up to 70% during verification
          return prev < 70 ? prev + 5 : prev;
        });
      }, 100);
      try {
        if (tableId) {
          // Attempt to verify the table
          const tableData = await verifyTableStatus(tableId);
          if (tableData) {
            // Set table info in context
            setTableInfo({
              tableNumber: tableData.table.number,
              restaurantName: tableData.venue.name
            });
            // Store table ID in local storage for use elsewhere
            localStorage.setItem('currentTableId', tableData.table._id);
            localStorage.setItem('currentVenueId', tableData.venue._id);
            // Complete progress and redirect to menu
            setProgress(100);
            redirectTimeout = setTimeout(() => {
              navigate(`/menu?table=${tableData.table._id}`);
            }, 500);
          } else {
            throw new Error('Invalid table');
          }
        } else {
          // No table ID, redirect to scan
          setProgress(100);
          redirectTimeout = setTimeout(() => {
            navigate('/scan');
          }, 500);
        }
      } catch (err) {
        // Handle error
        setError(
          err instanceof Error 
            ? err.message 
            : 'Failed to verify table. Please try again.'
        );
        // Complete progress and redirect to scan
        setProgress(100);
        redirectTimeout = setTimeout(() => {
          navigate('/scan');
        }, 1500);
      } finally {
        clearInterval(progressInterval);
      }
    };
    handleTableVerification();
    // Cleanup
    return () => {
      clearInterval(progressInterval);
      clearTimeout(redirectTimeout);
    };
  }, [tableId, navigate, setTableInfo]);
  return (
    <div className="flex flex-col items-center justify-center min-h-screen p-4 bg-background">
      <div className="w-full max-w-md space-y-6">
        <div className="text-center space-y-2">
          <h1 className="text-3xl font-bold">INSEAT</h1>
          <p className="text-muted-foreground">Loading your dining experience</p>
        </div>
        <ProgressBar progress={progress} />
        {progress < 100 && (
          <div className="flex justify-center pt-4">
            <Loader2 className="h-6 w-6 animate-spin text-primary" />
          </div>
        )}
        {error && (
          <Alert variant="destructive">
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}
      </div>
    </div>
  );
};
export default Splash;
</file>

<file path="src/services/DemoService.ts">
import axios from 'axios';
const API_URL = import.meta.env.VITE_API_URL || 'https://api.inseat.achievengine.com/api';
// Check if we're in demo mode (URL contains a demo token)
export const isDemoMode = (): boolean => {
  const path = window.location.pathname;
  return path.includes('/demo/') || path.match(/\/[a-f0-9]{12}/) !== null;
};
// Extract demo token from URL if in demo mode
export const getDemoToken = (): string | null => {
  if (!isDemoMode()) return null;
  const path = window.location.pathname;
  const match = path.match(/\/([a-f0-9]{12})/);
  return match ? match[1] : null;
};
class DemoService {
  // Get restaurant information for demo
  async getRestaurantInfo() {
    try {
      const demoToken = getDemoToken();
      if (!demoToken) {
        return {
          success: false,
          error: 'Not in demo mode'
        };
      }
      const response = await axios.get(`${API_URL}/demo/customer/${demoToken}`);
      if (response.data.success) {
        // Save restaurant information to localStorage
        localStorage.setItem('demoRestaurantId', response.data.restaurantId);
        localStorage.setItem('demoRestaurantName', response.data.restaurantName);
        localStorage.setItem('isDemo', 'true');
        return {
          success: true,
          data: response.data
        };
      }
      return {
        success: false,
        error: 'Failed to load demo data'
      };
    } catch (error) {
      console.error('Error loading demo restaurant:', error);
      return {
        success: false,
        error: error.response?.data?.error || 'Failed to load demo restaurant data'
      };
    }
  }
  // Get the current restaurant ID (for API requests)
  getRestaurantId(): string | null {
    return localStorage.getItem('demoRestaurantId');
  }
  // Add demo token to requests
  getAuthHeader() {
    const demoToken = getDemoToken();
    return demoToken ? { 'X-Demo-Token': demoToken } : {};
  }
  // Reset demo data
  resetDemo() {
    localStorage.removeItem('demoRestaurantId');
    localStorage.removeItem('demoRestaurantName');
    localStorage.removeItem('isDemo');
  }
}
export default new DemoService();
</file>

<file path="src/services/OrderService.ts">
import { Order, CartItem, OrderStatus, PaymentStatus } from '@/types';
import { toast } from 'sonner';
import { AuthService } from './AuthService';
import apiClient from '@/api/apiClient';
// Extract base URL without any trailing /api to prevent double prefixes
let API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:3001';
// Remove any trailing /api if present to avoid double prefix
if (API_BASE.endsWith('/api')) {
  API_BASE = API_BASE.slice(0, -4);
}
const API_URL = `${API_BASE}/api`;
console.log('Order Service API URL:', API_URL);
// Simulate API delay
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));
export const OrderService = {
  // Create a new order
  createOrder: async (items: CartItem[], tableNumber: string): Promise<Order> => {
    await delay(1200); // Simulate network delay
    // Calculate order details
    const subtotal = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
    const tax = subtotal * 0.15; // Assuming 15% tax
    const total = subtotal + tax;
    // Create order object
    const order: Order = {
      id: 'order-' + Date.now(),
      items: [...items],
      subtotal,
      tax,
      total,
      status: OrderStatus.PREPARING,
      paymentStatus: PaymentStatus.PENDING,
      timestamp: new Date(),
      tableNumber
    };
    // In a real app, we would send the order to the server here
    // For now, we'll save it in localStorage
    const existingOrdersString = localStorage.getItem('orders');
    const existingOrders: Order[] = existingOrdersString ? JSON.parse(existingOrdersString) : [];
    localStorage.setItem('orders', JSON.stringify([order, ...existingOrders]));
    // Notify user
    toast.success('Order placed successfully!');
    return order;
  },
  // Get all orders for the current user
  getOrders: async (): Promise<Order[]> => {
    await delay(800); // Simulate network delay
    // In a real app, we would fetch orders from the server
    // For now, we'll retrieve them from localStorage
    const ordersString = localStorage.getItem('orders');
    return ordersString ? JSON.parse(ordersString) : [];
  },
  // Get order by ID
  getOrderById: async (orderId: string): Promise<Order | null> => {
    await delay(500); // Simulate network delay
    const ordersString = localStorage.getItem('orders');
    const orders: Order[] = ordersString ? JSON.parse(ordersString) : [];
    const order = orders.find(order => order.id === orderId);
    return order || null;
  },
  // Update order status
  updateOrderStatus: async (orderId: string, status: OrderStatus): Promise<Order | null> => {
    await delay(700); // Simulate network delay
    // Get orders from localStorage
    const ordersString = localStorage.getItem('orders');
    const orders: Order[] = ordersString ? JSON.parse(ordersString) : [];
    // Find and update the order
    const updatedOrders = orders.map(order => {
      if (order.id === orderId) {
        return { ...order, status };
      }
      return order;
    });
    // Save updated orders
    localStorage.setItem('orders', JSON.stringify(updatedOrders));
    // Return the updated order
    const updatedOrder = updatedOrders.find(order => order.id === orderId);
    return updatedOrder || null;
  },
  // Cancel an order
  cancelOrder: async (orderId: string): Promise<boolean> => {
    await delay(800); // Simulate network delay
    // Get orders from localStorage
    const ordersString = localStorage.getItem('orders');
    const orders: Order[] = ordersString ? JSON.parse(ordersString) : [];
    // Remove the order
    const updatedOrders = orders.filter(order => order.id !== orderId);
    // Check if any order was removed
    if (updatedOrders.length === orders.length) {
      toast.error('Order not found');
      return false;
    }
    // Save updated orders
    localStorage.setItem('orders', JSON.stringify(updatedOrders));
    toast.success('Order cancelled successfully');
    return true;
  },
  // Get active orders (preparing or ready status)
  getActiveOrders: async (): Promise<Order[]> => {
    await delay(600); // Simulate network delay
    const ordersString = localStorage.getItem('orders');
    const orders: Order[] = ordersString ? JSON.parse(ordersString) : [];
    return orders.filter(order => 
      order.status === OrderStatus.PREPARING || order.status === OrderStatus.READY
    );
  },
  // Get completed orders (delivered or completed status)
  getCompletedOrders: async (): Promise<Order[]> => {
    await delay(600); // Simulate network delay
    const ordersString = localStorage.getItem('orders');
    const orders: Order[] = ordersString ? JSON.parse(ordersString) : [];
    return orders.filter(order => 
      order.status === OrderStatus.DELIVERED || order.status === OrderStatus.COMPLETED
    );
  },
  // Request the bill for an order
  requestBill: async (orderId: string): Promise<Order | null> => {
    await delay(1000); // Simulate network delay
    // Get orders from localStorage
    const ordersString = localStorage.getItem('orders');
    const orders: Order[] = ordersString ? JSON.parse(ordersString) : [];
    // Find the order
    const orderIndex = orders.findIndex(order => order.id === orderId);
    if (orderIndex === -1) {
      toast.error('Order not found');
      return null;
    }
    // Update the order status
    const updatedOrder = { 
      ...orders[orderIndex],
      status: OrderStatus.COMPLETED
    };
    const updatedOrders = [...orders];
    updatedOrders[orderIndex] = updatedOrder;
    // Save updated orders
    localStorage.setItem('orders', JSON.stringify(updatedOrders));
    toast.success('Bill requested successfully');
    return updatedOrder;
  },
  // Add tip to an order
  addTip: async (orderId: string, tipAmount: number): Promise<Order | null> => {
    await delay(700); // Simulate network delay
    // Get orders from localStorage
    const ordersString = localStorage.getItem('orders');
    const orders: Order[] = ordersString ? JSON.parse(ordersString) : [];
    // Find the order
    const orderIndex = orders.findIndex(order => order.id === orderId);
    if (orderIndex === -1) {
      toast.error('Order not found');
      return null;
    }
    // Update the order with tip
    const order = orders[orderIndex];
    const tipPercentage = (tipAmount / 100);
    const tipValue = order.subtotal * tipPercentage;
    const updatedOrder = { 
      ...order,
      tip: tipValue,
      total: order.subtotal + order.tax + tipValue
    };
    const updatedOrders = [...orders];
    updatedOrders[orderIndex] = updatedOrder;
    // Save updated orders
    localStorage.setItem('orders', JSON.stringify(updatedOrders));
    toast.success(`${tipAmount}% tip added successfully`);
    return updatedOrder;
  },
  // Process payment for an order
  processPayment: async (orderId: string, paymentMethod: string): Promise<Order | null> => {
    await delay(1500); // Simulate network delay
    // Get orders from localStorage
    const ordersString = localStorage.getItem('orders');
    const orders: Order[] = ordersString ? JSON.parse(ordersString) : [];
    // Find the order
    const orderIndex = orders.findIndex(order => order.id === orderId);
    if (orderIndex === -1) {
      toast.error('Order not found');
      return null;
    }
    // Update the order with payment status
    const updatedOrder = { 
      ...orders[orderIndex],
      paymentStatus: PaymentStatus.PAID,
      paymentMethod: paymentMethod
    };
    const updatedOrders = [...orders];
    updatedOrders[orderIndex] = updatedOrder;
    // Save updated orders
    localStorage.setItem('orders', JSON.stringify(updatedOrders));
    toast.success('Payment processed successfully');
    return updatedOrder;
  }
};
</file>

<file path="src/services/qrService.ts">
import { 
  verifyTableStatus, 
  getCategories, 
  getVenueMenuItems, 
  getVenueById,
  getSubcategories,
  getSubSubcategories,
  getMenuItems,
  Venue,
  Category,
  MenuItem,
  Subcategory,
  SubSubcategory
} from '@/api/menuService';
// Custom error types
export class TableError extends Error {
  constructor(message: string, public tableId: string) {
    super(message);
    this.name = 'TableError';
  }
}
export class VenueError extends Error {
  constructor(message: string, public venueId: string) {
    super(message);
    this.name = 'VenueError';
  }
}
export class MenuError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'MenuError';
  }
}
// Response interfaces
export interface QRScanResponse {
  table: {
    id: string;
    status: {
      exists: boolean;
      isAvailable: boolean;
      venue?: Venue;
    }
  };
  venue: Venue;
  menu: {
    categories: Category[];
    items: MenuItem[];
  }
}
export interface CategorySelectionResponse {
  subcategories: Subcategory[];
  menuItems: MenuItem[];
  category: {
    id: string;
    name: string;
  };
}
export interface SubcategorySelectionResponse {
  subsubcategories: SubSubcategory[];
  menuItems: MenuItem[];
  subcategory: {
    id: string;
    name: string;
  };
}
export interface SubSubcategorySelectionResponse {
  menuItems: MenuItem[];
  subsubcategory: {
    id: string;
    name: string;
  };
}
// Validation functions
const validateMenuData = (categories: Category[], items: MenuItem[]): boolean => {
  return Array.isArray(categories) && Array.isArray(items) && 
    categories.length > 0;
};
const validateCategoryData = (subcategories: Subcategory[], menuItems: MenuItem[]): boolean => {
  return Array.isArray(subcategories) && Array.isArray(menuItems);
};
const validateSubcategoryData = (subsubcategories: SubSubcategory[], menuItems: MenuItem[]): boolean => {
  return Array.isArray(subsubcategories) && Array.isArray(menuItems);
};
/**
 * Handles a table QR code scan and loads the venue-specific menu
 * @param tableId The ID of the table from the QR code
 * @returns Table, venue and menu information
 */
export const handleTableQRScan = async (tableId: string): Promise<QRScanResponse> => {
  try {
    // Step 1: Verify table and get venue info with retry logic
    let retries = 3;
    let tableStatus;
    while (retries > 0) {
      tableStatus = await verifyTableStatus(tableId);
      if (tableStatus.exists) break;
      retries--;
      if (retries > 0) await new Promise(resolve => setTimeout(resolve, 1000));
    }
    if (!tableStatus?.exists || !tableStatus?.isAvailable) {
      throw new TableError('Table not found or not available', tableId);
    }
    // Get venue info from table status
    const venue = tableStatus.venue;
    if (!venue) {
      throw new VenueError('Venue information not found for table', tableId);
    }
    // Step 2: Fetch menu data
    const [categories, menuItems] = await Promise.all([
      getCategories(venue.restaurantId),
      getVenueMenuItems(venue._id)
    ]);
    if (!validateMenuData(categories, menuItems)) {
      throw new MenuError('Invalid menu data received from server');
    }
    // Step 3: Structure the response
    return {
      table: {
        id: tableId,
        status: tableStatus
      },
      venue,
      menu: {
        categories,
        items: menuItems
      }
    };
  } catch (error) {
    console.error('Error handling QR code scan:', error);
    if (error instanceof TableError || error instanceof VenueError || error instanceof MenuError) {
      throw error;
    }
    throw new Error('Failed to process QR code scan');
  }
};
/**
 * Handles category selection and loads subcategories and menu items
 * @param categoryId The ID of the selected category
 * @param venueId The venue ID
 * @param categoryName Optional category name
 * @returns Subcategories and menu items for the selected category
 */
export const handleCategorySelection = async (
  categoryId: string, 
  venueId: string,
  categoryName?: string
): Promise<CategorySelectionResponse> => {
  try {
    const venue = await getVenueById(venueId);
    if (!venue) {
      throw new VenueError('Venue not found', venueId);
    }
    const [subcategories, menuItems] = await Promise.all([
      getSubcategories(categoryId, venue.restaurantId),
      getMenuItems(venue.restaurantId, categoryId, undefined, undefined, venueId)
    ]);
    if (!validateCategoryData(subcategories, menuItems)) {
      throw new MenuError('Invalid category data received from server');
    }
    return {
      subcategories,
      menuItems,
      category: {
        id: categoryId,
        name: categoryName || subcategories[0]?.categoryId || categoryId
      }
    };
  } catch (error) {
    console.error('Error handling category selection:', error);
    if (error instanceof VenueError || error instanceof MenuError) {
      throw error;
    }
    throw new Error(`Failed to process category selection for category ${categoryId}`);
  }
};
/**
 * Handles subcategory selection and loads subsubcategories and menu items
 * @param subcategoryId The ID of the selected subcategory
 * @param venueId The venue ID
 * @param subcategoryName Optional subcategory name
 * @returns Subsubcategories and menu items for the selected subcategory
 */
export const handleSubcategorySelection = async (
  subcategoryId: string, 
  venueId: string,
  subcategoryName?: string
): Promise<SubcategorySelectionResponse> => {
  try {
    const venue = await getVenueById(venueId);
    if (!venue) {
      throw new VenueError('Venue not found', venueId);
    }
    const [subsubcategories, menuItems] = await Promise.all([
      getSubSubcategories(subcategoryId, venue.restaurantId),
      getMenuItems(venue.restaurantId, undefined, subcategoryId, undefined, venueId)
    ]);
    if (!validateSubcategoryData(subsubcategories, menuItems)) {
      throw new MenuError('Invalid subcategory data received from server');
    }
    return {
      subsubcategories,
      menuItems,
      subcategory: {
        id: subcategoryId,
        name: subcategoryName || subcategoryId
      }
    };
  } catch (error) {
    console.error('Error handling subcategory selection:', error);
    if (error instanceof VenueError || error instanceof MenuError) {
      throw error;
    }
    throw new Error(`Failed to process subcategory selection for subcategory ${subcategoryId}`);
  }
};
/**
 * Handles subsubcategory selection and loads menu items
 * @param subsubcategoryId The ID of the selected subsubcategory
 * @param venueId The venue ID
 * @param subsubcategoryName Optional subsubcategory name
 * @returns Menu items for the selected subsubcategory
 */
export const handleSubSubcategorySelection = async (
  subsubcategoryId: string, 
  venueId: string,
  subsubcategoryName?: string
): Promise<SubSubcategorySelectionResponse> => {
  try {
    const venue = await getVenueById(venueId);
    if (!venue) {
      throw new VenueError('Venue not found', venueId);
    }
    const menuItems = await getMenuItems(
      venue.restaurantId, 
      undefined, 
      undefined, 
      subsubcategoryId, 
      venueId
    );
    if (!Array.isArray(menuItems)) {
      throw new MenuError('Invalid menu items data received from server');
    }
    return {
      menuItems,
      subsubcategory: {
        id: subsubcategoryId,
        name: subsubcategoryName || subsubcategoryId
      }
    };
  } catch (error) {
    console.error('Error handling subsubcategory selection:', error);
    if (error instanceof VenueError || error instanceof MenuError) {
      throw error;
    }
    throw new Error(`Failed to process subsubcategory selection for subsubcategory ${subsubcategoryId}`);
  }
};
</file>

<file path="src/types/menu.ts">
export interface MenuItem {
  id: string;
  name: string;
  description: string;
  price: number;
  image?: string;
  imageSearchTerm?: string;
  categoryId: string;
  subCategoryId?: string;
  featured?: boolean;
  tags?: string[];
  preparationTime?: string;
  rating?: number;
  modifiers?: MenuItemModifierGroup[];
}
export interface TableVerification {
  exists: boolean;
  isAvailable: boolean;
  table?: {
    _id: string;
    number: string;
    venueId: string;
  };
  venue?: {
    _id: string;
    name: string;
    description?: string;
  };
}
export interface Category {
  _id: string;
  name: string;
  image?: string;
  isActive?: boolean;
  subCategories?: string[];
}
export interface SubCategory {
  _id: string;
  name: string;
  categoryId?: string;
  subSubCategories?: string[];
}
export interface Menu {
  _id: string;
  name: string;
  description: string;
  restaurantId: string;
  venueId: {
    _id: string;
    name: string;
  };
  categories: Category[];
  subCategories: SubCategory[];
  createdAt: string;
  updatedAt: string;
}
</file>

<file path="src/types/Order.ts">
import { CartItem } from './index';
// Enhanced OrderStatus with more states - using uppercase values to match backend
export enum OrderStatus {
  PENDING = 'PENDING',
  PREPARING = 'PREPARING',
  READY = 'READY',
  DELIVERED = 'DELIVERED',
  COMPLETED = 'COMPLETED',
  CANCELLED = 'CANCELLED'
}
// Payment status - using uppercase values to match backend
export enum PaymentStatus {
  PENDING = 'PENDING',
  PAID = 'PAID',
  FAILED = 'FAILED',
  REFUNDED = 'REFUNDED'
}
// Order type
export enum OrderType {
  DINE_IN = 'DINE_IN',
  TAKEOUT = 'TAKEOUT'
}
export interface OrderItem {
  _id?: string;
  menuItem: string; // ID of the menu item
  menuItemId?: string; // Legacy support
  name: string;
  price: number;
  quantity: number;
  subtotal: number;
  modifiers?: {
    name: string;
    options?: {
      name: string;
      price: number;
    }[];
    price?: number;
  }[];
  specialInstructions?: string;
}
export interface Order {
  id: string;
  _id?: string; // For API compatibility
  orderNumber?: string;
  userId?: string;
  restaurantId?: string;
  tableId: string;
  items: CartItem[];
  subtotal: number;
  tax: number;
  tip: number;
  serviceFee?: number;
  total: number;
  status: string | OrderStatus;
  paymentStatus?: string | PaymentStatus;
  orderType?: string | OrderType;
  specialInstructions?: string;
  timestamp: Date;
}
// API response type for order creation
export interface OrderResponseData {
  _id: string;
  orderNumber: string;
  restaurantId: string;
  tableId: string;
  items: OrderItem[];
  subtotal: number;
  tax: number;
  tip: number;
  serviceFee: number;
  total: number;
  status: string;
  paymentStatus: string;
  orderType: string;
  specialInstructions?: string;
  createdAt: string;
  updatedAt: string;
}
</file>

<file path="src/utils/__tests__/dataTransformers.test.ts">
import {
  transformRestaurant,
  transformVenue,
  transformCategory,
  transformSubcategory,
  transformMenuItem,
  transformTableMenu,
  transformMenuHierarchy,
  validateRequiredFields,
  UiRestaurant,
  UiVenue,
  UiCategory,
  UiSubcategory
} from '../dataTransformers';
import { ApiError } from '../../api/menuService';
import { MenuItem as UiMenuItem } from '../../types/menu';
describe('Data Transformers', () => {
  describe('transformRestaurant', () => {
    it('should transform API restaurant format to UI format', () => {
      const apiRestaurant = {
        _id: "68187734a6d5090de7422456",
        name: "CINEMA CITY ARABIAN CENTRE",
        venues: [],
        tables: [],
        adminIds: [],
        locations: [],
        menu: [],
        schedule: [],
        createdAt: "2025-05-05T08:30:44.441Z",
        updatedAt: "2025-05-05T08:30:44.441Z",
        __v: 0
      };
      const expected: UiRestaurant = {
        id: "68187734a6d5090de7422456",
        name: "CINEMA CITY ARABIAN CENTRE",
        venues: []
      };
      expect(transformRestaurant(apiRestaurant)).toEqual(expected);
    });
    it('should transform restaurant with venues', () => {
      const apiRestaurant = {
        _id: "68187734a6d5090de7422456",
        name: "CINEMA CITY ARABIAN CENTRE",
        venues: [
          {
            _id: "venue1",
            name: "Main Hall",
            description: "Main dining area",
            restaurantId: {
              _id: "68187734a6d5090de7422456",
              name: "CINEMA CITY ARABIAN CENTRE"
            }
          }
        ],
        createdAt: "2025-05-05T08:30:44.441Z",
        updatedAt: "2025-05-05T08:30:44.441Z"
      };
      const result = transformRestaurant(apiRestaurant);
      expect(result.id).toBe("68187734a6d5090de7422456");
      expect(result.name).toBe("CINEMA CITY ARABIAN CENTRE");
      expect(result.venues).toHaveLength(1);
      expect(result.venues?.[0].id).toBe("venue1");
      expect(result.venues?.[0].name).toBe("Main Hall");
    });
    it('should throw error for invalid restaurant data', () => {
      const invalidData = {
        name: "Test Restaurant"
        // Missing _id
      };
      expect(() => transformRestaurant(invalidData)).toThrow(ApiError);
    });
  });
  describe('transformVenue', () => {
    it('should transform API venue format to UI format', () => {
      const apiVenue = {
        _id: "venue1",
        name: "Main Hall",
        description: "Main dining area",
        restaurantId: {
          _id: "rest1",
          name: "CINEMA CITY"
        }
      };
      const expected: UiVenue = {
        id: "venue1",
        name: "Main Hall",
        description: "Main dining area",
        restaurantId: "rest1",
        restaurantName: "CINEMA CITY"
      };
      expect(transformVenue(apiVenue)).toEqual(expected);
    });
    it('should handle missing optional fields', () => {
      const apiVenue = {
        _id: "venue1",
        name: "Main Hall",
        restaurantId: {
          _id: "rest1"
        }
      };
      const result = transformVenue(apiVenue);
      expect(result.description).toBe('');
      expect(result.restaurantId).toBe('rest1');
      expect(result.restaurantName).toBeUndefined();
    });
    it('should throw error for invalid venue data', () => {
      const invalidData = {
        description: "Main dining area"
        // Missing _id and name
      };
      expect(() => transformVenue(invalidData as any)).toThrow(ApiError);
    });
  });
  describe('transformCategory', () => {
    it('should transform API category format to UI format', () => {
      const apiCategory = {
        _id: "cat1",
        name: "Burgers",
        description: "Delicious burgers",
        image: "burger.jpg",
        isActive: true,
        order: 1,
        restaurantId: "rest1"
      };
      const expected: UiCategory = {
        id: "cat1",
        name: "Burgers",
        description: "Delicious burgers",
        image: "burger.jpg",
        restaurantId: "rest1",
        order: 1
      };
      expect(transformCategory(apiCategory)).toEqual(expected);
    });
    it('should handle missing optional fields', () => {
      const apiCategory = {
        _id: "cat1",
        name: "Burgers"
      };
      const result = transformCategory(apiCategory);
      expect(result.id).toBe("cat1");
      expect(result.name).toBe("Burgers");
      expect(result.image).toBe('');
      expect(result.description).toBeUndefined();
      expect(result.order).toBeUndefined();
    });
    it('should throw error for invalid category data', () => {
      const invalidData = {
        _id: "cat1"
        // Missing name
      };
      expect(() => transformCategory(invalidData as any)).toThrow(ApiError);
    });
  });
  describe('transformSubcategory', () => {
    it('should transform API subcategory format to UI format', () => {
      const apiSubcategory = {
        _id: "subcat1",
        name: "Beef Burgers",
        description: "All beef burgers",
        image: "beef.jpg",
        isActive: true,
        order: 1,
        categoryId: "cat1"
      };
      const expected: UiSubcategory = {
        id: "subcat1",
        name: "Beef Burgers",
        description: "All beef burgers",
        image: "beef.jpg",
        categoryId: "cat1",
        order: 1
      };
      expect(transformSubcategory(apiSubcategory)).toEqual(expected);
    });
    it('should handle missing optional fields', () => {
      const apiSubcategory = {
        _id: "subcat1",
        name: "Beef Burgers",
        categoryId: "cat1"
      };
      const result = transformSubcategory(apiSubcategory);
      expect(result.id).toBe("subcat1");
      expect(result.name).toBe("Beef Burgers");
      expect(result.categoryId).toBe("cat1");
      expect(result.image).toBe('');
      expect(result.description).toBeUndefined();
    });
    it('should throw error for invalid subcategory data', () => {
      const invalidData = {
        _id: "subcat1",
        // Missing name
        categoryId: "cat1"
      };
      expect(() => transformSubcategory(invalidData as any)).toThrow(ApiError);
    });
  });
  describe('transformMenuItem', () => {
    it('should transform API menu item format to UI format', () => {
      const apiMenuItem = {
        _id: "item1",
        name: "Classic Burger",
        description: "Juicy beef patty",
        price: 15.99,
        image: "burger.jpg",
        categories: ["cat1"],
        subCategories: ["subcat1"],
        isAvailable: true,
        isActive: true
      };
      const result = transformMenuItem(apiMenuItem);
      // Check that result conforms to the UI MenuItem interface
      const expectedMenuItem: UiMenuItem = {
        id: "item1",
        name: "Classic Burger",
        description: "Juicy beef patty",
        price: 15.99,
        image: "burger.jpg",
        imageSearchTerm: "",
        category: "cat1",
        categoryId: "cat1",
        subcategory: "subcat1",
        featured: false,
        popular: false,
        tags: []
      };
      expect(result).toEqual(expectedMenuItem);
    });
    it('should handle menu items without categories', () => {
      const apiMenuItem = {
        _id: "item1",
        name: "Classic Burger",
        description: "Juicy beef patty",
        price: 15.99,
        image: "burger.jpg",
        categories: [],
        isAvailable: true,
        isActive: true
      };
      const result = transformMenuItem(apiMenuItem);
      expect(result.category).toBe('');
      expect(result.categoryId).toBe('');
      expect(result.subcategory).toBeUndefined();
    });
    it('should handle menu items with missing fields', () => {
      const apiMenuItem = {
        _id: "item1",
        name: "Classic Burger",
        price: 15.99,
        categories: ["cat1"],
        isAvailable: true,
        isActive: true
      };
      const result = transformMenuItem(apiMenuItem);
      expect(result.description).toBe('');
      expect(result.image).toBe('');
    });
    it('should throw error for invalid menu item data', () => {
      const invalidData = {
        _id: "item1",
        // Missing name
        price: 15.99
      };
      expect(() => transformMenuItem(invalidData as any)).toThrow(ApiError);
    });
  });
  describe('transformTableMenu', () => {
    it('should transform complete table menu data', () => {
      const apiTableMenu = {
        venue: {
          _id: 'venue1',
          name: 'Test Venue',
          description: 'Test description'
        },
        menu: {
          categories: [{
            _id: 'cat1',
            name: 'Burgers',
            image: 'burger.jpg',
            description: 'Burgers category',
            isActive: true,
            order: 1,
            restaurantId: 'rest1'
          }],
          subcategories: {},
          menuItems: [{
            _id: 'item1',
            name: 'Classic Burger',
            description: 'Delicious burger',
            price: 9.99,
            image: 'burger.jpg',
            categories: ['cat1'],
            isAvailable: true,
            isActive: true
          }]
        }
      };
      const result = transformTableMenu(apiTableMenu);
      expect(result).toHaveProperty('categories');
      expect(result).toHaveProperty('menuItems');
      expect(result.categories).toHaveLength(1);
      expect(result.menuItems).toHaveLength(1);
      // Check transformed category
      expect(result.categories[0].id).toBe('cat1');
      expect(result.categories[0].name).toBe('Burgers');
      // Check transformed menu item
      expect(result.menuItems[0].id).toBe('item1');
      expect(result.menuItems[0].name).toBe('Classic Burger');
      expect(result.menuItems[0].categoryId).toBe('cat1');
    });
    it('should throw error for invalid table menu data', () => {
      // Missing categories
      const invalidTableMenu = {
        venue: {
          _id: 'venue1',
          name: 'Test Venue'
        },
        menu: {
          menuItems: []
        }
      };
      expect(() => transformTableMenu(invalidTableMenu as any)).toThrow(ApiError);
    });
  });
  describe('transformMenuHierarchy', () => {
    it('should transform complete menu hierarchy', () => {
      const apiData = {
        categories: [{
          _id: "cat1",
          name: "Burgers",
          image: "burger.jpg",
          isActive: true,
          order: 1
        }],
        subcategories: {
          "cat1": [{
            _id: "subcat1",
            name: "Beef Burgers",
            image: "beef.jpg",
            categoryId: "cat1",
            isActive: true,
            order: 1
          }]
        },
        subsubcategories: {},
        menuItems: [{
          _id: "item1",
          name: "Classic Burger",
          description: "Juicy beef patty",
          price: 15.99,
          image: "burger.jpg",
          categories: ["cat1"],
          subCategories: ["subcat1"],
          isAvailable: true,
          isActive: true
        }]
      };
      const result = transformMenuHierarchy(apiData);
      // Check categories
      expect(result.categories).toHaveLength(1);
      expect(result.categories[0].id).toBe("cat1");
      expect(result.categories[0].name).toBe("Burgers");
      // Check subcategories
      expect(result.subcategories["cat1"]).toHaveLength(1);
      expect(result.subcategories["cat1"][0].id).toBe("subcat1");
      expect(result.subcategories["cat1"][0].name).toBe("Beef Burgers");
      // Check menu items
      expect(result.menuItems).toHaveLength(1);
      expect(result.menuItems[0].id).toBe("item1");
      expect(result.menuItems[0].name).toBe("Classic Burger");
      expect(result.menuItems[0].category).toBe("cat1");
    });
    it('should handle empty subcategories', () => {
      const apiData = {
        categories: [{
          _id: "cat1",
          name: "Burgers",
          image: "burger.jpg",
          isActive: true
        }],
        subcategories: {},
        subsubcategories: {},
        menuItems: [{
          _id: "item1",
          name: "Classic Burger",
          price: 15.99,
          categories: ["cat1"],
          isAvailable: true,
          isActive: true
        }]
      };
      const result = transformMenuHierarchy(apiData);
      expect(result.categories).toHaveLength(1);
      expect(Object.keys(result.subcategories)).toHaveLength(0);
      expect(result.menuItems).toHaveLength(1);
    });
  });
  describe('validateRequiredFields', () => {
    it('should validate required fields successfully', () => {
      const data = {
        field1: 'value1',
        field2: 'value2',
        field3: null
      };
      expect(() => validateRequiredFields(data, ['field1', 'field2'])).not.toThrow();
    });
    it('should throw error for missing required fields', () => {
      const data = {
        field1: 'value1',
        field2: undefined
      };
      expect(() => validateRequiredFields(data, ['field1', 'field2']))
        .toThrow('Missing required field: field2');
    });
    it('should throw error for null values', () => {
      const data
</file>

<file path="src/utils/dataTransformers.ts">
import { ApiError } from '../api/menuService';
import { 
  Category, 
  MenuItem as ApiMenuItem, 
  Subcategory, 
  TableMenu, 
  Venue 
} from '../api/menuService';
import { MenuItem as UiMenuItem } from '../types/menu';
// Type definitions for UI data structures
export interface UiRestaurant {
  id: string;
  name: string;
  description?: string;
  logoUrl?: string;
  address?: string;
  venues?: UiVenue[];
}
export interface UiVenue {
  id: string;
  name: string;
  description: string;
  restaurantId: string;
  restaurantName?: string;
}
export interface UiCategory {
  id: string;
  name: string;
  image: string;
  description?: string;
  restaurantId?: string;
  order?: number;
}
export interface UiSubcategory {
  id: string;
  name: string;
  image: string;
  description?: string;
  categoryId: string;
  order?: number;
}
/**
 * Transform API restaurant data to UI format
 * Maps _id to id and preserves other fields as appropriate
 */
export function transformRestaurant(apiRestaurant: any): UiRestaurant {
  if (!apiRestaurant?._id || !apiRestaurant?.name) {
    throw new ApiError('Invalid restaurant data format', 400);
  }
  return {
    id: apiRestaurant._id,
    name: apiRestaurant.name,
    description: apiRestaurant.description,
    logoUrl: apiRestaurant.logoUrl,
    address: apiRestaurant.address,
    venues: Array.isArray(apiRestaurant.venues) 
      ? apiRestaurant.venues.map(transformVenue)
      : undefined
  };
}
/**
 * Transform API venue data to UI format
 * Maps _id to id and preserves other fields as appropriate
 */
export function transformVenue(apiVenue: Venue): UiVenue {
  if (!apiVenue?._id || !apiVenue?.name) {
    throw new ApiError('Invalid venue data format', 400);
  }
  return {
    id: apiVenue._id,
    name: apiVenue.name,
    description: apiVenue.description || '',
    restaurantId: apiVenue.restaurantId?._id || '',
    restaurantName: apiVenue.restaurantId?.name
  };
}
/**
 * Transform API category data to UI format
 * Maps _id to id and preserves other fields as appropriate
 */
export function transformCategory(apiCategory: Category): UiCategory {
  if (!apiCategory?._id || !apiCategory?.name) {
    throw new ApiError('Invalid category data format', 400);
  }
  return {
    id: apiCategory._id,
    name: apiCategory.name,
    image: apiCategory.image || '',
    description: apiCategory.description,
    restaurantId: apiCategory.restaurantId,
    order: apiCategory.order
  };
}
/**
 * Transform API subcategory data to UI format
 * Maps _id to id and preserves other fields as appropriate
 */
export function transformSubcategory(apiSubcategory: Subcategory): UiSubcategory {
  if (!apiSubcategory?._id || !apiSubcategory?.name) {
    throw new ApiError('Invalid subcategory data format', 400);
  }
  return {
    id: apiSubcategory._id,
    name: apiSubcategory.name,
    image: apiSubcategory.image || '',
    description: apiSubcategory.description,
    categoryId: apiSubcategory.categoryId,
    order: apiSubcategory.order
  };
}
/**
 * Transform API menu item to UI format
 * Maps _id to id and adapts fields to match the UI MenuItem interface
 */
export function transformMenuItem(apiMenuItem: ApiMenuItem): UiMenuItem {
  if (!apiMenuItem?._id || !apiMenuItem?.name) {
    throw new ApiError('Invalid menu item data format', 400);
  }
  return {
    id: apiMenuItem._id,
    name: apiMenuItem.name,
    description: apiMenuItem.description || '',
    price: apiMenuItem.price,
    image: apiMenuItem.image || '',
    imageSearchTerm: '', // This field doesn't exist in API, defaulting to empty
    category: apiMenuItem.categories?.[0] || '', // Take first category as primary
    categoryId: apiMenuItem.categories?.[0] || '', // Using first category ID
    subcategory: apiMenuItem.subCategories?.[0], // Optional subcategory
    featured: false, // Default values since these fields don't exist in API
    popular: false, 
    tags: [], // No direct mapping in API, defaulting to empty array
    // Add any additional fields from the UI MenuItem interface with sensible defaults
  };
}
/**
 * Transform entire table menu from API to UI format
 * Returns categories and menu items in the UI format
 */
export function transformTableMenu(tableMenu: TableMenu): {
  categories: UiCategory[];
  menuItems: UiMenuItem[];
} {
  if (!tableMenu?.menu?.categories || !tableMenu?.menu?.menuItems) {
    throw new ApiError('Invalid table menu data format', 400);
  }
  const transformedCategories = tableMenu.menu.categories.map(transformCategory);
  const transformedMenuItems = tableMenu.menu.menuItems.map(transformMenuItem);
  return {
    categories: transformedCategories,
    menuItems: transformedMenuItems
  };
}
/**
 * Transform entire menu hierarchy to UI format
 * Handles categories, subcategories, and menu items
 */
export function transformMenuHierarchy(apiData: {
  categories: Category[];
  subcategories: { [categoryId: string]: Subcategory[] };
  subsubcategories: { [subcategoryId: string]: Subcategory[] };
  menuItems: ApiMenuItem[];
}): {
  categories: UiCategory[];
  subcategories: { [categoryId: string]: UiSubcategory[] };
  subsubcategories: { [subcategoryId: string]: UiSubcategory[] };
  menuItems: UiMenuItem[];
} {
  // Transform categories
  const transformedCategories = apiData.categories.map(transformCategory);
  // Transform subcategories
  const transformedSubcategories: { [categoryId: string]: UiSubcategory[] } = {};
  Object.entries(apiData.subcategories).forEach(([categoryId, subcategories]) => {
    transformedSubcategories[categoryId] = subcategories.map(transformSubcategory);
  });
  // Transform subsubcategories
  const transformedSubsubcategories: { [subcategoryId: string]: UiSubcategory[] } = {};
  Object.entries(apiData.subsubcategories).forEach(([subcategoryId, subsubcategories]) => {
    transformedSubsubcategories[subcategoryId] = subsubcategories.map(transformSubcategory);
  });
  // Transform menu items
  const transformedMenuItems = apiData.menuItems.map(transformMenuItem);
  return {
    categories: transformedCategories,
    subcategories: transformedSubcategories,
    subsubcategories: transformedSubsubcategories,
    menuItems: transformedMenuItems
  };
}
/**
 * Helper function to validate required fields in data objects
 * Throws an ApiError if any required fields are missing
 */
export function validateRequiredFields(data: any, requiredFields: string[]): void {
  for (const field of requiredFields) {
    if (data[field] === undefined || data[field] === null) {
      throw new ApiError(`Missing required field: ${field}`, 400);
    }
  }
}
</file>

<file path="src/main.tsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ThemeProvider } from 'next-themes';
import App from './App';
import './index.css';
import { StagewiseToolbar } from '@stagewise/toolbar-react';
// Create a new client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 1,
      staleTime: 1000 * 60 * 5, // 5 minutes
    },
  },
});
// Stagewise configuration
const stagewiseConfig = {
  plugins: []
};
// Only include StagewiseToolbar in development
const ToolbarWrapper = import.meta.env.DEV ? () => (
  <StagewiseToolbar config={stagewiseConfig} />
) : () => null;
ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ThemeProvider attribute="class" defaultTheme="dark" enableSystem>
      <QueryClientProvider client={queryClient}>
        <App />
        <ToolbarWrapper />
      </QueryClientProvider>
    </ThemeProvider>
  </React.StrictMode>,
);
</file>

<file path="src/README-API-INTEGRATION.md">
# InSeat Menu API Integration

## Summary of Changes

This document summarizes the changes made to integrate real API endpoints for fetching menu data instead of using static JSON files.

### Files Changed

1. **src/hooks/useMenuItems.ts**
   - Replaced JSON file loading with API call using `getMenuItems` from menuService
   - Added parameters for `restaurantId`, `categoryId`, and `subcategoryId`
   - Added data transformation to map API response to expected MenuItem interface
   - Updated dependency array to re-fetch when filter parameters change

2. **src/services/api.ts**
   - Removed JSON file imports
   - Replaced static data with API calls using functions from menuService
   - Added transformation functions to map API data to application interfaces
   - Maintained the same function signatures to avoid breaking changes
   - Removed artificial delays since we're using real API calls now
   - Added error handling for API calls

3. **src/pages/MenuItemDetail.tsx**
   - Removed JSON fallback mechanism
   - Simplified API fetching logic to use only the API service
   - Removed the fallback warning banner
   - Added better error handling

### New Data Flow

The application now follows this data flow for menu data:

1. **API Layer** (`src/api/menuService.ts`)
   - Contains the core API functions that communicate directly with the backend
   - Handles HTTP requests using axios
   - Provides typed interfaces for API responses
   - Functions: `getCategories`, `getSubcategories`, `getMenuItems`

2. **Service Layer** (`src/services/api.ts`)
   - Acts as a facade over the API layer
   - Transforms API responses to match application interfaces
   - Provides consistent error handling
   - Maintains backward compatibility with existing code

3. **Hook Layer** (`src/hooks/useMenuItems.ts`)
   - Custom React hook that consumes the service layer
   - Manages loading and error states
   - Provides reactive data based on filter parameters

4. **Component Layer** (various components)
   - Consumes hooks and services to display data
   - No longer directly imports JSON files

### Benefits of the New Implementation

1. **Real-time Data**: The application now displays real data from the backend
2. **Filtering**: Menu items can be filtered by category and subcategory on the server side
3. **Consistency**: API responses ensure data structure consistency
4. **Maintainability**: Separation of concerns between API calls and UI components
5. **Error Handling**: Proper error handling throughout the application

## Potential Improvements

1. **Caching**: Implement React Query's caching capabilities more extensively to minimize API calls
2. **Pagination**: Add support for paginated API responses for large menu datasets
3. **Search Endpoint**: Create a dedicated API endpoint for searching instead of client-side filtering
4. **Featured/Popular Items**: Add backend support for featured and popular flags instead of simulating them client-side
5. **API Versioning**: Implement API versioning to handle future changes to endpoints
6. **State Management**: Consider using a central state management solution for shared data
7. **Environment Configuration**: Make the restaurant ID configurable through environment variables
8. **Error Boundaries**: Add React Error Boundaries to gracefully handle component-level errors
9. **Optimistic Updates**: Implement optimistic updates for adding to cart, favorites, etc.
10. **Offline Support**: Add offline capabilities by caching API responses

## Testing Recommendations

1. **Unit Tests**:
   - Test the transformation functions in `api.ts`
   - Test the `useMenuItems` hook with various parameter combinations
   - Mock API responses to test error handling

2. **Integration Tests**:
   - Test the data flow from API to UI
   - Verify that components render correctly with real API data
   - Test filtering and search functionality

3. **API Mock Tests**:
   - Create mock API responses for testing
   - Test with various error scenarios
   - Test with empty, partial, and complete data

4. **End-to-End Tests**:
   - Test the complete user flow from browsing categories to ordering
   - Test with real backend or a staging environment
   - Verify loading states and error messages

5. **Performance Tests**:
   - Measure API response times and component rendering
   - Test with large datasets to ensure performance
   - Verify that filtering is efficient

## Implementation Notes

- A default restaurant ID (`rest1`) is used throughout the application. In a production environment, this should be configurable or determined based on the user's context.
- The API transformation functions handle differences between API response formats and the application's expected formats.
- Some features like 'featured' and 'popular' items are currently simulated client-side since the API doesn't support these flags yet.
- API error handling returns empty arrays or undefined values with console error logging to avoid breaking the UI.
</file>

<file path="cookies.txt">
# Netscape HTTP Cookie File
# https://curl.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

#HttpOnly_localhost	FALSE	/	TRUE	1749030891	refresh_token	eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY4MzZkZDZiZTkwNmRlNWNhODBlOWViOSIsImlhdCI6MTc0ODQyNjA5MSwiZXhwIjoxNzQ5MDMwODkxfQ.2yWSoxUc6njh6mKMe69n9GiM2UF9IzPtE526ykPK2EM
#HttpOnly_localhost	FALSE	/	TRUE	1748512491	access_token	eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY4MzZkZDZiZTkwNmRlNWNhODBlOWViOSIsImVtYWlsIjoidGVzdEBleGFtcGxlLmNvbSIsInJvbGUiOiJjdXN0b21lciIsImlhdCI6MTc0ODQyNjA5MSwiZXhwIjoxNzQ4NTEyNDkxfQ.wKP_VmXbUZGF8SE8GFUA7OXQzDQ3b6ShaTmlEkbFpbM
</file>

<file path="deploy.sh">
#!/bin/bash
# Deployment script for INSEAT Menu
# Set error handling
set -e
# Log function
log() {
    echo "[$(date +"%Y-%m-%d %H:%M:%S")] $1"
}
# Check if we are deploying to production
if [ "$1" != "production" ]; then
    log "Error: Please specify environment. Usage: ./deploy.sh production"
    exit 1
fi
# Ensure we have the required environment files
if [ ! -f .env.production ]; then
    log "Error: .env.production file is missing"
    exit 1
fi
# Build for production
log "Building for production environment..."
echo "NODE_ENV=production" > .env.local
cp .env.production .env
# Run the build
log "Running build command..."
npm run build
# Verify the build
if [ -d "dist" ]; then
    log "Build completed successfully"
else
    log "Error: Build failed - dist directory not found"
    exit 1
fi
log "Deployment build completed successfully"
</file>

<file path="docker-compose.yml">
services:
  inseat-backend:
    build:
      context: .
      dockerfile: Dockerfile
    image: inseat-backend:latest
    container_name: inseat-backend
    ports:
      - "3001:3001"
    env_file:
      - .env
    environment:
      - KAFKA_BROKERS=kafka:29092
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: curl -f http://localhost:3001/health || exit 1
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    networks:
      - inseat-network
    depends_on:
      - redis
      - kafka
  redis:
    image: redis:latest
    container_name: redis
    ports:
      - "6379:6379"
    networks:
      - inseat-network
  zookeeper:
    image: confluentinc/cp-zookeeper:latest
    container_name: zookeeper
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    networks:
      - inseat-network
  kafka:
    image: confluentinc/cp-kafka:latest
    container_name: kafka
    ports:
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:29092,PLAINTEXT_HOST://localhost:9092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
    depends_on:
      - zookeeper
    networks:
      - inseat-network
networks:
  inseat-network:
    driver: bridge
volumes:
  mongodb_data:
</file>

<file path="INSEAT-MENU-INTEGRATION.md">
# INSEAT Menu System Integration Documentation

## 1. Overview

This documentation outlines the integration between INSEAT-Backend and inseat-menu to create a table-specific menu viewing system. When users scan a QR code associated with a table, they should be directed to a menu page showing the menu items available at that venue.

## 2. System Architecture

### Backend Structure (INSEAT-Backend)

The INSEAT-Backend application follows a modular architecture with services:

```
/home/abenezer/Desktop/work/INSEAT-Backend/
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ restaurant-service/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ TableController.ts     # Table controller that needs to be updated
â”‚   â”‚   â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ table.routes.ts        # Table routes that need to be updated
â”‚   â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Table.ts               # Table model
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Venue.ts               # Venue model
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Category.ts            # Category model
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ MenuItem.ts            # Menu item model
```

### Frontend Structure (inseat-menu)

The inseat-menu application is a React-based frontend:

```
/home/abenezer/Desktop/work/inseat-menu/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ menuService.ts          # API integration service (exists, needs updates)
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ QRScanner.tsx           # QR code scanner component (exists)
â”‚   â”‚   â”œâ”€â”€ menu/
â”‚   â”‚   â”‚   â”œâ”€â”€ MenuGrid.tsx        # Grid for menu items (exists)
â”‚   â”‚   â”‚   â””â”€â”€ MenuItemCard.tsx    # Individual menu item display (exists)
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â””â”€â”€ useQRScanner.ts         # QR scanner hook (exists)
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ Menu.tsx                # Menu display page (exists, needs updates)
â”‚   â”‚   â””â”€â”€ ScanTable.tsx           # QR scanning page (to be created)
â”‚   â””â”€â”€ App.tsx                     # Main application component with routing (exists, needs updates)
```

## 3. Required Backend Endpoints

### 1. Table Verification Endpoint (TO BE IMPLEMENTED)

**Purpose**: Verify if a table exists and is available for use.

**Endpoint**:
```
GET /api/tables/{tableId}/verify
```

**Example Response (Success)**:
```json
{
  "exists": true,
  "isAvailable": true,
  "venue": {
    "_id": "67f6056fc5f5d349242273c6",
    "name": "Screen 2",
    "description": "Screen 2 at CINEMA CITY ARABIAN CENTRE",
    "capacity": 88,
    "restaurantId": {
      "_id": "67f6056fc5f5d349242273c2",
      "name": "CINEMA CITY ARABIAN CENTRE"
    }
  },
  "table": {
    "_id": "67f60565c5f5d349242273a2",
    "number": "T123",
    "venueId": "67f6056fc5f5d349242273c6",
    "capacity": 4,
    "isOccupied": false,
    "isActive": true
  }
}
```

**Example Response (Table Not Found)**:
```json
{
  "exists": false,
  "isAvailable": false,
  "error": "Table not found"
}
```

### 2. Table Menu Endpoint (TO BE IMPLEMENTED)

**Purpose**: Get the complete menu hierarchy for a table's venue.

**Endpoint**:
```
GET /api/tables/{tableId}/menu
```

**Example Response**:
```json
{
  "venue": {
    "_id": "67f6056fc5f5d349242273c6",
    "name": "Screen 2",
    "description": "Screen 2 at CINEMA CITY ARABIAN CENTRE"
  },
  "menu": {
    "categories": [
      {
        "_id": "681390684d05b2857e931219",
        "name": "FOOD",
        "description": "FOOD category",
        "image": "https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg",
        "isActive": true,
        "order": 1
      }
    ],
    "subcategories": {
      "681390684d05b2857e931219": [
        {
          "_id": "6813906a4d05b2857e931230",
          "name": "NOODLES",
          "description": "NOODLES subcategory",
          "image": "https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg",
          "isActive": true,
          "order": 0
        }
      ]
    },
    "menuItems": [
      {
        "_id": "67f7bff6fc06b1668c789281",
        "name": "Main Menu",
        "description": "Our primary selection of dishes.",
        "price": 12.99,
        "image": "image_url",
        "categories": [
          {
            "_id": "681390684d05b2857e931219",
            "name": "FOOD"
          }
        ],
        "subCategories": [
          {
            "_id": "6813906a4d05b2857e931230",
            "name": "NOODLES"
          }
        ],
        "isAvailable": true,
        "isActive": true
      }
    ]
  }
}
```

## 4. Backend Implementation Details

### 1. Table Verification Endpoint Implementation

Update `/home/abenezer/Desktop/work/INSEAT-Backend/services/restaurant-service/src/controllers/TableController.ts`:

```typescript
// Add this method to the TableController class
public async verifyTable(req: Request, res: Response): Promise<void> {
  try {
    const { tableId } = req.params;
    
    console.log(`Verifying table with ID: ${tableId}`);
    
    // Find table by ID
    const table = await Table.findById(tableId);
    
    if (!table) {
      return res.json({
        exists: false,
        isAvailable: false,
        error: "Table not found"
      });
    }
    
    // Find venue
    const venue = await Venue.findById(table.venueId).populate('restaurantId', 'name');
    
    if (!venue) {
      return res.json({
        exists: true,
        isAvailable: false,
        error: "Venue not found"
      });
    }
    
    const isAvailable = table.isActive && !table.isOccupied;
    
    return res.json({
      exists: true,
      isAvailable,
      venue,
      table
    });
  } catch (error) {
    console.error('Error verifying table:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
    return res.status(500).json({
      error: true,
      message: "Server error while verifying table",
      details: errorMessage
    });
  }
}
```

### 2. Table Menu Endpoint Implementation

Add to `/home/abenezer/Desktop/work/INSEAT-Backend/services/restaurant-service/src/controllers/TableController.ts`:

```typescript
// Add this method to the TableController class
public async getTableMenu(req: Request, res: Response): Promise<void> {
  try {
    const { tableId } = req.params;
    
    console.log(`Getting menu for table with ID: ${tableId}`);
    
    // Find table by ID
    const table = await Table.findById(tableId);
    if (!table) {
      return res.status(404).json({
        error: true,
        message: "Table not found"
      });
    }
    
    // Find venue
    const venue = await Venue.findById(table.venueId);
    if (!venue) {
      return res.status(404).json({
        error: true,
        message: "Venue not found"
      });
    }
    
    // Get restaurant ID
    const restaurantId = venue.restaurantId;
    
    // Get categories for this venue
    const categories = await Category.find({
      restaurantId,
      isActive: true
    }).sort({ order: 1 });
    
    // Get subcategories organized by category
    const subcategoriesMap = {};
    for (const category of categories) {
      const subcategories = await Subcategory.find({
        categoryId: category._id,
        isActive: true
      }).sort({ order: 1 });
      
      subcategoriesMap[category._id] = subcategories;
    }
    
    // Get menu items for this venue
    const menuItems = await MenuItem.find({
      venueId: venue._id,
      isActive: true
    });
    
    return res.json({
      venue: {
        _id: venue._id,
        name: venue.name,
        description: venue.description
      },
      menu: {
        categories,
        subcategories: subcategoriesMap,
        menuItems
      }
    });
  } catch (error) {
    console.error('Error fetching table menu:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
    return res.status(500).json({
      error: true,
      message: "Server error while fetching table menu",
      details: errorMessage
    });
  }
}
```

### 3. Update Table Routes

Update `/home/abenezer/Desktop/work/INSEAT-Backend/services/restaurant-service/src/routes/table.routes.ts`:

```typescript
// Add these routes to the router
router.route('/tables/:tableId/verify')
  .get(validateIds, controller.verifyTable.bind(controller));

router.route('/tables/:tableId/menu')
  .get(validateIds, controller.getTableMenu.bind(controller));
```

## 5. Frontend Implementation Details

### 1. Create ScanTable.tsx

Create a new file at `/home/abenezer/Desktop/work/inseat-menu/src/pages/ScanTable.tsx`:

```tsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { QrReader } from 'react-qr-reader';
import { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { verifyTableStatus } from '@/api/menuService';
import { Loader2 } from 'lucide-react';

export const ScanTable: React.FC = () => {
  const navigate = useNavigate();
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [showScanner, setShowScanner] = useState(false);

  const handleScan = async (result: string | null) => {
    if (result && !loading) {
      setLoading(true);
      setError(null);
      
      try {
        const tableId = result; // In real implementation, parse QR code content
        const verification = await verifyTableStatus(tableId);
        
        if (verification.exists && verification.isAvailable) {
          navigate(`/${tableId}`);
        } else {
          setError(verification.exists ? 
            'This table is currently not available.' : 
            'Invalid table QR code.');
        }
      } catch (err) {
        setError('Failed to verify table. Please try again.');
      } finally {
        setLoading(false);
      }
    }
  };

  return (
    <div className="container mx-auto px-4 py-8 flex flex-col items-center justify-center min-h-screen">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle>Welcome to INSEAT</CardTitle>
          <CardDescription>
            Scan your table's QR code to view the menu
          </CardDescription>
        </CardHeader>
        <CardContent>
          {error && (
            <Alert variant="destructive" className="mb-4">
              <AlertTitle>Error</AlertTitle>
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          
          {showScanner ? (
            <div className="relative aspect-square w-full">
              <QrReader
                constraints={{ facingMode: 'environment' }}
                onResult={(result) => result && handleScan(result.getText())}
                className="w-full h-full"
              />
              {loading && (
                <div className="absolute inset-0 flex items-center justify-center bg-black/50">
                  <Loader2 className="h-8 w-8 animate-spin text-white" />
                </div>
              )}
            </div>
          ) : (
            <Button 
              onClick={() => setShowScanner(true)}
              className="w-full"
            >
              Start Scanning
            </Button>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default ScanTable;
```

### 2. Update App.tsx

Update `/home/abenezer/Desktop/work/inseat-menu/src/App.tsx` to add the new routes:

```tsx
// Import the new component
import ScanTable from "./pages/ScanTable";
import { useEffect } from "react";

// Update the Routes in App.tsx
<Routes>
  {/* Add root path to scan QR code - this is the landing page */}
  <Route path="/" element={<ScanTable />} />
  
  {/* Add table-specific route */}
  <Route path="/:tableId" element={<Layout />}>
    <Route index element={<TableMenu />} />
    {/* Other existing routes */}
    <Route path="menu" element={<Menu />} />
    {/* ... */}
  </Route>
</Routes>

// Create a TableMenu component to handle table verification
const TableMenu: React.FC = () => {
  const { tableId } = useParams<{ tableId: string }>();
  const navigate = useNavigate();
  
  useEffect(() => {
    const checkTable = async () => {
      if (!tableId) {
        navigate('/');
        return;
      }
      
      try {
        const verification = await verifyTableStatus(tableId);
        if (!verification.exists || !verification.isAvailable) {
          navigate('/');
        }
      } catch (error) {
        console.error('Error verifying table:', error);
        navigate('/');
      }
    };
    
    checkTable();
  }, [tableId, navigate]);
  
  return <Menu />;
};
```

### 3. Update menu

# INSEAT Menu System Integration Documentation

## 1. Overview

This documentation outlines the integration between INSEAT-Backend and inseat-menu to create a table-specific menu viewing system. This system allows restaurant patrons to scan QR codes on tables to view menus specific to that venue.

## 2. Repository Structure

### Backend Structure (INSEAT-Backend)
```
/home/abenezer/Desktop/work/INSEAT-Backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”œâ”€â”€ tableController.ts      # Table-related logic
â”‚   â”‚   â”œâ”€â”€ menuController.ts       # Menu-related logic
â”‚   â”‚   â””â”€â”€ categoryController.ts   # Category-related logic
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ tableRoutes.ts          # Table API endpoints
â”‚   â”‚   â”œâ”€â”€ menuRoutes.ts           # Menu API endpoints
â”‚   â”‚   â””â”€â”€ categoryRoutes.ts       # Category API endpoints
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ Table.ts                # Table data model
â”‚   â”‚   â”œâ”€â”€ Menu.ts                 # Menu data model
â”‚   â”‚   â”œâ”€â”€ Category.ts             # Category data model
â”‚   â”‚   â””â”€â”€ MenuItem.ts             # Menu item data model
â”‚   â””â”€â”€ app.ts                      # Express app setup
```

### Frontend Structure (inseat-menu)
```
/home/abenezer/Desktop/work/inseat-menu/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ menuService.ts          # API integration service
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ QRScanner.tsx           # QR code scanner component (exists)
â”‚   â”‚   â”œâ”€â”€ menu/
â”‚   â”‚   â”‚   â”œâ”€â”€ MenuGrid.tsx        # Grid for menu items (exists)
â”‚   â”‚   â”‚   â””â”€â”€ MenuItemCard.tsx    # Individual menu item display
â”‚   â”œâ”€â”€ context/
â”‚   â”‚   â””â”€â”€ TableContext.tsx        # Table context for state management
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â””â”€â”€ useQRScanner.ts         # QR scanner hook (exists)
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ Menu.tsx                # Menu display page (exists)
â”‚   â”‚   â””â”€â”€ ScanTable.tsx           # QR scanning page (to be created)
â”‚   â””â”€â”€ App.tsx                     # Main application component with routing
```

## 3. Backend API Endpoints

### Table Verification Endpoint (NEEDS IMPLEMENTATION)

**Purpose**: Verifies if a table exists and is available for use.

**Endpoint**: 
```
GET /api/tables/{tableId}/verify
```

**Request**: None

**Example Response (Success)**:
```json
{
  "exists": true,
  "isAvailable": true,
  "venue": {
    "_id": "67f6056fc5f5d349242273c6",
    "name": "Screen 2",
    "description": "Screen 2 at CINEMA CITY ARABIAN CENTRE",
    "capacity": 88,
    "restaurantId": {
      "_id": "67f6056fc5f5d349242273c2",
      "name": "CINEMA CITY ARABIAN CENTRE"
    }
  },
  "table": {
    "_id": "67f60565c5f5d349242273a2",
    "number": "T123",
    "venueId": "67f6056fc5f5d349242273c6",
    "capacity": 4,
    "isOccupied": false,
    "isActive": true
  }
}
```

**Example Response (Table Not Found)**:
```json
{
  "exists": false,
  "isAvailable": false,
  "error": "Table not found"
}
```

**Implementation Path**: `/home/abenezer/Desktop/work/INSEAT-Backend/src/controllers/tableController.ts`

```typescript
export const verifyTable = async (req: Request, res: Response) => {
  try {
    const { tableId } = req.params;
    
    // Find table by ID
    const table = await Table.findById(tableId);
    
    if (!table) {
      return res.json({
        exists: false,
        isAvailable: false,
        error: "Table not found"
      });
    }
    
    // Find venue
    const venue = await Venue.findById(table.venueId).populate('restaurantId', 'name');
    
    if (!venue) {
      return res.json({
        exists: true,
        isAvailable: false,
        error: "Venue not found"
      });
    }
    
    const isAvailable = table.isActive && !table.isOccupied;
    
    return res.json({
      exists: true,
      isAvailable,
      venue,
      table
    });
  } catch (error) {
    return res.status(500).json({
      error: true,
      message: "Server error while verifying table",
      details: error.message
    });
  }
};
```

### Table Menu Endpoint (NEEDS IMPLEMENTATION)

**Purpose**: Retrieves the complete menu hierarchy for a table's venue.

**Endpoint**: 
```
GET /api/tables/{tableId}/menu
```

**Request**: None

**Example Response**:
```json
{
  "venue": {
    "_id": "67f6056fc5f5d349242273c6",
    "name": "Screen 2",
    "description": "Screen 2 at CINEMA CITY ARABIAN CENTRE"
  },
  "menu": {
    "categories": [
      {
        "_id": "681390684d05b2857e931219",
        "name": "FOOD",
        "description": "FOOD category",
        "image": "https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg",
        "isActive": true,
        "order": 1
      }
    ],
    "subcategories": {
      "681390684d05b2857e931219": [
        {
          "_id": "6813906a4d05b2857e931230",
          "name": "NOODLES",
          "description": "NOODLES subcategory",
          "image": "https://images.pexels.com/photos/1640777/pexels-photo-1640777.jpeg",
          "isActive": true,
          "order": 0
        }
      ]
    },
    "menuItems": [
      {
        "_id": "67f7bff6fc06b1668c789281",
        "name": "Main Menu",
        "description": "Our primary selection of dishes.",
        "price": 12.99,
        "image": "image_url",
        "categories": [
          {
            "_id": "681390684d05b2857e931219",
            "name": "FOOD"
          }
        ],
        "subCategories": [
          {
            "_id": "6813906a4d05b2857e931230",
            "name": "NOODLES"
          }
        ],
        "isAvailable": true,
        "isActive": true
      }
    ]
  }
}
```

**Implementation Path**: `/home/abenezer/Desktop/work/INSEAT-Backend/src/controllers/tableController.ts`

```typescript
export const getTableMenu = async (req: Request, res: Response) => {
  try {
    const { tableId } = req.params;
    
    // Find table by ID
    const table = await Table.findById(tableId);
    if (!table) {
      return res.status(404).json({
        error: true,
        message: "Table not found"
      });
    }
    
    // Find venue
    const venue = await Venue.findById(table.venueId);
    if (!venue) {
      return res.status(404).json({
        error: true,
        message: "Venue not found"
      });
    }
    
    // Get categories for this venue
    const categories = await Category.find({
      restaurantId: venue.restaurantId,
      isActive: true
    }).sort({ order: 1 });
    
    // Get subcategories organized by category
    const subcategoriesMap = {};
    for (const category of categories) {
      const subcategories = await Subcategory.find({
        categoryId: category._id,
        isActive: true
      }).sort({ order: 1 });
      
      subcategoriesMap[category._id] = subcategories;
    }
    
    // Get menu items for this venue
    const menuItems = await MenuItem.find({
      venueId: venue._id,
      isActive: true
    });
    
    return res.json({
      venue: {
        _id: venue._id,
        name: venue.name,
        description: venue.description
      },
      menu: {
        categories,
        subcategories: subcategoriesMap,
        menuItems
      }
    });
  } catch (error) {
    return res.status(500).json({
      error: true,
      message: "Server error while fetching table menu",
      details: error.message
    });
  }
};
```

### Category and Subcategory Endpoints (EXISTING)

**Category Endpoint**:
```
GET /api/categories
```

**Example Call**:
```bash
curl -s http://localhost:3001/api/categories
```

**Subcategory Endpoint**:
```
GET /api/subcategories?categoryId=<category-id>
```

**Example Call**:
```bash
curl -s "http://localhost:3001/api/subcategories?categoryId=681390684d05b2857e931219"
```

## 4. Frontend Implementation

### API Service Integration (src/api/menuService.ts)

**Add these functions to `/home/abenezer/Desktop/work/inseat-menu/src/api/menuService.ts`**:

```typescript
// This function is already implemented
export const verifyTableStatus = async (tableId: string): Promise<{
  exists: boolean;
  isAvailable: boolean;
  venue?: Venue;
  table?: Table;
}> => {
  try {
    let table;
    try {
      table = await getTableById(tableId);
    } catch (err) {
      if (err instanceof TableNotFoundError) {
        return { exists: false, isAvailable: false };
      }
      throw err;
    }
    
    let venue;
    try {
      venue = await getVenueById(table.venueId);
    } catch (err) {
      if (err instanceof VenueNotFoundError) {
        return { exists: true, isAvailable: false };
      }
      throw err;
    }

    const isAvailable = table.isActive && !table.isOccupied;
    
    if (!isAvailable) {
      return { exists: true, isAvailable: false, venue, table };
    }

    return {
      exists: true,
      isAvailable: true,
      venue,
      table
    };
  } catch (error) {
    console.error('Error verifying table status:', error);
    if (error instanceof ApiError) {
      throw error;
    }
    throw new ApiError(`Failed to verify table status for table ID ${tableId}`, 500);
  }
};

// This function is already implemented
export const getFullMenuHierarchy = async (venueId: string): Promise<{
  categories: Category[];
  subcategories: { [categoryId: string]: Subcategory[] };
  subsubcategories: { [subcategoryId: string]: SubSubcategory[] };
  menuItems: MenuItem[];
}> => {
  try {
    const venue = await getVenueById(venueId);
    if (!venue) throw new Error('Venue not found');

    const restaurantId = typeof venue.restaurantId === 'string' ? 
      venue.restaurantId : 
      venue.restaurantId._id;

    // Get all menu data in parallel
    const [categories, menuItems] = await Promise.all([
      getCategories(restaurantId),
      getVenueMenuItems(venueId)
    ]);

    // Get subcategories for each category
    const subcategoriesPromises = categories.map(category => 
      getSubcategories(category._id, restaurantId)
    );
    const subcategoriesArrays = await Promise.all(subcategoriesPromises);
    
    // Create subcategories map
    const subcategories: { [categoryId: string]: Subcategory[] } = {};
    categories.forEach((category, index) => {
      subcategories[category._id] = subcategoriesArrays[index];
    });

    // Get subsubcategories for each subcategory
    const subsubcategoriesPromises = Object.values(subcategories)
      .flat()
      .map(subcategory => getSubSubcategories(subcategory._id, restaurantId));
    const subsubcategoriesArrays = await Promise.all(subsubcategoriesPromises);

    // Create subsubcategories map
    const subsubcategories: { [subcategoryId: string]: SubSubcategory[] } = {};
    Object.values(subcategories).flat().forEach((subcategory, index) => {
      subsubcategories[subcategory._id] = subsubcategoriesArrays[index];
    });

    return {
      categories,
      subcategories,
      subsubcategories,
      menuItems
    };
  } catch (error) {
    console.error('Error fetching full menu hierarchy:', error);
    if (error instanceof ApiError) {
      throw error;
    }
    throw new ApiError(`Failed to fetch menu hierarchy for venue ID ${venueId}`, 500);
  }
};

// Direct API call to the new backend endpoints (to be added)
export const getTableMenu = async (tableId: string) => {
  try {
    const response = await axios.get(`${API_BASE_URL}/tables/${tableId}/menu`);
    return response.data;
  } catch (error) {
    console.error('Error fetching table menu:', error);
    handleApiError(error, `Failed to fetch menu for table ID ${tableId}`);
  }
};

export const getTableById = async (tableId: string): Promise<Table> => {
  try {
    const response = await axios.get(`${API_BASE_URL}/tables/${tableId}`);
    const data = response.data.data || response.data;
    if (!data) {
      throw new TableNotFoundError(tableId);
    }
    return data;
  } catch (error) {
    console.error('Error fetching table:', error);
    handleApiError(error, `Failed to fetch table with ID ${tableId}`);
  }
};
```

### Create Scan Table Page (src/pages/ScanTable.tsx)

**Create a new file at `/home/abenezer/Desktop/work/inseat-menu/src/pages/ScanTable.tsx`**:

```tsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { QrReader } from 'react-qr-reader';
import { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { verifyTableStatus } from '@/api/menuService';
import { Loader2 } from 'lucide-react';

export const ScanTable: React.FC = () => {
  const navigate = useNavigate();
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [showScanner, setShowScanner] = useState(false);

  const handleScan = async (result: string | null) => {
    if (result && !loading) {
      setLoading(true);
      setError(null);
      
      try {
        const tableId = result; // In real implementation, parse QR code content
        const verification = await verifyTableStatus(tableId);
        
        if (verification.exists && verification.isAvailable) {
          navigate(`/${tableId}`);
        } else {
          setError(verification.exists ? 
            'This table is currently not available.' : 
            'Invalid table QR code.');
        }
      } catch (err) {
        setError('Failed to verify table. Please try again.');
      } finally {
        setLoading(false);
      }
    }
  };

  return (
    <div className="container mx-auto px-4 py-8 flex flex-col items-center justify-center min-h-screen">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle>Welcome to INSEAT</CardTitle>
          <CardDescription>
            Scan your table's QR code to view the menu
          </CardDescription>
        </CardHeader>
        <CardContent>
          {error && (
            <Alert variant="destructive" className="mb-4">
              <AlertTitle>Error</AlertTitle>
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          
          {showScanner ? (
            <div className="relative aspect-square w-full">
              <QrReader
                constraints={{ facingMode: 'environment' }}
                onResult={(result) => result && handleScan(result.getText())}
                className="w-full h-full"
              />
              {loading && (
                <div className="absolute inset-0 flex items-center justify-center bg-black/50">
                  <Loader2 className="h-8 w-8 animate-spin text-white" />
                </div>
              )}
            </div>
          ) : (
            <Button 
              onClick={() => setShowScanner(true)}
              className="w-full"
            >
              Start Scanning
            </Button>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default ScanTable;
```

### Update App.tsx with Table Routing

**Modify `/home/abenezer/Desktop/work/inseat-menu/src/App.tsx`**:

```typescript
// Current App.tsx imports (keep existing imports)
import ScanTable from "./pages/ScanTable";
import { useEffect } from "react";

const App = () => {
  return (
    <React.StrictMode>
      <QueryClientProvider client={queryClient}>
        <ThemeProvider attribute="class" defaultTheme="dark" forcedTheme="dark">
          <AuthProvider>
            <TableProvider>
              <OrdersProvider>
                <CartProvider>
                  <FavoritesProvider>
                    <TooltipProvider>
                      <Toaster />
                      <Sonner position="top-right" closeButton />
                      <BrowserRouter>
                        <Routes>
                          {/* Add root path to scan QR code - this is the landing page */}
                          <Route path="/" element={<ScanTable />} />
                          
                          {/* Regular app routes inside Layout */}
                          <Route element={<Layout />}>
                            {/* Add table-specific route that checks the table ID */}
                            <Route path="/:tableId" element={<TableMenuChecker />} />
                            
                            {/* Keep existing routes */}
                            <Route path="/menu" element={<Menu />} />
                            <Route path="/menu/:id" element={<MenuItemDetail />} />
                            <Route path="/category/:categoryId" element={<CategoryDetail />} />
                            <Route path="/my-orders" element={
                              <ProtectedRoute>
                                <MyOrders />
                              </ProtectedRoute>
                            } />
                            <Route path="/call-waiter" element={<CallWaiter />} />
                            <Route path="/bill" element={<Bill />} />
                            <Route path="/checkout" element={
                              <ProtectedRoute>
                                <Checkout />
                              </ProtectedRoute>
                            } />
                            <Route path="/order-confirmation" element={<OrderConfirmation />} />
                            <Route path="/login" element={<Login />} />
                            <Route path="/signup" element={<Signup />} />
                            <Route path="/account" element={
                              <ProtectedRoute>
                                <Account />
                              </ProtectedRoute>
                            } />
                            <Route path="*" element={<NotFound />} />
                          </Route>
                        </Routes>
                      </BrowserRouter>
                    </TooltipProvider>
                  </FavoritesProvider>
                </CartProvider>
              </OrdersProvider>
            </TableProvider>
          </AuthProvider>
        </ThemeProvider>
      </QueryClientProvider>
    </React.StrictMode>
  );
};

// Create a component to handle table verification and redirection
const TableMenuChecker: React.FC = () => {
  const { tableId } = useParams<{ tableId: string }>();
  const navigate = useNavigate();
  
  useEffect(() => {
    const checkTable = async () => {
      if (!tableId) {
        navigate('/');
        return;
      }
      
      try {
        const verification = await verifyTableStatus(tableId);
        if (!verification.exists || !verification.isAvailable) {
          navigate('/');
        }
      } catch (error) {
        console.error('Error verifying table:', error);
        navigate('/');
      }
    };
    
    checkTable();
  }, [tableId, navigate]);
  
  return <Menu />;
};

export default App;
```

### Update Menu Component to Handle Table-Specific Data

**Modify `/home/abenezer/Desktop/work/inseat-menu/src/pages/Menu.tsx`**:

```typescript
// Add to the imports
import { useParams } from 'react-router-dom';
import { getTableMenu, verifyTableStatus } from '@/api/menuService';
import { useTableInfo } from '@/context/TableContext';

const Menu: React.FC = () => {
  const { tableId } = useParams<{ tableId: string }>();
  const tableInfo = useTableInfo();
  const location = useLocation();
  const [searchQuery, setSearchQuery] = useState('');
  const [activeCategory, setActiveCategory] = useState('all');
  const [selectedItem, setSelectedItem] = useState<MenuItem | null>(null);
  const [isDrawerOpen, setIsDrawerOpen] = useState(false);
  
  // Get menu data based on table ID if available
  const { data: menuData, isLoading: menuLoading } = useQuery({
    queryKey: ['tableMenu', tableId],
    queryFn: () => tableId ? getTableMenu(tableId) : null,
    enabled: !!tableId,
  });
  
  // Use the categories from the table-specific menu if available
  const { data: categories, isLoading: categoriesLoading } = useQuery({
    queryKey: ['categories', tableId],
    queryFn: () => {
      if (tableId && menuData) {
        return menuData.menu.categories;
      }
      return api.getCategories();
    },
    placeholderData: defaultCategories,
    enabled: !menuLoading,
  });
  
  // Update table info in context when we have verified table data
  useEffect(() => {
    if (tableId && menuData?.venue) {
      tableInfo.setTableInfo({
        tableNumber: tableId,
        restaurantName: menuData.venue.name,
      });
    }
  }, [tableId, menuData, tableInfo]);

  // Rest of the component remains the same...
  
  return (
    <div className="container mx-auto px-4 py-8 md:py-12 animate-fade-in">
      {/* Show venue info if available */}
      {menuData?.venue && (
        <div className="mb-6 text-center">
          <h1 className="text-2xl font-bold">{menuData.venue.name}</h1>
          {menuData.venue.description && (
            <p className="text-muted-foreground mt-1">{menuData.venue.description}</p>
          )}
        </div>
      )}
      
      <div className="text-center mb-8 md:mb-12">
        <h1 className="text-3xl font-medium mb-4">Our Menu</h1>
        <p className="text-muted-foreground">Discover our exquisite selection of dishes</p>
      </div>
      
      {/* Rest of the component remains the same... */}
    </div>
  );
};

export default Menu;
```

## 5. Testing Instructions

### Backend Testing

1. First, ensure the backend is running:
```bash
cd /home/abenezer/Desktop/work/INSEAT-Backend
npm run dev
```

2. Test table verification endpoint:
```bash
# Test with a valid table ID
curl -s http://localhost:3001/api/tables/67f60565c5f5d349242273a2/verify

# Test with an invalid table ID
curl -s http://localhost:3001/api/tables/invalid_id/verify
```

3. Test table menu endpoint:
```bash
# Test with a valid table ID
curl -s http://localhost:3001/api/tables/67f60565c5f5d349242273a2/menu

# Test with an invalid table ID
curl -s http://localhost:3001/api/tables/invalid_id/menu
```

### Frontend Testing

1. Start the frontend development server:
```bash
cd /home/abenezer/Desktop/work/inseat-menu
npm run dev
```

2. Test the QR scanning flow:
   - Open http://localhost:8080 in a mobile browser
   - Click "Start Scanning"
   - Scan a valid table QR code
   - Verify that you're redirected to the menu page

3. Test direct table access:
   - Visit http://localhost:8080/67f60565c5f5d349242273a2 (replace with valid table ID)
   - Verify that the menu loads correctly
   - Check that categories and subcategories are properly displayed
   - Verify that menu items are filtered correctly when selecting categories

4. Test error scenarios:
   - Try accessing an invalid table ID
   - Test with an inactive table
   - Test with a non-existent venue
   - Verify that appropriate error messages are shown

## 6. Next Steps

1. Deploy the changes:
   - Backend: Deploy updated controllers and routes
   - Frontend: Deploy new ScanTable page and updated Menu components

2. Monitor for issues:
   - Watch for API errors in logs
   - Monitor frontend error boundaries
   - Check performance metrics

3. Gather feedback:
   - Test with real users
   - Monitor user interaction patterns
   - Collect feedback on UI/UX

## 7. Success Criteria

The integration will be considered successful when:
1. Users can scan table QR codes and view the correct menu
2. The menu hierarchy (categories, subcategories) is properly displayed
3. All error cases are properly handled with user-friendly messages
4. The system performs well under load
5. The UI is responsive and works well on mobile devices

Remember to test thoroughly on multiple devices and browsers before deploying to production.
</file>

<file path="README-menu-integration.md">
# INSEAT Menu Integration

This document provides guidance for developers working with the INSEAT menu integration, particularly focusing on the TableHeader component and category display enhancements.

## Overview

We've enhanced the menu UI to provide a better user experience by:

1. Showing venue name on the left edge of the navbar
2. Displaying table name in the center of the navbar
3. Using real category images instead of placeholder images
4. Showing accurate subcategory and subsubcategory counts

## Component Structure

### TableHeader

The `TableHeader` component accepts two main props:

```typescript
interface TableHeaderProps {
  venueName?: string; // The venue name to display on left edge
  tableName?: string; // The table name to display in center
}
```

Example usage:

```tsx
<TableHeader 
  venueName="Main Dining Room" 
  tableName="A12" 
/>
```

### CategoryGrid

The `CategoryGrid` component has been updated to display enhanced category information:

```typescript
interface Category {
  id: string;
  _id?: string;
  name: string;
  image: string;
  subCategories: string[];
  subCategoryCount: number;
  totalSubSubCategoryCount: number;
}

interface CategoryGridProps {
  categories: Category[];
}
```

Example usage:

```tsx
<CategoryGrid categories={formattedCategories} />
```

## Testing

### Using TableHeaderTest

We've included a test component to help verify the TableHeader implementation:

1. Navigate to `/test/header` in your browser
2. Use the provided controls to:
   - Adjust viewport width (mobile, tablet, desktop)
   - Test different venue and table name combinations
   - Try edge cases like empty values or very long names

### Category Display Testing

To test the enhanced category display:

1. Ensure backend API provides the required data format
2. Verify real images are displayed and subcategory counts are accurate
3. Check responsive behavior on different screen sizes

## Implementation Notes

### Venue Name Truncation

Long venue names will be truncated on mobile devices to prevent layout issues. The truncation includes:

- Maximum width of 120px
- Text overflow with ellipsis
- Preserved readability of the table name in center

### Image Error Handling

The CategoryGrid component includes error handling for images:

```tsx
const handleImageError = (e: React.SyntheticEvent<HTMLImageElement, Event>) => {
  e.currentTarget.src = '/placeholder-category.jpg';
};
```

This ensures a fallback image is displayed if the real image fails to load.

## Backend API Requirements

The frontend implementation expects the backend to provide:

1. Venue and table information in table verification response
2. Real category images in menu response
3. Accurate subcategory and subsubcategory counts

See `docs/backend-enhancements.md` for detailed API requirements.

## Troubleshooting

Common issues:

1. **Missing venue/table information**: Ensure tableData is properly fetched and passed to TableHeader
2. **Category images not loading**: Check network requests and confirm backend returns valid image URLs
3. **Subcategory counts incorrect**: Verify API response contains accurate category relationship data

## Future Enhancements

Planned improvements:

1. Further customization options for the TableHeader (colors, branding)
2. Enhanced accessibility for venue and table information
3. Better performance optimization for category image loading
</file>

<file path="src/api/menuService.ts">
import axios, { AxiosError } from 'axios';
import { API_BASE_URL } from '@/constants';
// Custom error types for better error handling
export class ApiError extends Error {
  status: number;
  data?: any;
  constructor(message: string, status: number = 500, data?: any) {
    super(message);
    this.name = 'ApiError';
    this.status = status;
    this.data = data;
  }
}
export class TableNotFoundError extends ApiError {
  constructor(tableId: string) {
    super(`Table with ID ${tableId} not found`, 404);
    this.name = 'TableNotFoundError';
  }
}
export class VenueNotFoundError extends ApiError {
  constructor(venueId: string) {
    super(`Venue with ID ${venueId} not found`, 404);
    this.name = 'VenueNotFoundError';
  }
}
export class TableNotAvailableError extends ApiError {
  constructor(tableId: string) {
    super(`Table with ID ${tableId} is not available`, 400);
    this.name = 'TableNotAvailableError';
  }
}
// Helper function to handle API errors
const handleApiError = (error: unknown, defaultMessage: string): never => {
  if (axios.isAxiosError(error)) {
    const axiosError = error as AxiosError;
    if (axiosError.response) {
      // Type assertion for response data to access error property safely
      const responseData = axiosError.response.data as { error?: string };
      throw new ApiError(
        responseData.error || defaultMessage,
        axiosError.response.status,
        axiosError.response.data
      );
    } else if (axiosError.request) {
      throw new ApiError('No response received from server', 503);
    }
  }
  // Handle unknown error types safely
  throw new ApiError(
    error instanceof Error ? error.message : defaultMessage
  );
};
// Interfaces
export interface Venue {
  _id: string;
  name: string;
  description: string;
  restaurantId: {
    _id: string;
    name: string;
  };
}
export interface Table {
  _id: string;
  number: string;
  venueId: string;
  capacity: number;
  isOccupied: boolean;
  isActive: boolean;
}
export interface Category {
  _id: string;
  name: string;
  description: string;
  image: string;
  isActive: boolean;
  order: number;
  restaurantId?: string;
}
export interface Subcategory {
  _id: string;
  name: string;
  description: string;
  image: string;
  isActive: boolean;
  order: number;
  categoryId: string;
}
export interface MenuItem {
  _id: string;
  name: string;
  description: string;
  price: number;
  image: string;
  categories: string[];
  subCategories?: string[];
  isAvailable: boolean;
  isActive: boolean;
}
export interface TableMenu {
  venue: {
    _id: string;
    name: string;
    description: string;
  };
  menu: {
    categories: Category[];
    subcategories: { [categoryId: string]: Subcategory[] };
    menuItems: MenuItem[];
  };
}
// API Functions
export const verifyTableStatus = async (tableId: string): Promise<{
  exists: boolean;
  isAvailable: boolean;
  venue?: Venue;
  table?: Table;
}> => {
  try {
    console.log(`Verifying table status for table ID: ${tableId}`);
    const response = await axios.get(`${API_BASE_URL}/tables/${tableId}/verify`, {
      timeout: 5000 // Add a 5 second timeout for faster feedback
    });
    return response.data;
  } catch (error) {
    console.error('Error verifying table:', error);
    // Check for specific error types
    if (axios.isAxiosError(error)) {
      // If it's a 404 Not Found, the table doesn't exist
      if (error.response?.status === 404) {
        throw new TableNotFoundError(tableId);
      }
    }
    // For all other errors, throw an appropriate error
    handleApiError(error, `Failed to verify table status for table ID ${tableId}`);
  }
};
export const getTableMenu = async (tableId: string): Promise<TableMenu> => {
  try {
    const response = await axios.get(`${API_BASE_URL}/tables/${tableId}/menu`);
    return response.data;
  } catch (error) {
    console.error('Error fetching table menu:', error);
    handleApiError(error, `Failed to fetch menu for table ID ${tableId}`);
  }
};
export const getCategories = async (): Promise<Category[]> => {
  try {
    const response = await axios.get(`${API_BASE_URL}/categories`);
    return response.data;
  } catch (error) {
    console.error('Error fetching categories:', error);
    handleApiError(error, 'Failed to fetch categories');
  }
};
export const getSubcategories = async (categoryId: string): Promise<Subcategory[]> => {
  try {
    const response = await axios.get(`${API_BASE_URL}/categories/${categoryId}/subcategories`);
    return response.data;
  } catch (error) {
    console.error('Error fetching subcategories:', error);
    handleApiError(error, `Failed to fetch subcategories for category ${categoryId}`);
  }
};
export const getSubSubcategories = async (subcategoryId: string): Promise<Subcategory[]> => {
  try {
    const response = await axios.get(`${API_BASE_URL}/subcategories/${subcategoryId}/subsubcategories`);
    return response.data;
  } catch (error) {
    console.error('Error fetching subsubcategories:', error);
    handleApiError(error, `Failed to fetch subsubcategories for subcategory ${subcategoryId}`);
  }
};
export const getMenuItems = async (categoryId?: string, subcategoryId?: string): Promise<MenuItem[]> => {
  try {
    let url = `${API_BASE_URL}/menu-items`;
    const params = new URLSearchParams();
    if (categoryId) params.append('categoryId', categoryId);
    if (subcategoryId) params.append('subcategoryId', subcategoryId);
    if (params.toString()) {
      url += `?${params.toString()}`;
    }
    const response = await axios.get(url);
    return response.data;
  } catch (error) {
    console.error('Error fetching menu items:', error);
    handleApiError(error, 'Failed to fetch menu items');
  }
};
export const getVenueById = async (venueId: string): Promise<Venue> => {
  try {
    const response = await axios.get(`${API_BASE_URL}/venues/${venueId}`);
    return response.data;
  } catch (error) {
    console.error('Error fetching venue:', error);
    handleApiError(error, `Failed to fetch venue with ID ${venueId}`);
  }
};
export const getVenueMenuItems = async (venueId: string): Promise<MenuItem[]> => {
  try {
    const response = await axios.get(`${API_BASE_URL}/venues/${venueId}/menu-items`);
    return response.data;
  } catch (error) {
    console.error('Error fetching venue menu items:', error);
    handleApiError(error, `Failed to fetch menu items for venue ${venueId}`);
  }
};
export const getFullMenuHierarchy = async (venueId: string): Promise<{
  categories: Category[];
  subcategories: { [categoryId: string]: Subcategory[] };
  subsubcategories: { [subcategoryId: string]: Subcategory[] };
  menuItems: MenuItem[];
}> => {
  try {
    // Get venue info
    const venue = await getVenueById(venueId);
    if (!venue) throw new VenueNotFoundError(venueId);
    // Get all categories
    const categories = await getCategories();
    // Get all venue menu items
    const menuItems = await getVenueMenuItems(venueId);
    // Get subcategories for each category
    const subcategoriesMap: { [categoryId: string]: Subcategory[] } = {};
    for (const category of categories) {
      const subcategories = await getSubcategories(category._id);
      subcategoriesMap[category._id] = subcategories;
    }
    // Initialize subsubcategories (in this case we're using Subcategory as the type since there is no SubSubcategory type)
    const subsubcategoriesMap: { [subcategoryId: string]: Subcategory[] } = {};
    return {
      categories,
      subcategories: subcategoriesMap,
      subsubcategories: subsubcategoriesMap,
      menuItems
    };
  } catch (error) {
    console.error('Error fetching full menu hierarchy:', error);
    handleApiError(error, `Failed to fetch full menu hierarchy for venue ${venueId}`);
  }
};
export const getTableById = async (tableId: string): Promise<Table> => {
  try {
    const response = await axios.get(`${API_BASE_URL}/tables/${tableId}`);
    return response.data;
  } catch (error) {
    console.error('Error fetching table:', error);
    handleApiError(error, `Failed to fetch table with ID ${tableId}`);
  }
};
</file>

<file path="src/api/paymentService.ts">
import { CartItem } from '@/types';
import apiClient from './apiClient';
import { API_BASE_URL } from '@/constants';
// Stripe response type
interface StripeSessionResponse {
  success: boolean;
  url: string;
  sessionId: string;
  error?: {
    message: string;
  };
}
// Payment status response
interface PaymentStatusResponse {
  success: boolean;
  status: 'paid' | 'pending' | 'failed';
  paymentProviderStatus?: string; // Status from payment provider (e.g., Stripe)
  orderId?: string;
  paymentId?: string;
  sessionId?: string;
  amount?: number;
  currency?: string;
  error?: {
    message: string;
  };
}
/**
 * Create a Stripe checkout session for the given order
 */
export const createStripeCheckoutSession = async (
  cartItems: CartItem[],
  tableId: string,
  restaurantId: string
): Promise<StripeSessionResponse> => {
  try {
    console.log('createStripeCheckoutSession called for tableId:', tableId, 'restaurantId:', restaurantId);
    console.log('Relying on HttpOnly cookies for authentication.');
    // Format cart items for the Stripe session
    const lineItems = cartItems.map(item => {
      // Calculate the total price including modifiers
      const modifierPrice = item.modifiers 
        ? item.modifiers.reduce((sum, mod) => sum + mod.price, 0) 
        : 0;
      const totalItemPrice = (item.price + modifierPrice) * 100; // Convert to cents for Stripe
      // Format description including modifiers
      let description = item.name;
      if (item.modifiers && item.modifiers.length > 0) {
        const modifierNames = item.modifiers.map(mod => mod.name).join(', ');
        description += ` with ${modifierNames}`;
      }
      if (item.specialInstructions) {
        description += `. Note: ${item.specialInstructions}`;
      }
      return {
        price_data: {
          currency: 'usd',
          product_data: {
            name: item.name,
            description: description,
            images: item.image ? [item.image] : undefined
          },
          unit_amount: totalItemPrice // Amount in cents
        },
        quantity: item.quantity
      };
    });
    // Request body for the API
    // Make sure tableId and restaurantId are strings for Stripe metadata
    const tableIdStr = typeof tableId === 'object' ? 
      (tableId && 'id' in tableId ? String((tableId as any).id) : 
       tableId && '_id' in tableId ? String((tableId as any)._id) : 
       String(tableId)) : 
      String(tableId || '');
    const restaurantIdStr = typeof restaurantId === 'object' ? 
      (restaurantId && 'id' in restaurantId ? String((restaurantId as any).id) : 
       restaurantId && '_id' in restaurantId ? String((restaurantId as any)._id) : 
       String(restaurantId)) : 
      String(restaurantId || '');
    console.log('Processing tableId for Stripe:', { original: tableId, processed: tableIdStr });
    console.log('Processing restaurantId for Stripe:', { original: restaurantId, processed: restaurantIdStr });
    const requestBody = {
      tableId: tableIdStr,
      restaurantId: restaurantIdStr,
      lineItems,
      metadata: {
        tableId: tableIdStr,
        restaurantId: restaurantIdStr
      }
    };
    // Add success and cancel URLs
    const successUrl = `${window.location.origin}/payment/success`;
    const cancelUrl = `${window.location.origin}/payment/cancel`;
    // Call API to create Stripe session using apiClient
    console.log(`Making API request to create checkout session`);
    // Use apiClient which handles auth headers automatically
    const response = await apiClient.post('/api/payments/create-checkout-session', {
      ...requestBody,
      successUrl,
      cancelUrl
    });
    console.log('Payment API response status:', response.status);
    if (!response.data.success) {
      throw new Error(response.data.error?.message || 'Failed to create payment session');
    }
    // Store the Stripe session ID in localStorage for later reference
    // This is helpful if the redirect URL contains a different ID format
    if (response.data.sessionId) {
      console.log('Storing Stripe session ID in localStorage:', response.data.sessionId);
      localStorage.setItem('stripeSessionId', response.data.sessionId);
    }
    return response.data;
  } catch (error) {
    console.error('Error creating payment session:', error);
    throw error;
  }
}
/**
 * Check the status of a Stripe payment session
 */
export const checkPaymentStatus = async (
  sessionId: string
): Promise<PaymentStatusResponse> => {
  try {
    console.log(`Checking payment status for session ${sessionId}`);
    // Debug the API base URL and request path
    console.log('API Base URL:', API_BASE_URL);
    // Validate the session ID
    if (!sessionId) {
      console.error('Missing session ID');
      throw new Error('Missing session ID');
    }
    // Log the session ID we're working with
    console.log('Checking payment status with session ID:', sessionId);
    // In case we're receiving a non-Stripe format, try to extract the proper format
    // Stripe session IDs typically start with cs_test_ or cs_live_
    let normalizedSessionId = sessionId;
    // If the session doesn't look like a Stripe session ID, it might be from our local system
    // This handles the case where we're getting timestamps or internal IDs
    if (!sessionId.startsWith('cs_test_') && !sessionId.startsWith('cs_live_')) {
      console.warn('Session ID does not appear to be a standard Stripe format:', sessionId);
      // Check if we have the correct session ID in localStorage
      const storedSessionId = localStorage.getItem('stripeSessionId');
      if (storedSessionId && (storedSessionId.startsWith('cs_test_') || storedSessionId.startsWith('cs_live_'))) {
        console.log('Using stored Stripe session ID instead:', storedSessionId);
        normalizedSessionId = storedSessionId;
      } else {
        console.warn('No valid Stripe session ID found in storage, proceeding with original ID');
      }
    }
    // Make sure we're using the correct endpoint - try multiple approaches to cover all bases
    // Create all possible endpoint variations to ensure we hit the right one
    const endpointPaths = [
      `/api/payments/sessions/${normalizedSessionId}`,      // Full path with /api prefix
      `/payments/sessions/${normalizedSessionId}`,         // Without /api prefix (apiClient might add it)
      `/api/payments/check-session/${normalizedSessionId}`, // Legacy endpoint with /api prefix
      `/payments/check-session/${normalizedSessionId}`     // Legacy endpoint without /api prefix
    ];
    // Use apiClient which handles auth headers automatically
    try {
      console.log(`Attempting to check payment status with primary endpoint: /api/payments/sessions/${normalizedSessionId}`);
      const response = await apiClient.get(`/api/payments/sessions/${normalizedSessionId}`);
      // Log the response for debugging
      console.log('Response:', {
        status: response.status,
        statusText: response.statusText,
        data: response.data
      });
      return response.data;
    } catch (primaryError: any) {
      console.log('Primary endpoint failed, trying fallback endpoints');
      // Try fallback endpoints
      let response = null;
      let lastError = primaryError;
      let errors: Record<string, any> = {
        primary: {
          message: primaryError.message,
          status: primaryError.response?.status,
          statusText: primaryError.response?.statusText,
          data: primaryError.response?.data
        }
      };
      // If the error is a 404 with a message about the session not found on Stripe,
      // this is a clear indication that the session ID is invalid
      if (primaryError.response?.status === 404 && 
          primaryError.response?.data?.error?.message?.includes('not found on payment provider')) {
        throw new Error('Payment session expired or invalid. Please try creating a new order.');
      }
      // Try alternative endpoints
      for (const path of endpointPaths.slice(1)) { // Skip the first endpoint which we already tried
        try {
          console.log(`Attempting to check payment status with fallback endpoint: ${path}`);
          response = await apiClient.get(path);
          // Log the response for debugging
          console.log(`Response from ${path}:`, {
            status: response.status,
            statusText: response.statusText,
            data: response.data
          });
          if (response.status === 200) {
            console.log(`Success with endpoint: ${path}`);
            break;
          }
        } catch (err: any) {
          // Extract and log detailed error information
          const errorDetails = {
            message: err.message,
            status: err.response?.status,
            statusText: err.response?.statusText,
            data: err.response?.data
          };
          console.log(`Failed with endpoint: ${path}`, errorDetails);
          errors[path] = errorDetails;
          lastError = err;
        }
      }
      // If we've tried all endpoints and none worked, provide a detailed error
      if (!response) {
        console.error('All payment status endpoints failed:', errors);
        // Create a more user-friendly error message
        const statusCode = lastError.response?.status;
        if (statusCode === 404) {
          throw new Error('Payment session not found. It may have expired or been cancelled.');
        } else if (statusCode === 401 || statusCode === 403) {
          throw new Error('Authorization error. Please log in again and try once more.');
        } else {
          throw new Error(`Payment verification failed: ${lastError.message || 'Unknown error'}`);
        }
      }
      if (!response || !response.data) {
        throw new Error('No response data received from payment status check');
      }
      if (!response.data.success) {
        throw new Error(response.data.error?.message || 'Failed to check payment status');
      }
      return response.data;
    }
  } catch (error) {
    console.error('Error checking payment status:', error);
    throw error;
  }
}
/**
 * Update order with payment information
 */
export const updateOrderPayment = async (
  orderId: string,
  paymentStatus: string,
  paymentId: string
): Promise<any> => {
  try {
    console.log(`Updating order payment for ${orderId} to ${paymentStatus}`);
    // Use apiClient which handles auth headers automatically
    const response = await apiClient.put(`/api/orders/${orderId}/payment`, { orderId, paymentStatus, paymentId });
    if (!response.data.success) {
      throw new Error(response.data.error?.message || 'Failed to update order payment');
    }
    return response.data.data;
  } catch (error) {
    console.error('Error updating order payment:', error);
    throw error;
  }
}
</file>

<file path="src/api/stripeService.ts">
import apiClient from './apiClient';
import { Order, PaymentStatus } from '@/types';
/**
 * Helper function to get table ID from localStorage
 * Checks multiple sources to ensure we get a valid table ID
 */
const getTableIdFromLocalStorage = (): string => {
  try {
    // First check tableInfo which contains the full table data
    const tableInfo = localStorage.getItem('tableInfo');
    if (tableInfo) {
      const parsedTableInfo = JSON.parse(tableInfo);
      if (parsedTableInfo?.id) {
        console.log('Found table ID in tableInfo:', parsedTableInfo.id);
        return parsedTableInfo.id;
      }
    }
    // If not found, check currentTableId which is a direct reference
    const currentTableId = localStorage.getItem('currentTableId');
    if (currentTableId) {
      console.log('Found table ID in currentTableId:', currentTableId);
      return currentTableId;
    }
    // Finally, check URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const tableParam = urlParams.get('table');
    if (tableParam) {
      console.log('Found table ID in URL parameters:', tableParam);
      // Store it for future use
      localStorage.setItem('currentTableId', tableParam);
      return tableParam;
    }
  } catch (error) {
    console.error('Error getting table ID from localStorage:', error);
  }
  console.warn('No table ID found in any storage location');
  return '';
};
/**
 * Initiates a Stripe checkout session for an order
 * 
 * @param orderId - The ID of the order to pay for
 * @param order - The order data
 * @returns Promise resolving to the checkout URL
 * @throws Error if API request fails
 */
export const createStripeCheckout = async (
  orderId: string | undefined, 
  order: Order
): Promise<string> => {
  // Validate orderId before proceeding
  if (!orderId) {
    console.error('OrderId is undefined in createStripeCheckout');
    orderId = order.id || order._id; // Try to use order's ID if available
    if (!orderId) {
      throw new Error('Order ID is required for checkout');
    }
    console.log('Using order ID from order object:', orderId);
  }
  try {
    // Prepare line items for Stripe from order data
    const lineItems = order.items.map(item => ({
      price_data: {
        currency: 'usd',
        product_data: {
          name: item.name,
          description: item.specialInstructions || undefined,
        },
        unit_amount: Math.round(item.price * 100), // Convert to cents
      },
      quantity: item.quantity,
    }));
    // Add tax as a separate line item
    if (order.tax > 0) {
      lineItems.push({
        price_data: {
          currency: 'usd',
          product_data: {
            name: 'Tax',
            description: 'Sales tax', // Adding required description
          },
          unit_amount: Math.round(order.tax * 100), // Convert to cents
        },
        quantity: 1,
      });
    }
    // Add tip as a separate line item if applicable
    if (order.tip && order.tip > 0) {
      lineItems.push({
        price_data: {
          currency: 'usd',
          product_data: {
            name: 'Tip',
            description: 'Gratuity', // Adding required description
          },
          unit_amount: Math.round(order.tip * 100), // Convert to cents
        },
        quantity: 1,
      });
    }
    // Get table ID from order or localStorage
    let tableId = order.tableId || getTableIdFromLocalStorage() || '';
    // Ensure tableId is a string, not an object
    if (typeof tableId === 'object') {
      console.warn('Table ID is an object, converting to string:', tableId);
      // If it has an id property, use that
      if (tableId && 'id' in tableId) {
        tableId = (tableId as any).id?.toString() || '';
      } 
      // If it has a _id property (MongoDB style), use that
      else if (tableId && '_id' in tableId) {
        tableId = (tableId as any)._id?.toString() || '';
      }
      // Otherwise, try to use the number property if available
      else if (tableId && 'number' in tableId) {
        tableId = (tableId as any).number?.toString() || '';
      }
      // Last resort, just stringify it
      else {
        try {
          const stringified = JSON.stringify(tableId);
          tableId = stringified !== '{}' ? stringified : '';
        } catch (e) {
          console.error('Failed to stringify tableId object:', e);
          tableId = '';
        }
      }
      console.log('Converted table ID to string:', tableId);
    }
    // If we found a table ID, ensure it's stored in localStorage for consistency
    if (tableId) {
      localStorage.setItem('currentTableId', tableId);
      console.log('Stored table ID in localStorage for payment flow:', tableId);
    }
    // Prepare metadata for the session
    const metadata = {
      orderId,
      orderNumber: order.orderNumber || orderId.slice(-6),
      tableId,
    };
    // Generate a session ID for tracking
    const sessionId = `session_${Date.now()}`;
    // Use explicit path to payments endpoint
    const apiUrl = '/api/payments/create-checkout-session'; // Ensure we're using the correct path
    console.log('Making Stripe checkout request to:', apiUrl);
    const response = await apiClient.post(apiUrl, {
      lineItems,
      orderId,
      metadata,
      // Set success and cancel URLs with table info if available
      successUrl: `${window.location.origin}/payment/success?orderId=${orderId}&sessionId=${sessionId}&table=${metadata.tableId}`,
      cancelUrl: `${window.location.origin}/payment/cancel?orderId=${orderId}&table=${metadata.tableId}`,
      // Include user ID if authenticated
      userId: localStorage.getItem('userId') || undefined,
    });
    if (!response.data?.url) {
      throw new Error('No checkout URL received from payment service');
    }
    return response.data.url;
  } catch (error) {
    console.error('Error creating Stripe checkout session:', error);
    throw new Error(error instanceof Error ? error.message : 'Failed to create checkout session');
  }
};
/**
 * Checks the status of a Stripe payment session
 * 
 * @param sessionId - The Stripe session ID to check
 * @returns Promise resolving to the payment status
 * @throws Error if API request fails
 */
export const checkStripeSessionStatus = async (sessionId: string): Promise<{
  status: string;
  orderId?: string;
}> => {
  try {
    // Using explicit API path to payment sessions endpoint
    const apiUrl = `/api/payments/sessions/${sessionId}`;
    console.log('Checking payment session status at:', apiUrl);
    const response = await apiClient.get(apiUrl);
    if (!response.data?.status) {
      throw new Error('Invalid response from payment status check');
    }
    return {
      status: response.data.status,
      orderId: response.data.orderId,
    };
  } catch (error) {
    console.error('Error checking Stripe session:', error);
    throw new Error(error instanceof Error ? error.message : 'Failed to check payment status');
  }
};
/**
 * Updates order payment status directly through order API
 * This is used as a fallback when Stripe integration is not available
 * 
 * @param orderId - ID of the order to update
 * @param paymentStatus - New payment status to set
 * @returns Promise resolving to the updated payment status data
 * @throws Error if API request fails
 */
export const updateOrderPaymentStatus = async (
  orderId: string | undefined,
  paymentStatus: PaymentStatus
) => {
  try {
    // Ensure orderId is valid
    if (!orderId) {
      console.error('Invalid orderId provided to updateOrderPaymentStatus:', orderId);
      throw new Error('Invalid order ID provided');
    }
    // Use explicit API path for updating payment status
    const apiUrl = `/api/payments/orders/${orderId}/payment-status`;
    console.log('Updating payment status at:', apiUrl);
    // Update the order status
    const response = await apiClient.patch(apiUrl, {
      status: paymentStatus,
    });
    return response.data;
  } catch (error) {
    console.error('Error updating payment status directly:', error);
    throw new Error(error instanceof Error ? error.message : 'Unknown error updating payment status');
  }
};
</file>

<file path="src/api/tableService.ts">
import axios, { AxiosError } from 'axios';
import { Table, TableDetails, Venue, VenueDetails } from '@/types';
import { API_BASE_URL } from '@/config/api';
// Use API_BASE_URL from centralized configuration
// Custom error types for better error handling
export class ApiError extends Error {
  status: number;
  data?: any;
  constructor(message: string, status: number = 500, data?: any) {
    super(message);
    this.name = 'ApiError';
    this.status = status;
    this.data = data;
  }
}
export class TableNotFoundError extends ApiError {
  constructor(tableId: string) {
    super(`Table with ID ${tableId} not found`, 404);
    this.name = 'TableNotFoundError';
  }
}
export class TableNotActiveError extends ApiError {
  constructor(tableId: string) {
    super(`Table with ID ${tableId} is not active`, 403);
    this.name = 'TableNotActiveError';
  }
}
export class VenueNotFoundError extends ApiError {
  constructor(tableId: string) {
    super(`Venue not found for table with ID ${tableId}`, 404);
    this.name = 'VenueNotFoundError';
  }
}
export class VenueNotActiveError extends ApiError {
  constructor(venueId: string) {
    super(`Venue with ID ${venueId} is not active`, 403);
    this.name = 'VenueNotActiveError';
  }
}
// Helper function to handle API errors
const handleApiError = (error: unknown, defaultMessage: string): never => {
  if (axios.isAxiosError(error)) {
    const axiosError = error as AxiosError;
    if (axiosError.response) {
      // Handle specific error status codes
      const status = axiosError.response.status;
      const responseData = axiosError.response.data as { error?: string; message?: string };
      const errorMessage = responseData.error || responseData.message || defaultMessage;
      if (status === 404) {
        if (defaultMessage.includes('table')) {
          throw new TableNotFoundError(defaultMessage.split(' ').pop() || '');
        } else if (defaultMessage.includes('venue')) {
          throw new VenueNotFoundError(defaultMessage.split(' ').pop() || '');
        }
      } else if (status === 403) {
        if (defaultMessage.includes('table')) {
          throw new TableNotActiveError(defaultMessage.split(' ').pop() || '');
        } else if (defaultMessage.includes('venue')) {
          throw new VenueNotActiveError(defaultMessage.split(' ').pop() || '');
        }
      }
      throw new ApiError(errorMessage, status, axiosError.response.data);
    } else if (axiosError.request) {
      throw new ApiError('No response received from server', 503);
    }
  }
  // Handle unknown error types
  throw new ApiError(
    error instanceof Error ? error.message : defaultMessage
  );
};
/**
 * Gets a table by its ID
 * @param tableId - The ID of the table to retrieve
 * @returns The table details
 * @throws {TableNotFoundError} If the table is not found
 * @throws {ApiError} For other API errors
 */
export const getTableById = async (tableId: string): Promise<Table> => {
  try {
    const response = await axios.get(`${API_BASE_URL}/tables/${tableId}`);
    // Check if the table is active
    const table = response.data;
    if (!table.isActive) {
      throw new TableNotActiveError(tableId);
    }
    return table;
  } catch (error) {
    console.error('Error fetching table:', error);
    return handleApiError(error, `Failed to fetch table with ID ${tableId}`);
  }
};
/**
 * Gets table details including venue information
 * @param tableId - The ID of the table to retrieve details for
 * @returns Table details and venue information
 * @throws {TableNotFoundError} If the table is not found
 * @throws {VenueNotFoundError} If the venue is not found
 * @throws {ApiError} For other API errors
 */
export const getTableDetails = async (tableId: string): Promise<{
  table: TableDetails;
  venue: VenueDetails;
}> => {
  try {
    const response = await axios.get(`${API_BASE_URL}/tables/details`, {
      params: { tableId }
    });
    const responseData = response.data;
    // Validate the response data
    if (!responseData.table) {
      throw new TableNotFoundError(tableId);
    }
    if (!responseData.venue) {
      throw new VenueNotFoundError(responseData.table.venueId || 'unknown');
    }
    // Check if the table is active
    if (!responseData.table.isActive) {
      throw new TableNotActiveError(tableId);
    }
    return {
      table: responseData.table,
      venue: responseData.venue
    };
  } catch (error) {
    console.error('Error fetching table details:', error);
    return handleApiError(error, `Failed to fetch details for table ID ${tableId}`);
  }
};
/**
 * Verifies if a table exists and is available
 * @param tableId - The ID of the table to verify
 * @returns Table verification result with venue data if available
 */
export const verifyTableStatus = async (tableId: string): Promise<{
  exists: boolean;
  isAvailable: boolean;
  venue?: VenueDetails;
}> => {
  try {
    // First try the real API endpoint
    try {
      const response = await axios.get(`${API_BASE_URL}/tables/${tableId}/status`);
      return response.data.data;
    } catch (apiError) {
      console.log('API not available, using fallback verification');
      // FALLBACK: If API is not available, use local verification for demo
      // In a real app, you would handle this differently
      // For demo purposes, accept any table ID that starts with valid format
      // or use specific test IDs
      const isValidFormat = 
        /^[0-9a-f]{24}$/.test(tableId) || // MongoDB ObjectId format
        /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/.test(tableId) || // UUID format
        tableId === '123456'; // Test ID
      // Always consider these specific IDs as valid for testing
      const testTableIds = [
        '681a581f1a12c59b214b389d',
        '681a582f1a12c59b214b393a',
        '123456'
      ];
      const exists = isValidFormat || testTableIds.includes(tableId);
      const isAvailable = exists; // Consider all existing tables as available in demo
      // Return fallback data
      return {
        exists,
        isAvailable,
        venue: exists ? {
          _id: `venue_${tableId}`,
          name: `Table ${tableId}`,
          description: 'Fallback venue data',
          address: '123 Test Street',
          logo: '/placeholder.jpg',
          openingHours: {
            'Monday': { open: '09:00', close: '22:00' }
          }
        } : undefined
      };
    }
  } catch (error) {
    console.error('Error verifying table status:', error);
    return {
      exists: false,
      isAvailable: false
    };
  }
};
</file>

<file path="src/components/BottomNav.tsx">
import React from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import { Menu, Wallet, Bell, ClipboardList } from 'lucide-react';
import { useCart } from '@/context/CartContext';
import { useTableInfo } from '@/context/TableContext';
export const BottomNav: React.FC = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const { cartItems } = useCart();
  const { tableId } = useTableInfo();
  // Special case for menu button to ensure we always pass the table ID
  const handleMenuClick = () => {
    // Check all possible sources of table ID
    const storedTableId = localStorage.getItem('currentTableId') || 
                         localStorage.getItem('table_id') || 
                         localStorage.getItem('tableId');
    const effectiveTableId = tableId || storedTableId || '';
    console.log('Navigating to menu with table ID:', effectiveTableId);
    if (effectiveTableId) {
      navigate(`/?table=${effectiveTableId}`);
    } else {
      navigate('/');
    }
  };
  // Helper function to get path with table ID if available
  const getPathWithTableId = (path: string): string => {
    if (tableId) {
      const separator = path.includes('?') ? '&' : '?';
      return `${path}${separator}table=${tableId}`;
    }
    return path;
  };
  const navItems = [
    {
      path: '/',
      icon: <Menu className="h-6 w-6" />,
      label: 'Menu',
      onClick: handleMenuClick // Special handler for menu
    },
    {
      path: '/my-orders',
      icon: <ClipboardList className="h-6 w-6" />,
      label: 'My Orders',
      onClick: () => navigate(getPathWithTableId('/my-orders'))
    },
    {
      path: '/bill',
      icon: <Wallet className="h-6 w-6" />,
      label: 'Get Bill',
      onClick: () => navigate(getPathWithTableId('/bill'))
    },
    {
      path: '/call-waiter',
      icon: <Bell className="h-6 w-6" />,
      label: 'Call Waiter',
      onClick: () => navigate(getPathWithTableId('/call-waiter'))
    },
  ];
  const currentPath = location.pathname === '/' || location.pathname === '/menu' ? '/' : location.pathname;
  return (
    <div className="fixed bottom-0 left-0 right-0 z-50 bg-[#1F1D2B] border-t border-[#2D303E] py-2">
      <div className="flex items-center justify-around w-full">
        {navItems.map((item) => {
          // Check if path is active without considering query parameters
          const basePath = item.path.split('?')[0];
          const currentPath = location.pathname;
          const isActive = currentPath === basePath;
          return (
            <div
              key={item.path} 
              className="flex flex-col items-center relative"
              onClick={item.onClick || (() => navigate(item.path))}
              style={{ cursor: 'pointer' }}
            >
              <div 
                className={`p-1.5 transition-all duration-200 ${
                  isActive ? 'bg-[#252836] rounded-lg' : ''
                }`}
              >
                <div className={isActive ? 'text-[#6C5ECF]' : 'text-gray-400'}>
                  {item.icon}
                </div>
              </div>
              <span 
                className={`text-xs mt-0.5 ${isActive ? 'text-[#6C5ECF] font-medium' : 'text-gray-400'}`}
              >
                {item.label}
              </span>
              {basePath === '/my-orders' && Array.isArray(cartItems) && cartItems.length > 0 && (
                <span className="absolute -top-1 right-0 bg-red-500 text-white text-xs w-4 h-4 flex items-center justify-center rounded-full">
                  {cartItems.length}
                </span>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
};
export default BottomNav;
</file>

<file path="src/components/CategoryGrid.tsx">
import React from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { ChevronRight } from 'lucide-react';
import { Skeleton } from '@/components/ui/skeleton';
import { Card, CardContent } from '@/components/ui/card'; 
// Skeleton Loader Component
const CategorySkeleton = () => (
  <div className="space-y-4 px-4">
    {[...Array(4)].map((_, i) => (
      <div key={i} className="relative overflow-hidden rounded-xl">
        <div className="relative h-48 w-full overflow-hidden">
          {/* Image Skeleton */}
          <Skeleton className="w-full h-full bg-gray-800/50" />
          {/* Gradient Overlay */}
          <div className="absolute inset-0 bg-gradient-to-br from-black/70 via-black/40 to-black/20" />
          {/* Left Border */}
          <div className="absolute left-0 top-0 bottom-0 w-1.5 bg-gray-700" />
          {/* Content Skeleton */}
          <div className="absolute bottom-0 left-0 right-0 pb-4 px-4">
            <div className="flex justify-between items-end">
              <div className="space-y-2 pl-2 w-2/3">
                <Skeleton className="h-6 w-3/4 bg-gray-600" />
                <div className="flex gap-2">
                  <Skeleton className="h-6 w-20 bg-gray-600 rounded-full" />
                  <Skeleton className="h-6 w-16 bg-gray-600 rounded-full" />
                </div>
              </div>
              <Skeleton className="w-10 h-10 rounded-full bg-gray-600" />
            </div>
          </div>
        </div>
      </div>
    ))}
  </div>
);
interface Category {
  id: string;
  name: string;
  image?: string;
  subCategories: string[];
  subCategoryCount: number;
  totalSubSubCategoryCount: number;
  isActive?: boolean;
}
interface CategoryGridProps {
  categories: Category[];
  isLoading?: boolean;
}
const CategoryGrid: React.FC<CategoryGridProps> = ({ categories, isLoading = false }) => {
  if (isLoading) {
    return <CategorySkeleton />;
  }
  const navigate = useNavigate();
  const location = useLocation();
  // Get table ID from URL if it exists
  const queryParams = new URLSearchParams(location.search);
  const tableId = queryParams.get('table');
  const handleCategoryClick = (categoryId: string) => {
    // Add table ID to the URL if it exists
    const url = tableId 
      ? `/category/${categoryId}?table=${tableId}` 
      : `/category/${categoryId}`;
    navigate(url);
  };
  return (
    <div className="space-y-4 px-4">
      {categories.map((category) => (
        <div 
          key={category.id}
          className={`relative group overflow-hidden rounded-xl cursor-pointer transition-all duration-300 transform hover:scale-[1.02] ${
            category.isActive === false ? 'opacity-60' : ''
          }`}
          onClick={() => handleCategoryClick(category.id)}
        >
          {/* Background Image */}
          <div className="relative h-48 w-full overflow-hidden">
            <img
              src={category.image || '/placeholder-category.jpg'}
              alt={category.name}
              className="w-full h-full object-cover transition-transform duration-500 group-hover:scale-110"
              loading="lazy"
              onError={(e) => {
                const target = e.target as HTMLImageElement;
                target.src = '/placeholder-category.jpg';
              }}
            />
            {/* Gradient Overlay - Full Card */}
            <div className="absolute inset-0 bg-gradient-to-br from-black/70 via-black/40 to-black/20 opacity-100 transition-opacity duration-300" />
            {/* Left Border */}
            <div className="absolute left-0 top-0 bottom-0 w-1.5 bg-purple-600" />
            {/* Category Info Overlay */}
            <div className="absolute bottom-0 left-0 right-0 pb-4 px-4 text-white">
              <div className="flex justify-between items-end">
                {/* Text Container - No Background */}
                <div className="relative pl-2">
                  <h3 className="text-xl font-bold mb-1.5 text-white drop-shadow-md">{category.name}</h3>
                  <div className="flex flex-wrap gap-2">
                    <span className="inline-flex items-center px-2.5 py-1 bg-purple-600/90 text-white text-xs font-medium rounded-full backdrop-blur-sm border border-purple-400/20">
                      {category.subCategoryCount === 0 ? 'No' : category.subCategoryCount} 
                      {category.subCategoryCount === 1 ? 'Category' : 'Categories'}
                    </span>
                    {category.totalSubSubCategoryCount > 0 && (
                      <span className="inline-flex items-center px-2.5 py-1 bg-purple-800/80 text-white text-xs font-medium rounded-full backdrop-blur-sm border border-purple-400/20">
                        {category.totalSubSubCategoryCount} Items
                      </span>
                    )}
                  </div>
                </div>
              </div>
            </div>
            {category.isActive === false && (
              <div className="absolute inset-0 bg-black/60 flex items-center justify-center">
                <span className="text-white text-sm font-medium bg-black/50 px-3 py-1 rounded-full">
                  Currently Unavailable
                </span>
              </div>
            )}
          </div>
        </div>
      ))}
    </div>
  );
};
export default CategoryGrid;
</file>

<file path="src/components/QRScanner.tsx">
import { useState, useCallback } from 'react';
import { useQRScanner, TableError } from '@/hooks/useQRScanner';
import { useCart } from '@/context/CartContext';
import { MenuItem } from '@/api/menuService';
import { ChevronRightIcon, ArrowLeftIcon, QrCodeIcon, SearchIcon, Loader2Icon, AlertTriangleIcon } from 'lucide-react';
interface QRScannerProps {
  onScanComplete?: (tableId: string) => void;
}
// Breadcrumb component for navigation
const Breadcrumb: React.FC<{
  category?: { id: string; name: string };
  subcategory?: { id: string; name: string };
  subsubcategory?: { id: string; name: string };
  onNavigate: (level: 'category' | 'subcategory' | 'subsubcategory' | null) => void;
}> = ({ category, subcategory, subsubcategory, onNavigate }) => (
  <nav className="flex items-center space-x-2 text-sm text-gray-500 overflow-x-auto py-2">
    <button 
      onClick={() => onNavigate(null)}
      className="hover:text-gray-700 flex-shrink-0"
    >
      Menu
    </button>
    {category && (
      <>
        <ChevronRightIcon className="h-4 w-4 flex-shrink-0" />
        <button 
          onClick={() => onNavigate('category')}
          className="hover:text-gray-700 flex-shrink-0"
        >
          {category.name}
        </button>
      </>
    )}
    {subcategory && (
      <>
        <ChevronRightIcon className="h-4 w-4 flex-shrink-0" />
        <button 
          onClick={() => onNavigate('subcategory')}
          className="hover:text-gray-700 flex-shrink-0"
        >
          {subcategory.name}
        </button>
      </>
    )}
    {subsubcategory && (
      <>
        <ChevronRightIcon className="h-4 w-4 flex-shrink-0" />
        <button 
          onClick={() => onNavigate('subsubcategory')}
          className="hover:text-gray-700 flex-shrink-0"
        >
          {subsubcategory.name}
        </button>
      </>
    )}
  </nav>
);
// Alert component for errors and warnings
const Alert: React.FC<{
  type: 'error' | 'warning' | 'info';
  message: string;
  onDismiss?: () => void;
}> = ({ type, message, onDismiss }) => {
  const bgColor = 
    type === 'error' ? 'bg-red-100' : 
    type === 'warning' ? 'bg-yellow-100' : 
    'bg-blue-100';
  const textColor = 
    type === 'error' ? 'text-red-800' : 
    type === 'warning' ? 'text-yellow-800' : 
    'text-blue-800';
  return (
    <div className={`rounded-lg p-4 ${bgColor} my-4`}>
      <div className="flex items-start">
        <div className="flex-shrink-0">
          <AlertTriangleIcon className={`h-5 w-5 ${textColor}`} />
        </div>
        <div className="ml-3">
          <p className={`text-sm font-medium ${textColor}`}>{message}</p>
        </div>
        {onDismiss && (
          <div className="ml-auto pl-3">
            <button
              onClick={onDismiss}
              className={`inline-flex rounded-md p-1.5 ${textColor} hover:bg-red-200 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2`}
            >
              <span className="sr-only">Dismiss</span>
              <svg className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path
                  fillRule="evenodd"
                  d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                  clipRule="evenodd"
                />
              </svg>
            </button>
          </div>
        )}
      </div>
    </div>
  );
};
// Menu Item Card component
const MenuItemCard: React.FC<{
  item: MenuItem;
}> = ({ item }) => (
  <div className="bg-white rounded-lg shadow-md overflow-hidden">
    {item.image && (
      <div className="w-full h-48 overflow-hidden">
        <img 
          src={item.image} 
          alt={item.name} 
          className="w-full h-full object-cover"
          onError={(e) => {
            // Replace with placeholder on error
            (e.target as HTMLImageElement).src = 'https://via.placeholder.com/300x200?text=No+Image';
          }}
        />
      </div>
    )}
    <div className="p-4">
      <div className="flex justify-between items-start">
        <h3 className="text-lg font-semibold text-gray-900">{item.name}</h3>
        <span className="text-lg font-bold text-green-600">${item.price.toFixed(2)}</span>
      </div>
      <p className="mt-2 text-sm text-gray-600">{item.description}</p>
      {/* Preparation time */}
      {item.preparationTime && (
        <div className="mt-2 text-xs text-gray-500">
          Preparation time: {item.preparationTime} min
        </div>
      )}
      {/* Allergens */}
      {item.allergens && item.allergens.length > 0 && (
        <div className="mt-2">
          <p className="text-xs font-medium text-gray-500">Allergens:</p>
          <div className="flex flex-wrap gap-1 mt-1">
            {item.allergens.map((allergen) => (
              <span 
                key={allergen} 
                className="px-2 py-1 text-xs bg-red-100 text-red-800 rounded-full"
              >
                {allergen}
              </span>
            ))}
          </div>
        </div>
      )}
      {/* Available status */}
      <div className="mt-3 flex items-center">
        <span 
          className={`inline-block w-3 h-3 rounded-full mr-2 ${
            item.isAvailable ? 'bg-green-500' : 'bg-red-500'
          }`}
        ></span>
        <span className="text-sm text-gray-600">
          {item.isAvailable ? 'Available' : 'Unavailable'}
        </span>
      </div>
    </div>
  </div>
);
export const QRScanner: React.FC<QRScannerProps> = ({ onScanComplete }) => {
  const { 
    isLoading, 
    error, 
    data, 
    handleScan, 
    selectCategory, 
    selectSubcategory, 
    selectSubSubcategory,
    resetError,
    resetState
  } = useQRScanner();
  const [tableId, setTableId] = useState('');
  const { clearCart } = useCart();
  // Reset scanner and clear cart
  const resetScanner = useCallback(() => {
    clearCart();
    resetState();
    setTableId('');
  }, [clearCart, resetState]);
  // Handle form submission for manual table ID input
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!tableId.trim()) return;
    // Clear the cart before scanning new table
    clearCart();
    try {
      await handleScan(tableId.trim());
      if (onScanComplete) {
        onScanComplete(tableId.trim());
      }
    } catch (error) {
      console.error('Error in form submission:', error);
      // Error will be handled by the useQRScanner hook
    }
  };
  // Navigation handler for breadcrumb
  const handleNavigation = async (level: 'category' | 'subcategory' | 'subsubcategory' | null) => {
    if (!data.tableData?.venue) return;
    if (level === null) {
      // Reset to top level (categories)
      if (data.tableData?.table) {
        // Clear cart when navigating back to top level with table scan
        resetScanner();
        await handleScan(data.tableData.table._id);
      }
      return;
    }
    if (level === 'category' && data.currentCategory) {
      // Navigate to category level
      await selectCategory(data.currentCategory.id, data.currentCategory.name);
      return;
    }
    if (level === 'subcategory' && data.currentSubcategory) {
      // Navigate to subcategory level
      await selectSubcategory(data.currentSubcategory.id, data.currentSubcategory.name);
      return;
    }
    // No need to handle 'subsubcategory' as it's already the deepest level
  };
  // Helper to get items to display based on current navigation level
  const getItemsToDisplay = (): MenuItem[] => {
    if (!data.menuData) return [];
    // If we're at subsubcategory level, show those items
    if (data.currentSubSubcategory && data.subsubcategoryData) {
      return data.subsubcategoryData.menuItems;
    }
    // If we're at subcategory level, show those items
    if (data.currentSubcategory && data.subcategoryData) {
      return data.subcategoryData.menuItems;
    }
    // If we're at category level, show those items
    if (data.currentCategory && data.categoryData) {
      return data.categoryData.menuItems;
    }
    // Otherwise show venue menu items
    return data.menuData.menuItems || [];
  };
  return (
    <div className="max-w-4xl mx-auto p-4">
      <h1 className="text-2xl font-bold text-gray-900 mb-6">In-Seat Menu</h1>
      {/* Table Scanning Section */}
      {!data.tableData && (
        <div className="bg-white rounded-lg shadow p-6 mb-6">
          <h2 className="text-xl font-semibold text-gray-800 mb-4">Scan Table QR Code</h2>
          {/* QR Code Scanner (Placeholder) */}
          <div className="mb-4 p-6 border-2 border-dashed border-gray-300 rounded-lg flex flex-col items-center justify-center">
            <QrCodeIcon className="h-16 w-16 text-gray-400 mb-2" />
            <p className="text-gray-500 text-center">
              Camera access not available. Please enter your table ID manually.
            </p>
          </div>
          {/* Manual Input Form */}
          <form onSubmit={handleSubmit} className="mb-4">
            <div className="flex flex-col sm:flex-row gap-3">
              <div className="relative flex-grow">
                <div className="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
                  <SearchIcon className="h-5 w-5 text-gray-400" />
                </div>
                <input
                  type="text"
                  value={tableId}
                  onChange={(e) => setTableId(e.target.value)}
                  className="pl-10 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                  placeholder="Enter table ID"
                  disabled={isLoading}
                />
              </div>
              <button
                type="submit"
                disabled={isLoading || !tableId.trim()}
                className="inline-flex justify-center rounded-md border border-transparent bg-indigo-600 py-2 px-4 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:bg-gray-400 disabled:cursor-not-allowed"
              >
                {isLoading ? (
                  <Loader2Icon className="h-5 w-5 animate-spin mr-2" />
                ) : null}
                {isLoading ? 'Loading...' : 'Submit'}
              </button>
            </div>
          </form>
          {/* Error Display */}
          {error && (
            <Alert 
              type="error" 
              message={error.message}
              onDismiss={resetError}
            />
          )}
        </div>
      )}
      {/* Menu Display Section */}
      {data.tableData && (
        <div className="bg-white rounded-lg shadow p-6">
          {/* Venue Information */}
          <div className="mb-6">
            <h2 className="text-xl font-semibold text-gray-900">
              {data.tableData.venue.name}
            </h2>
            <p className="text-gray-600 mt-1">
              Table: {data.tableData.table.number}
            </p>
            {data.tableData.venue.description && (
              <p className="text-sm text-gray-500 mt-2">
                {data.tableData.venue.description}
              </p>
            )}
          </div>
          {/* Breadcrumb Navigation */}
          <Breadcrumb 
            category={data.currentCategory}
            subcategory={data.currentSubcategory}
            subsubcategory={data.currentSubSubcategory}
            onNavigate={handleNavigation}
          />
          {/* Loading State */}
          {isLoading && (
            <div className="py-12 flex flex-col items-center justify-center">
              <Loader2Icon className="h-8 w-8 text-indigo-500 animate-spin mb-4" />
              <p className="text-gray-500">Loading menu...</p>
            </div>
          )}
          {!isLoading && (
            <>
              {/* Categories List (Top Level) */}
              {data.menuData && !data.currentCategory && (
                <div className="mt-6">
                  <h3 className="text-lg font-medium text-gray-900 mb-4">Categories</h3>
                  <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                    {data.menuData.categories.map((category) => (
                      <button
                        key={category._id}
                        onClick={() => selectCategory(category._id, category.name)}
                        className="p-4 bg-white border border-gray-200 rounded-lg shadow-sm hover:bg-gray-50 text-left"
                      >
                        <div className="flex items-center">
                          {category.image && (
                            <div className="flex-shrink-0 h-10 w-10 mr-3">
                              <img
                                src={category.image}
                                alt={category.name}
                                className="h-10 w-10 rounded-full object-cover"
                                onError={(e) => {
                                  (e.target as HTMLImageElement).src = 'https://via.placeholder.com/40?text=C';
                                }}
                              />
                            </div>
                          )}
                          <div>
                            <h4 className="text-sm font-medium text-gray-900">{category.name}</h4>
                            {category.description && (
                              <p className="text-xs text-gray-500 mt-1 line-clamp-2">{category.description}</p>
                            )}
                          </div>
                        </div>
                      </button>
                    ))}
                  </div>
                </div>
              )}
              {/* Subcategories (When Category is Selected) */}
              {data.categoryData?.subcategories && data.categoryData.subcategories.length > 0 && (
                <div className="mt-6">
                  <h3 className="text-lg font-medium text-gray-900 mb-4">
                    {data.currentCategory?.name} - Subcategories
                  </h3>
                  <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                    {data.categoryData.subcategories.map((subcategory) => (
                      <button
                        key={subcategory._id}
                        onClick={() => selectSubcategory(subcategory._id, subcategory.name)}
                        className="p-4 bg-white border border-gray-200 rounded-lg shadow-sm hover:bg-gray-50 text-left"
                      >
                        <h4 className="text-sm font-medium text-gray-900">{subcategory.name}</h4>
                        {subcategory.description && (
                          <p className="text-xs text-gray-500 mt-1 line-clamp-2">{subcategory.description}</p>
                        )}
                      </button>
                    ))}
                  </div>
                </div>
              )}
              {/* Subsubcategories (When Subcategory is Selected) */}
              {data.subcategoryData?.subsubcategories && data.subcategoryData.subsubcategories.length > 0 && (
                <div className="mt-6">
                  <h3 className="text-lg font-medium text-gray-900 mb-4">
                    {data.currentSubcategory?.name} - Options
                  </h3>
                  <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                    {data.subcategoryData.subsubcategories.map((subsubcategory) => (
                      <button
                        key={subsubcategory._id}
                        onClick={() => selectSubSubcategory(subsubcategory._id, subsubcategory.name)}
                        className="p-4 bg-white border border-gray-200 rounded-lg shadow-sm hover:bg-gray-50 text-left"
                      >
                        <h4 className="text-sm font-medium text-gray-900">{subsubcategory.name}</h4>
                        {subsubcategory.description && (
                          <p className="text-xs text-gray-500 mt-1 line-clamp-2">{subsubcategory.description}</p>
                        )}
                      </button>
                    ))}
                  </div>
                </div>
              )}
              {/* Menu Items */}
              {getItemsToDisplay().length > 0 && (
                <div className="mt-8">
                  <h3 className="text-lg font-medium text-gray-900 mb-4">
                    {data.currentSubSubcategory?.name || data.currentSubcategory?.name || data.currentCategory?.name || 'All Items'}
                  </h3>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    {getItemsToDisplay().map((item) => (
                      <MenuItemCard key={item._id} item={item} />
                    ))}
                  </div>
                </div>
              )}
              {/* Empty State */}
              {getItemsToDisplay().length === 0 && !isLoading && (
                <div className="py-12 flex flex-col items-center justify-center text-center">
                  <p className="text-gray-500 mb-2">No menu items found.</p>
                  <p className="text-sm text-gray-400">
                    {data.currentSubSubcategory ? 
                      'Try selecting a different subsubcategory' : 
                      data.currentSubcategory ? 
                        'Try selecting a different subcategory' : 
                        data.currentCategory ? 
                          'Try selecting a different category' : 
                          'No items available for this venue'}
                  </p>
                </div>
              )}
              {/* Back Navigation */}
              {(data.currentCategory || data.currentSubcategory || data.currentSubSubcategory) && (
                <div className="mt-8">
                  <button
                    onClick={() => handleNavigation(
                      data.currentSubSubcategory ? 'subcategory' : 
                      data.currentSubcategory ? 'category' : null
                    )}
                    className="inline-flex items-center text-sm text-gray-600 hover:text-gray-900"
                  >
                    <ArrowLeftIcon className="h-4 w-4 mr-1" />
                    Back to {data.currentSubSubcategory ? 'Subcategory' : 
                            data.currentSubcategory ? 'Category' : 'Menu'}
                  </button>
                </div>
              )}
            </>
          )}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/TableHeader.tsx">
import React, { useEffect, useState, useCallback } from 'react';
import { useTableInfo } from '@/context/TableContext';
import { Link, useLocation, useNavigate } from 'react-router-dom';
import { User, ScanLine, Loader2 } from 'lucide-react';
import { useAuth } from '@/context/AuthContext';
import { AuthService } from '@/services/AuthService';
import { cn } from '@/lib/utils';
import { Button } from './ui/button';
import debounce from 'lodash/debounce';
import { useCart } from '@/context/CartContext';
interface TableHeaderProps {
  venueName?: string;
  tableName?: string;
  className?: string;
}
export const TableHeader: React.FC<TableHeaderProps> = ({ 
  venueName, 
  tableName,
  className
}) => {
  const { restaurantName, tableNumber, tableId, setTableInfo, clearTableInfo } = useTableInfo();
  const location = useLocation();
  const navigate = useNavigate();
  const { isAuthenticated, refreshToken, user, updateUser } = useAuth();
  const { clearCart } = useCart();
  const [isLoading, setIsLoading] = useState(false);
  // Create a debounced version of setTableInfo to avoid rapid consecutive updates
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const debouncedSetTableInfo = useCallback(
    debounce((info) => {
      setTableInfo(info);
      // Store in localStorage after debounce
      localStorage.setItem('tableInfo', JSON.stringify(info));
      localStorage.setItem('currentTableId', info.tableId);
      localStorage.setItem('currentVenueId', info.restaurantName);
      setIsLoading(false);
    }, 300),
    [setTableInfo]
  );
  useEffect(() => {
    // Skip this effect if tableName is provided via props (controlled component mode)
    if (tableName) {
      return;
    }
    // Extract table ID from URL query parameters
    const queryParams = new URLSearchParams(location.search);
    const tableParam = queryParams.get('table');
    // Only process if there's a table param in the URL
    if (tableParam) {
      // Don't update if the table ID is already set correctly
      if (tableParam === tableId) {
        console.log('Table ID already set correctly:', tableParam);
        return;
      }
      console.log('Setting table info from URL param:', tableParam);
      setIsLoading(true);
      const newTableInfo = {
        tableNumber: tableParam,
        tableId: tableParam,
        restaurantName: venueName || restaurantName || 'InSeat'
      };
      // Use the debounced function to prevent rapid updates
      debouncedSetTableInfo(newTableInfo);
    }
    // If no table in URL and no table in context, try to retrieve from localStorage
    else if (!tableNumber && !tableId) {
      const storedTable = localStorage.getItem('tableInfo');
      if (storedTable) {
        try {
          const parsedInfo = JSON.parse(storedTable);
          if (parsedInfo.tableId && parsedInfo.tableId !== tableId) {
            console.log('Using stored table info:', parsedInfo);
            setTableInfo(parsedInfo);
          }
        } catch (e) {
          console.error('Error parsing stored table info:', e);
          localStorage.removeItem('tableInfo');
        }
      }
    }
  // Include only dependencies that should trigger a re-evaluation
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [location.search, tableName, tableId, debouncedSetTableInfo]);
  // Handle scanning a new table
  const handleScanClick = () => {
    console.log('Clearing all table information and cart');
    // Clear all table information
    clearTableInfo();
    // Clear the cart as well when table info is cleared
    clearCart();
    // Remove from localStorage
    localStorage.removeItem('tableInfo');
    localStorage.removeItem('currentTableId');
    localStorage.removeItem('currentVenueId');
    // Navigate to scan page
    navigate('/scan');
  };
  // Use props with fallbacks to context values
  const displayVenueName = venueName || restaurantName || 'InSeat';
  // Format table ID to show as Table + last 4 characters if it's long
  const formatTableName = (tableId: string) => {
    if (tableId && tableId.length > 8) {
      return tableId.slice(-4);
    }
    return tableId;
  };
  // Use provided tableName first, then fall back to context value
  const effectiveTableId = tableName || tableNumber || tableId || '';
  const displayTableNumber = effectiveTableId ? 
    `TABLE ${formatTableName(effectiveTableId)}` : 
    'NO TABLE';
  return (
    <header className={cn(
      "fixed top-0 left-0 right-0 z-50 transition-all duration-300",
      className
    )}>
      <div className="flex justify-between items-center px-4 py-3 bg-[#16141F] text-white border-b border-[#2D303E]">
        <div className="flex-1">
          <h1 className="text-sm font-medium truncate">{displayVenueName}</h1>
        </div>
        <div className="flex items-center justify-center bg-[#2D303E] rounded-md px-3 py-1">
          {isLoading ? (
            <Loader2 className="h-4 w-4 text-white animate-spin" />
          ) : (
            <span className="text-xs font-semibold tracking-wider text-white">{displayTableNumber}</span>
          )}
        </div>
        <div className="flex-1 flex justify-end items-center gap-3">
          {/* QR Scan button */}
          <Button 
            variant="ghost" 
            size="icon" 
            className="h-8 w-8 text-white"
            onClick={handleScanClick}
            aria-label="Scan QR Code"
          >
            <ScanLine className="h-5 w-5" />
          </Button>
          {/* Account button */}
          <Link 
            to="/account"
            className="flex items-center text-white h-8 w-8 rounded-md hover:bg-[#3a3e52] flex items-center justify-center"
            aria-label="Account"
            onClick={(e) => {
              // Check for auth cookies directly
              const cookies = document.cookie.split(';');
              const hasAuthCookie = cookies.some(cookie => 
                cookie.trim().startsWith('auth_token=') || 
                cookie.trim().startsWith('access_token=')
              );
              // If we have auth cookies but isAuthenticated is false, update the auth state
              if (hasAuthCookie && !isAuthenticated) {
                console.log('Auth cookie found but not authenticated in state - updating auth state');
                window.dispatchEvent(new CustomEvent('auth-state-changed', { detail: { isAuthenticated: true } }));
              }
            }}
          >
            <User className="h-5 w-5" />
          </Link>
        </div>
      </div>
    </header>
  );
};
// Keep default export for backward compatibility
export default TableHeader;
</file>

<file path="src/pages/Account.tsx">
import React, { useState, useEffect } from 'react';
import { useAuth } from '@/context/AuthContext';
import { useOrders } from '@/context/OrdersContext';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { ArrowLeft, LogOut, Gift, History, User, Award, Edit } from 'lucide-react';
import { Link, useNavigate } from 'react-router-dom';
import { format } from 'date-fns';
import { toast } from 'sonner';
import { useTableInfo } from '@/context/TableContext';
const Account: React.FC = () => {
  const { user, logout, addLoyaltyPoints, isAuthenticated, isLoading } = useAuth();
  const { orders } = useOrders();
  const [activeTab, setActiveTab] = useState("profile");
  const navigate = useNavigate();
  const { tableId } = useTableInfo();
  const { pathname } = window.location;
  // Check for auth cookies directly
  const hasAuthCookie = () => {
    const cookies = document.cookie.split(';');
    return cookies.some(cookie => 
      cookie.trim().startsWith('auth_token=') || 
      cookie.trim().startsWith('access_token=')
    );
  };
  // Handle navigation in useEffect to avoid side effects during render
  useEffect(() => {
    // If we're loading, don't do anything yet
    if (isLoading) return;
    // Check for auth cookies first - if present, allow access even if isAuthenticated is false
    if (!isAuthenticated && !hasAuthCookie()) {
      console.log('No authentication token found, redirecting to login from account page');
      // Store the current path to redirect back after login
      if (pathname !== '/login') {
        navigate('/login', { state: { from: pathname }, replace: true });
      } else {
        navigate('/login', { replace: true });
      }
    } else if (!isAuthenticated && hasAuthCookie()) {
      console.log('Auth cookie found but not authenticated in state - allowing account page access and updating auth state');
      // Notify the auth context that we should be authenticated
      window.dispatchEvent(new CustomEvent('auth-state-changed', { detail: { isAuthenticated: true } }));
      // Force a reload of orders if we have auth cookies but aren't officially authenticated
      const fetchOrders = async () => {
        try {
          const response = await fetch('/api/orders/my-orders', {
            credentials: 'include'
          });
          if (response.ok) {
            const data = await response.json();
            console.log('Successfully fetched orders:', data);
          }
        } catch (error) {
          console.error('Error fetching orders:', error);
        }
      };
      fetchOrders();
    }
  }, [isAuthenticated, isLoading, pathname, navigate]);
  // Show loading state while checking authentication
  if (isLoading) {
    return <div className="container mx-auto px-4 py-6 mt-16 mb-20">Loading...</div>;
  }
  // If not authenticated and no auth cookie, don't render anything (will be redirected by the effect)
  if (!isAuthenticated && !hasAuthCookie()) {
    return null;
  }
  // If we have an auth cookie but no user data yet, show loading
  if (!user && hasAuthCookie()) {
    return <div className="container mx-auto px-4 py-6 mt-16 mb-20">Loading user data...</div>;
  }
  // Get initials for avatar fallback
  const getInitials = () => {
    if (!user) return '';
    // Use firstName and lastName properties instead of expecting a name string
    const firstInitial = user.firstName ? user.firstName[0] : '';
    const lastInitial = user.lastName ? user.lastName[0] : '';
    return (firstInitial + lastInitial).toUpperCase();
  };
  const handleLogout = async () => {
    try {
      // Call the logout function from auth context
      await logout();
      // Clear any table-related data from localStorage
      localStorage.removeItem('tableInfo');
      // Redirect to home page
      toast.success('Logged out successfully');
      navigate('/', { replace: true });
    } catch (error) {
      console.error('Error during logout:', error);
      toast.error('There was an issue logging out');
      // Still redirect to home even on error
      navigate('/', { replace: true });
    }
  };
  // Mock function to redeem points (in a real app, this would call an API)
  const handleRedeemPoints = (points: number, reward: string) => {
    if (user.loyaltyPoints >= points) {
      toast.success(`Redeemed ${reward} for ${points} points!`);
      // In a real app, this would call an API to update user's loyalty points
    } else {
      toast.error(`Not enough loyalty points to redeem ${reward}`);
    }
  };
  // Function to determine loyalty tier
  const getLoyaltyTier = (points: number) => {
    if (points >= 1000) return { name: 'Platinum', color: 'bg-zinc-300 text-zinc-900' };
    if (points >= 500) return { name: 'Gold', color: 'bg-amber-400 text-amber-950' };
    if (points >= 200) return { name: 'Silver', color: 'bg-gray-400 text-gray-900' };
    return { name: 'Bronze', color: 'bg-amber-700 text-amber-50' };
  };
  const userTier = getLoyaltyTier(user.loyaltyPoints);
  // Add some test loyalty points (would remove in production)
  const handleAddTestPoints = () => {
    addLoyaltyPoints(50);
    toast.success('Added 50 test loyalty points!');
  };
  const handleGoBack = () =>{
    const storedTableId = localStorage.getItem('currentTableId');
    const effectiveTableId = tableId || storedTableId || '';
    navigate(`/?table=${effectiveTableId}`);
  }
  return (
    <div className="container mx-auto px-4 py-6 mt-16 mb-20">
      <div className="flex justify-between items-center mb-6">
        <Button 
          variant="ghost" 
          size="sm"
          onClick={handleGoBack}
          className="text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white"
        >
          <ArrowLeft className="mr-2" size={16} />
          Back to menu
        </Button>
        <Button 
          variant="ghost" 
          size="sm"
          onClick={handleLogout}
          className="text-red-600 dark:text-red-400 hover:text-red-700 hover:bg-red-50 dark:hover:bg-red-900/20"
        >
          <LogOut className="h-4 w-4 mr-1" />
          Logout
        </Button>
      </div>
      <div className="flex flex-col md:flex-row gap-6">
        {/* Left column - User info */}
        <div className="w-full md:w-1/3">
          <Card className="mb-6">
            <CardHeader className="pb-2">
              <div className="flex justify-between">
                <Avatar className="h-16 w-16 mb-2">
                  <AvatarFallback className="bg-emerald-100 text-emerald-700 dark:bg-emerald-700 dark:text-emerald-100 text-lg">
                    {getInitials()}
                  </AvatarFallback>
                </Avatar>
                <Badge className={`${userTier.color} mt-1`}>
                  {userTier.name} Member
                </Badge>
              </div>
              <CardTitle>{user.name}</CardTitle>
              <CardDescription>{user.email}</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="mb-4">
                <div className="flex justify-between text-sm mb-1">
                  <span className="text-muted-foreground">Loyalty Points</span>
                  <span className="font-medium">{user.loyaltyPoints}</span>
                </div>
                <div className="w-full h-2 bg-gray-100 dark:bg-gray-700 rounded-full overflow-hidden">
                  <div 
                    className="h-full bg-gradient-to-r from-emerald-400 to-emerald-600 dark:from-emerald-600 dark:to-emerald-400" 
                    style={{ 
                      width: `${Math.min(100, (user.loyaltyPoints / 10))}%` 
                    }}
                  />
                </div>
                {/* For development only */}
                <Button
                  variant="outline"
                  size="sm"
                  className="mt-4 w-full text-xs"
                  onClick={handleAddTestPoints}
                >
                  Add Test Points (Development Only)
                </Button>
              </div>
              <div className="space-y-2">
                <div className="text-sm">
                  <span className="text-muted-foreground">Member since:</span>
                  <span className="float-right">
                    {user.createdAt ? format(new Date(user.createdAt), 'MMM dd, yyyy') : 'N/A'}
                  </span>
                </div>
                <div className="text-sm">
                  <span className="text-muted-foreground">Total orders:</span>
                  <span className="float-right">{user.orders ? user.orders.length : 0}</span>
                </div>
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardHeader>
              <CardTitle className="text-base flex items-center">
                <Award className="h-4 w-4 mr-2 text-emerald-600" />
                Available Rewards
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="flex justify-between items-center">
                <div>
                  <h4 className="text-sm font-medium">Free Appetizer</h4>
                  <p className="text-xs text-muted-foreground">Any appetizer up to $12</p>
                </div>
                <Button
                  size="sm" 
                  variant="outline" 
                  onClick={() => handleRedeemPoints(200, 'Free Appetizer')}
                  disabled={user.loyaltyPoints < 200}
                >
                  200 pts
                </Button>
              </div>
              <Separator />
              <div className="flex justify-between items-center">
                <div>
                  <h4 className="text-sm font-medium">10% Off Your Order</h4>
                  <p className="text-xs text-muted-foreground">Valid for one order</p>
                </div>
                <Button 
                  size="sm" 
                  variant="outline"
                  onClick={() => handleRedeemPoints(350, '10% Off Your Order')}
                  disabled={user.loyaltyPoints < 350}
                >
                  350 pts
                </Button>
              </div>
              <Separator />
              <div className="flex justify-between items-center">
                <div>
                  <h4 className="text-sm font-medium">Free Dessert</h4>
                  <p className="text-xs text-muted-foreground">Any dessert on the menu</p>
                </div>
                <Button 
                  size="sm" 
                  variant="outline"
                  onClick={() => handleRedeemPoints(450, 'Free Dessert')}
                  disabled={user.loyaltyPoints < 450}
                >
                  450 pts
                </Button>
              </div>
            </CardContent>
          </Card>
        </div>
        {/* Right column - Tabs for Profile and Orders */}
        <div className="w-full md:w-2/3">
          <Card>
            <CardHeader className="pb-2">
              <Tabs defaultValue="profile" value={activeTab} onValueChange={setActiveTab}>
                <TabsList className="grid w-full grid-cols-2 mb-4">
                  <TabsTrigger value="profile" className="flex items-center justify-center">
                    <User className="h-4 w-4 mr-2" />
                    Profile
                  </TabsTrigger>
                  <TabsTrigger value="orders" className="flex items-center justify-center">
                    <History className="h-4 w-4 mr-2" />
                    Order History
                  </TabsTrigger>
                </TabsList>
                <div>
                  <TabsContent value="profile" className="m-0">
                    <CardTitle className="text-xl mb-1">My Profile</CardTitle>
                    <CardDescription>Manage your account information</CardDescription>
                  </TabsContent>
                  <TabsContent value="orders" className="m-0">
                    <CardTitle className="text-xl mb-1">Order History</CardTitle>
                    <CardDescription>Review your past orders</CardDescription>
                  </TabsContent>
                </div>
                <CardContent className="pt-6">
                  <TabsContent value="profile" className="m-0">
                    <div className="space-y-4">
                      <div>
                        <label className="text-sm font-medium">Full Name</label>
                        <div className="flex items-center justify-between mt-1">
                          <span>{user.name}</span>
                          <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
                            <Edit className="h-4 w-4 text-muted-foreground" />
                          </Button>
                        </div>
                      </div>
                      <Separator />
                      <div>
                        <label className="text-sm font-medium">Email Address</label>
                        <div className="flex items-center justify-between mt-1">
                          <span>{user.email}</span>
                          <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
                            <Edit className="h-4 w-4 text-muted-foreground" />
                          </Button>
                        </div>
                      </div>
                      <Separator />
                      <div>
                        <label className="text-sm font-medium">Password</label>
                        <div className="flex items-center justify-between mt-1">
                          <span>â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢</span>
                          <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
                            <Edit className="h-4 w-4 text-muted-foreground" />
                          </Button>
                        </div>
                      </div>
                      <Separator />
                      <div>
                        <label className="text-sm font-medium">Communication Preferences</label>
                        <div className="mt-2 space-y-2">
                          <div className="flex items-center">
                            <input type="checkbox" id="emailNotif" className="mr-2" defaultChecked />
                            <label htmlFor="emailNotif" className="text-sm">Email notifications</label>
                          </div>
                          <div className="flex items-center">
                            <input type="checkbox" id="smsNotif" className="mr-2" />
                            <label htmlFor="smsNotif" className="text-sm">SMS notifications</label>
                          </div>
                        </div>
                      </div>
                    </div>
                  </TabsContent>
                  <TabsContent value="orders" className="m-0">
                    {orders.length > 0 ? (
                      <div className="space-y-4">
                        {orders.map((order) => (
                          <Card key={order.id} className="overflow-hidden">
                            <div className="bg-gray-50 dark:bg-gray-800 px-4 py-2 flex justify-between items-center">
                              <div>
                                <span className="text-sm font-medium">
                                  Order #{order.id ? order.id.substring(0, 8) : 'Unknown'}
                                </span>
                                <span className="text-xs text-muted-foreground block">
                                  {order.timestamp ? format(new Date(order.timestamp), 'MMM dd, yyyy - hh:mm a') : 'N/A'}
                                </span>
                              </div>
                              <Badge variant={
                                String(order.status).toLowerCase() === 'completed' ? 'default' :
                                String(order.status).toLowerCase() === 'delivered' ? 'secondary' :
                                String(order.status).toLowerCase() === 'ready' ? 'outline' : 'secondary'
                              }>
                                {order.status ? `${order.status.charAt(0).toUpperCase()}${order.status.slice(1)}` : 'Pending'}
                              </Badge>
                            </div>
                            <CardContent className="p-4">
                              <div className="space-y-2">
                                {order.items.map((item, idx) => (
                                  <div key={idx} className="flex justify-between text-sm">
                                    <span>
                                      {item.quantity}x {item.name}
                                      {item.modifiers && item.modifiers.length > 0 && (
                                        <span className="text-xs text-muted-foreground block pl-4">
                                          {item.modifiers.map(mod => mod.name).join(', ')}
                                        </span>
                                      )}
                                    </span>
                                    <span>${(item.price * item.quantity).toFixed(2)}</span>
                                  </div>
                                ))}
                              </div>
                              <Separator className="my-3" />
                              <div className="flex justify-between font-medium">
                                <span>Total</span>
                                <span>${(order.total || 0).toFixed(2)}</span>
                              </div>
                            </CardContent>
                          </Card>
                        ))}
                      </div>
                    ) : (
                      <div className="text-center py-8">
                        <History className="h-12 w-12 mx-auto mb-3 text-gray-300 dark:text-gray-600" />
                        <h3 className="text-lg font-medium mb-2">No orders yet</h3>
                        <p className="text-muted-foreground text-sm mb-4">You haven't placed any orders yet</p>
                        <Button onClick={() => navigate('/menu')}>Browse Menu</Button>
                      </div>
                    )}
                  </TabsContent>
                </CardContent>
              </Tabs>
            </CardHeader>
          </Card>
        </div>
      </div>
    </div>
  );
};
export default Account;
</file>

<file path="src/pages/Bill.tsx">
import React, { useState } from 'react';
import { useOrders } from '@/context/OrdersContext';
import { Button } from '@/components/ui/button';
import { CreditCard, Landmark, Banknote, Check } from 'lucide-react';
import { toast } from 'sonner';
import { useTableInfo } from '@/context/TableContext';
import { format } from 'date-fns';
import TableHeader from '@/components/TableHeader';
import * as paymentService from '@/api/paymentService';
const Bill: React.FC = () => {
  const { orders, clearOrders } = useOrders();
  const { tableNumber, restaurantName } = useTableInfo();
  const [paymentMethod, setPaymentMethod] = useState<string | null>(null);
  const [isPaying, setIsPaying] = useState(false);
  const [paid, setPaid] = useState(false);
  // Calculate total from all orders
  const subtotal = orders.reduce((sum, order) => sum + order.subtotal, 0);
  const tax = orders.reduce((sum, order) => sum + order.tax, 0);
  const serviceCharge = subtotal * 0.1; // 10% service charge
  const total = subtotal + tax + serviceCharge;
  // Only show the bill if there are orders
  if (orders.length === 0) {
    return (
      <div className="min-h-screen bg-[#16141F] text-white">
        {/* Use the same TableHeader as the menu page */}
        <TableHeader 
          venueName={restaurantName || 'Screen 3'}
          className="bg-[#16141F] text-white"
        />
        <div className="px-4 py-8 mt-16">
          <h1 className="text-2xl font-semibold mb-6">Your Bill</h1>
          <div className="text-center py-12">
            <p className="text-gray-400 mb-4">You don't have any orders to pay for yet</p>
            <Button
              className="bg-purple-600 hover:bg-purple-700 text-white"
              onClick={() => window.location.href = '/'}
            >
              Browse Menu
            </Button>
          </div>
        </div>
      </div>
    );
  }
  const handlePayment = async () => {
    if (!paymentMethod) {
      toast.error('Please select a payment method');
      return;
    }
    setIsPaying(true);
    try {
      // Get order IDs from all orders
      // Handle potential type differences between frontend and backend
      const orderId = typeof orders[0]?.id === 'string' ? orders[0]?.id : 
                     typeof orders[0] === 'object' && '_id' in orders[0] ? (orders[0] as any)._id : 
                     null;
      // Prepare line items for Stripe
      const lineItems = [];
      // Add subtotal items
      orders.forEach(order => {
        order.items.forEach(item => {
          lineItems.push({
            price_data: {
              currency: 'usd',
              product_data: {
                name: item.name
              },
              unit_amount: Math.round(item.price * 100) // Convert to cents
            },
            quantity: item.quantity
          });
        });
      });
      // Add tax as a separate line item
      if (tax > 0) {
        lineItems.push({
          price_data: {
            currency: 'usd',
            product_data: {
              name: 'Tax'
            },
            unit_amount: Math.round(tax * 100) // Convert to cents
          },
          quantity: 1
        });
      }
      // Add service charge as a separate line item
      if (serviceCharge > 0) {
        lineItems.push({
          price_data: {
            currency: 'usd',
            product_data: {
              name: 'Service Charge'
            },
            unit_amount: Math.round(serviceCharge * 100) // Convert to cents
          },
          quantity: 1
        });
      }
      // Get table and restaurant information
      const tableId = localStorage.getItem('currentTableId') || 
                      localStorage.getItem('table_id') || 
                      localStorage.getItem('tableId');
      const restaurantId = localStorage.getItem('restaurantId') || 
                           localStorage.getItem('restaurant_id');
      // Get the items from all orders to create a single checkout session
      const allItems = [];
      orders.forEach(order => {
        if (order.items) {
          order.items.forEach(item => {
            allItems.push({
              id: item.id || (item as any)._id || '',
              name: item.name,
              price: item.price,
              quantity: item.quantity,
              modifiers: item.modifiers || [],
              specialInstructions: item.specialInstructions || ''
            });
          });
        }
      });
      // Create a checkout session with Stripe
      const response = await paymentService.createStripeCheckoutSession(
        allItems,
        tableId || '',
        restaurantId || ''
      );
      // Redirect to Stripe Checkout
      if (response && response.url) {
        window.location.href = response.url;
      } else {
        throw new Error('Failed to create checkout session');
      }
    } catch (error) {
      console.error('Payment error:', error);
      toast.error('Payment failed. Please try again.');
      setIsPaying(false);
    }
  };
  if (paid) {
    return (
      <div className="min-h-screen bg-[#16141F] text-white">
        {/* Use the same TableHeader as the menu page */}
        <TableHeader 
          venueName={restaurantName || 'Screen 3'}
          className="bg-[#16141F] text-white"
        />
        <div className="px-4 py-8 mt-16 text-center">
          <div className="w-16 h-16 bg-green-900 rounded-full mx-auto flex items-center justify-center mb-4">
            <Check className="h-8 w-8 text-green-400" />
          </div>
          <h1 className="text-2xl font-semibold mb-2">Payment Complete!</h1>
          <p className="text-gray-400 mb-8">
            Thank you for dining with us. We hope to see you again soon!
          </p>
          <Button
            className="bg-purple-600 hover:bg-purple-700 text-white"
            onClick={() => window.location.href = '/'}
          >
            Return to Menu
          </Button>
        </div>
      </div>
    );
  }
  return (
    <div className="min-h-screen bg-[#16141F] text-white">
      {/* Use the same TableHeader as the menu page */}
      <TableHeader 
        venueName={restaurantName || 'Screen 3'}
        className="bg-[#16141F] text-white"
      />
      <div className="px-4 py-4 mt-16">
        <h1 className="text-2xl font-semibold mb-6">Your Bill</h1>
        <div className="bg-[#262837] border border-[#2D303E] rounded-lg p-4 mb-6">
          <div className="text-center mb-4">
            <h2 className="font-bold text-xl">{restaurantName || 'Screen 3'}</h2>
            <p className="text-sm text-gray-400">Table {tableNumber}</p>
            <p className="text-sm text-gray-400">{format(new Date(), 'MMM d, yyyy h:mm a')}</p>
          </div>
          <div className="border-t border-b border-[#2D303E] py-4 my-4">
            {orders.map((order, index) => (
              <div key={index} className="mb-4">
                <h3 className="font-medium text-sm mb-2">Order #{order.id && order.id.includes('-') ? order.id.split('-')[1] : (order.orderNumber || order.id?.substring(0,6) || 'New')}</h3>
                {order.items.map((item, itemIndex) => (
                  <div key={itemIndex} className="flex justify-between text-sm py-1">
                    <span>{item.quantity} x {item.name}</span>
                    <span>${(item.price * item.quantity).toFixed(2)}</span>
                  </div>
                ))}
              </div>
            ))}
          </div>
          <div className="space-y-2 mb-4">
            <div className="flex justify-between">
              <span>Subtotal</span>
              <span>${subtotal.toFixed(2)}</span>
            </div>
            <div className="flex justify-between">
              <span>Tax (10%)</span>
              <span>${tax.toFixed(2)}</span>
            </div>
            <div className="flex justify-between">
              <span>Service Charge (10%)</span>
              <span>${serviceCharge.toFixed(2)}</span>
            </div>
            <div className="flex justify-between font-bold text-lg pt-2 border-t border-[#2D303E]">
              <span>Total</span>
              <span>${total.toFixed(2)}</span>
            </div>
          </div>
        </div>
        <div className="mb-8">
          <h2 className="font-medium mb-4">Select Payment Method</h2>
          <div className="grid grid-cols-3 gap-3">
            <Button
              variant={paymentMethod === 'card' ? 'default' : 'outline'}
              className={`h-20 flex flex-col ${
                paymentMethod === 'card' ? 'bg-purple-600 hover:bg-purple-700 text-white' : 'border-[#2D303E] text-white'
              }`}
              onClick={() => setPaymentMethod('card')}
            >
              <CreditCard className="h-6 w-6 mb-2" />
              <span>Card</span>
            </Button>
            <Button
              variant={paymentMethod === 'cash' ? 'default' : 'outline'}
              className={`h-20 flex flex-col ${
                paymentMethod === 'cash' ? 'bg-purple-600 hover:bg-purple-700 text-white' : 'border-[#2D303E] text-white'
              }`}
              onClick={() => setPaymentMethod('cash')}
            >
              <Banknote className="h-6 w-6 mb-2" />
              <span>Cash</span>
            </Button>
            <Button
              variant={paymentMethod === 'bank' ? 'default' : 'outline'}
              className={`h-20 flex flex-col ${
                paymentMethod === 'bank' ? 'bg-purple-600 hover:bg-purple-700 text-white' : 'border-[#2D303E] text-white'
              }`}
              onClick={() => setPaymentMethod('bank')}
            >
              <Landmark className="h-6 w-6 mb-2" />
              <span>Bank</span>
            </Button>
          </div>
        </div>
        <Button
          className="w-full h-12 bg-purple-600 hover:bg-purple-700 text-white"
          onClick={handlePayment}
          disabled={isPaying}
        >
          {isPaying ? (
            <>
              <span className="animate-spin mr-2">â­•</span> Processing...
            </>
          ) : (
            <>Pay ${total.toFixed(2)}</>
          )}
        </Button>
      </div>
    </div>
  );
};
export default Bill;
</file>

<file path="src/pages/CallWaiter.tsx">
import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Label } from '@/components/ui/label';
import { Bell, Check } from 'lucide-react';
import { toast } from 'sonner';
import { useTableInfo } from '@/context/TableContext';
import TableHeader from '@/components/TableHeader';
const CallWaiter: React.FC = () => {
  const [selectedReason, setSelectedReason] = useState('assistance');
  const [additionalInfo, setAdditionalInfo] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submitted, setSubmitted] = useState(false);
  const { tableNumber, restaurantName } = useTableInfo();
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    // Simulate API call
    setTimeout(() => {
      setIsSubmitting(false);
      setSubmitted(true);
      toast.success('Your request has been sent to the staff');
      // Reset after 10 seconds
      setTimeout(() => {
        setSubmitted(false);
        setSelectedReason('assistance');
        setAdditionalInfo('');
      }, 10000);
    }, 1500);
  };
  return (
    <div className="min-h-screen bg-[#16141F] text-white">
      {/* Use the same TableHeader as the menu page */}
      <TableHeader 
        venueName={restaurantName || 'Screen 3'}
        className="bg-[#16141F] text-white"
      />
      <div className="px-4 py-8 mt-16">
      <h1 className="text-2xl font-semibold mb-6">Call Waiter</h1>
      {submitted ? (
        <div className="text-center py-8">
          <div className="w-16 h-16 bg-purple-600/20 rounded-full mx-auto flex items-center justify-center mb-4">
            <Check className="h-8 w-8 text-purple-600" />
          </div>
          <h2 className="text-xl font-medium mb-2">Request Sent!</h2>
          <p className="text-gray-400 mb-4">
            A waiter will come to table {tableNumber} shortly.
          </p>
          <Button
            className="bg-purple-600 hover:bg-purple-700 text-white"
            onClick={() => setSubmitted(false)}
          >
            Send Another Request
          </Button>
        </div>
      ) : (
        <form onSubmit={handleSubmit}>
          <div className="bg-[#262837] border border-[#2D303E] rounded-lg p-4 mb-6">
            <h2 className="font-medium mb-4">Select a reason</h2>
            <RadioGroup 
              defaultValue="assistance" 
              value={selectedReason}
              onValueChange={setSelectedReason}
            >
              <div className="flex items-center space-x-2 mb-3">
                <RadioGroupItem value="assistance" id="assistance" className="text-purple-600 border-purple-600" />
                <Label htmlFor="assistance" className="text-white">Need Assistance</Label>
              </div>
              <div className="flex items-center space-x-2 mb-3">
                <RadioGroupItem value="refill" id="refill" className="text-purple-600 border-purple-600" />
                <Label htmlFor="refill" className="text-white">Need a Refill</Label>
              </div>
              <div className="flex items-center space-x-2 mb-3">
                <RadioGroupItem value="utensils" id="utensils" className="text-purple-600 border-purple-600" />
                <Label htmlFor="utensils" className="text-white">Need Utensils</Label>
              </div>
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="other" id="other" className="text-purple-600 border-purple-600" />
                <Label htmlFor="other" className="text-white">Other</Label>
              </div>
            </RadioGroup>
          </div>
          <div className="mb-6">
            <label htmlFor="additionalInfo" className="block font-medium mb-2">
              Additional Information (Optional)
            </label>
            <Textarea 
              id="additionalInfo" 
              placeholder="Provide more details about your request..."
              value={additionalInfo}
              onChange={(e) => setAdditionalInfo(e.target.value)}
              rows={4}
              className="border-[#2D303E] bg-[#262837] text-white focus-visible:ring-purple-600"
            />
          </div>
          <Button 
            type="submit"
            className="w-full h-12 bg-purple-600 hover:bg-purple-700 text-white"
            disabled={isSubmitting}
          >
            {isSubmitting ? (
              <span className="animate-spin mr-2">â­•</span>
            ) : (
              <Bell className="mr-2 h-4 w-4" />
            )}
            {isSubmitting ? 'Sending...' : 'Call Waiter'}
          </Button>
        </form>
      )}
    </div>
    </div>
  );
};
export default CallWaiter;
</file>

<file path="src/pages/Index.tsx">
import React, { useState, useEffect } from 'react';
import { useQuery } from '@tanstack/react-query';
import axios from 'axios';
import { motion, AnimatePresence } from 'framer-motion';
import { useNavigate, useLocation } from 'react-router-dom';
import { Search } from 'lucide-react';
import { Input } from '@/components/ui/input';
import TableHeader from '@/components/TableHeader';
import CategoryGrid from '@/components/CategoryGrid';
import SplashScreen from '@/components/SplashScreen';
// import HeroSlider from '@/components/home/HeroSlider';
import { api } from '@/services/api';
import { Category as LocalCategory } from '@/types';
import { Category, Menu, TableVerification } from '@/types/menu';
import { verifyTableStatus } from '@/api/menuService';
import { API_BASE_URL } from '@/constants';
// Interface for formatted category display
interface FormattedCategory {
  id: string;
  _id?: string;
  name: string;
  image?: string;
  subCategories: string[];
  subCategoryCount: number;
  totalSubSubCategoryCount: number;
  isActive?: boolean;
}
const Index: React.FC = () => {
  const [showSplash, setShowSplash] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  const [tableError, setTableError] = useState<string | null>(null);
  const navigate = useNavigate();
  const location = useLocation();
  // Extract table ID from query parameters instead of URL path
  const queryParams = new URLSearchParams(location.search);
  const tableId = queryParams.get('table');
  // Redirect to scan page if no table ID is present
  useEffect(() => {
    if (!tableId) {
      navigate('/scan');
    }
  }, [tableId, navigate]);
  // Fetch table data
  const { data: tableData, isLoading: isTableLoading } = useQuery({
    queryKey: ['table', tableId],
    queryFn: async () => {
      if (!tableId) throw new Error('No table ID available');
      try {
        // Use the existing verifyTableStatus function from menuService
        const tableStatus = await verifyTableStatus(tableId);
        if (!tableStatus.exists) {
          const error = new Error('Table not found');
          setTableError(error.message);
          throw error;
        }
        return {
          venue: tableStatus.venue,
          table: tableStatus.table
        };
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : 'Failed to verify table';
        setTableError(errorMsg);
        console.error('Table verification failed:', error);
        throw error;
      }
    },
    enabled: !!tableId,
    retry: 1
  });
  // Log table data for debugging
  useEffect(() => {
    if (!isTableLoading && tableData) {
      console.log('Table data:', tableData);
    }
  }, [tableId, tableData, isTableLoading]);
  // Fetch menu with populated categories
  const { data: menuData, isLoading: isMenuLoading } = useQuery({
    queryKey: ['menu', tableData?.venue?._id],
    queryFn: async () => {
      if (!tableData?.venue?._id) throw new Error('No venue ID available');
      const response = await axios.get<Menu[]>(
        `${API_BASE_URL}/menus?venueId=${tableData.venue._id}&populate=true`
      );
      if (!response.data || response.data.length === 0) {
        throw new Error('No menu found for this venue');
      }
      return response.data[0]; // Assuming one menu per venue
    },
    enabled: !!tableData?.venue?._id,
    retry: 1,
  });
  // Fetch default categories if no table ID
  const { data: defaultCategories = [] } = useQuery({
    queryKey: ['categories'],
    queryFn: async () => {
      const localCategories = await api.getCategories();
      // Convert local categories to match the API format
      return localCategories.map((cat: LocalCategory): Category => ({
        _id: cat.id,
        name: cat.name,
        image: cat.image,
        subCategories: cat.subCategories || [],
      }));
    },
    enabled: !tableId,
  });
  // Format categories with proper structure and counts
  const formattedCategories: FormattedCategory[] = React.useMemo(() => {
    if (tableId && menuData?.categories) {
      return menuData.categories.map(category => {
        // Find subcategories for this category
        const categorySubcategories = menuData.subCategories?.filter(subCat => {
          return (
            category._id === subCat.categoryId || 
            (Array.isArray(category.subCategories) && 
             category.subCategories.includes(subCat._id))
          );
        }) || [];
        // Count subsubcategories
        let totalSubSubCategoryCount = 0;
        categorySubcategories.forEach(subCat => {
          if (subCat.subSubCategories && Array.isArray(subCat.subSubCategories)) {
            totalSubSubCategoryCount += subCat.subSubCategories.length;
          }
        });
        return {
          id: category._id,
          _id: category._id,
          name: category.name,
          // Use real category image from API or placeholder
          image: category.image || `/categories/${category.name.toLowerCase().replace(/\s+/g, '-')}.jpg`,
          // Include subcategory IDs
          subCategories: categorySubcategories.map(sub => sub._id),
          subCategoryCount: categorySubcategories.length,
          totalSubSubCategoryCount: totalSubSubCategoryCount,
          isActive: category.isActive
        };
      });
    } else if (!tableId && Array.isArray(defaultCategories) && defaultCategories.length > 0) {
      // Handle default categories when no table ID is present
      return defaultCategories.map((category: Category) => ({
        id: category._id,
        _id: category._id,
        name: category.name,
        image: category.image || `/categories/${category.name.toLowerCase().replace(/\s+/g, '-')}.jpg`,
        subCategories: [],
        subCategoryCount: 0,
        totalSubSubCategoryCount: 0,
        isActive: true
      }));
    }
    return [];
  }, [menuData, defaultCategories, tableId]);
  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    if (searchQuery.trim()) {
      navigate(`/menu?search=${encodeURIComponent(searchQuery)}`);
    }
  };
  // Handle splash screen
  useEffect(() => {
    const hasSeen = sessionStorage.getItem('hasSeenSplash');
    if (hasSeen) {
      setShowSplash(false);
    } else {
      setTimeout(() => {
        sessionStorage.setItem('hasSeenSplash', 'true');
        setShowSplash(false);
      }, 3000);
    }
  }, []);
  if (tableError) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center p-4">
          <h2 className="text-xl font-bold text-red-600 mb-2">Error</h2>
          <p className="text-gray-600">{tableError}</p>
          <button
            onClick={() => navigate('/')}
            className="mt-4 px-4 py-2 bg-primary text-white rounded-md hover:bg-primary/90"
          >
            Return to Home
          </button>
        </div>
      </div>
    );
  }
  return (
    <>
      <AnimatePresence>
        {showSplash ? (
          <SplashScreen onComplete={() => setShowSplash(false)} />
        ) : (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="min-h-screen bg-[#16141F] text-white"
          >
            {/* Table Header with venue and table information */}
            <TableHeader 
              venueName={tableData?.venue?.name}
              tableName={tableData?.table?.number}
            />
            <main className="container mx-auto pt-16 pb-24">
              {/* Hero Slider - commented out as requested */}
              {/* !tableId && (
                <section className="mb-4">
                  <HeroSlider />
                </section>
              ) */}
              {/* Search Bar */}
              <section className="px-4 mb-6">
                <form onSubmit={handleSearch} className="relative">
                  <Input
                    type="text"
                    placeholder={`Search in ${tableData?.venue?.name || 'Menu'}`}
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    className="pl-10 py-5 h-10 rounded-full"
                  />
                  <button
                    type="submit"
                    className="absolute inset-y-0 left-0 pl-3 flex items-center"
                  >
                    <Search className="h-5 w-5 text-muted-foreground" />
                  </button>
                </form>
              </section>
              {/* Category Section */}
              <section>
                <div className="px-4 mb-4">
                  <h2 className="text-xl font-bold">Categories</h2>
                  <p className="text-sm text-muted-foreground">
                    Browse all food and drink categories
                  </p>
                </div>
                {(isTableLoading || isMenuLoading) ? (
                  <div className="p-4 text-center">
                    <div className="animate-pulse">
                      <div className="h-8 bg-muted rounded w-1/2 mx-auto mb-4"></div>
                      <div className="h-8 bg-muted rounded w-1/3 mx-auto"></div>
                    </div>
                  </div>
                ) : (
                  <CategoryGrid categories={formattedCategories} />
                )}
              </section>
            </main>
          </motion.div>
        )}
      </AnimatePresence>
    </>
  );
};
export default Index;
</file>

<file path="src/pages/Layout.tsx">
import React, { useEffect, useState } from 'react';
import { Outlet, useLocation, Link } from 'react-router-dom';
import { TableHeader } from '@/components/TableHeader';
import { BottomNav } from '@/components/BottomNav';
import { useTableInfo } from '@/context/TableContext';
import { useTheme } from 'next-themes';
import { ScanLine, ShoppingCart, Wand2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { useCart } from '@/context/CartContext';
import CartDrawer from '@/components/CartDrawer';
import AIChatDrawer from '@/components/AIChatDrawer';
const Layout: React.FC = () => {
  const { tableNumber, setTableInfo } = useTableInfo();
  const location = useLocation();
  const { theme, setTheme } = useTheme();
  const { cartItems } = useCart();
  const [isCartOpen, setIsCartOpen] = useState(false);
  useEffect(() => {
    // Extract table number from URL query parameters
    const queryParams = new URLSearchParams(location.search);
    const tableParam = queryParams.get('table');
    if (tableParam && tableParam !== tableNumber) {
      // If table parameter exists in URL and is different from current, use it
      setTableInfo(prev => ({
        ...prev,
        tableNumber: tableParam
      }));
    } else if (!tableNumber) {
      // Check if we need to generate a random table number
      const storedTable = localStorage.getItem('tableInfo');
      if (!storedTable || !JSON.parse(storedTable).tableNumber) {
        const randomTable = generateRandomTableNumber();
        setTableInfo(prev => ({
          ...prev,
          tableNumber: randomTable
        }));
      }
    }
  }, [location.search, tableNumber]);
  // Generate a random alphanumeric table number of length 4
  const generateRandomTableNumber = (): string => {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let result = '';
    for (let i = 0; i < 4; i++) {
      result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
  };
  // Don't show header on scan page
  const isScanPage = location.pathname === '/scan';
  return (
    <div className="flex flex-col min-h-screen" style={{ backgroundColor: '#16141F', color: 'white' }}>
      <div className="relative">
        {!isScanPage && <TableHeader />}
        {/* Scan button removed as per user request */}
      </div>
      {/* Floating cart icon */}
      {cartItems && cartItems.length > 0 && (
        <div className="fixed bottom-20 right-4 z-50">
          <Button 
            size="icon" 
            className="h-12 w-12 rounded-full bg-purple-600 hover:bg-purple-700 shadow-lg"
            onClick={() => setIsCartOpen(true)}
          >
            <ShoppingCart className="h-6 w-6 text-white" />
            {cartItems.length > 0 && (
              <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs w-5 h-5 flex items-center justify-center rounded-full">
                {cartItems.length}
              </span>
            )}
          </Button>
        </div>
      )}
      {/* Cart Drawer */}
      <CartDrawer isOpen={isCartOpen} onClose={() => setIsCartOpen(false)} />
      <AIChatDrawer />
      {/* Set main content background to dark color and ensure proper text color */}
      <main className="flex-grow pb-20" style={{ backgroundColor: '#16141F' }}> 
        <Outlet />
      </main>
      <BottomNav />
    </div>
  );
};
export default Layout;
</file>

<file path="src/pages/LoginSuccess.tsx">
import React, { useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useTableInfo } from '@/context/TableContext';
import { toast } from 'sonner';
const LoginSuccess: React.FC = () => {
  const navigate = useNavigate();
  const { tableId } = useTableInfo();
  useEffect(() => {
    // Check for all possible table ID sources
    const getEffectiveTableId = () => {
      // Check all possible sources of table ID
      const currentTableId = localStorage.getItem('currentTableId');
      const simpleTableId = localStorage.getItem('tableId');
      const tableIdFromSession = sessionStorage.getItem('tableId');
      const urlParams = new URLSearchParams(window.location.search);
      const tableIdFromUrl = urlParams.get('table');
      // Use the first valid table ID found
      return tableId || currentTableId || simpleTableId || tableIdFromSession || tableIdFromUrl || '';
    };
    const effectiveTableId = getEffectiveTableId();
    console.log('Effective table ID for redirection:', effectiveTableId);
    // Check if there's a pending cart to recover
    const pendingCartJson = localStorage.getItem('pendingCart');
    // Redirect with a slight delay for better UX
    const timer = setTimeout(() => {
      if (pendingCartJson) {
        try {
          // Parse the pending cart data
          const pendingCart = JSON.parse(pendingCartJson);
          // Clear the pending cart from localStorage
          localStorage.removeItem('pendingCart');
          // Store the table ID in localStorage to ensure it's available
          if (effectiveTableId) {
            localStorage.setItem('currentTableId', effectiveTableId);
          }
          // Redirect to menu page instead of cart
          if (effectiveTableId) {
            navigate(`/?table=${effectiveTableId}`);
          } else {
            navigate('/');
          }
          // Display message about successful login
          toast.success('Login successful! Your cart has been recovered.');
          console.log('Redirecting to menu page after login');
        } catch (error) {
          console.error('Error parsing pending cart:', error);
          if (effectiveTableId) {
            navigate(`/?table=${effectiveTableId}`);
          } else {
            navigate('/');
          }
        }
      } else {
        // No pending cart, redirect to menu with table ID
        if (effectiveTableId) {
          console.log(`Table ID found: ${effectiveTableId}, redirecting to menu`);
          navigate(`/?table=${effectiveTableId}`);
        } else {
          // No table ID found, redirect to home page
          console.log('No table ID found, redirecting to home page');
          navigate('/');
        }
      }
    }, 1000);
    // Clean up the timer
    return () => clearTimeout(timer);
  }, [navigate, tableId]);
  return (
    <div className="min-h-screen bg-[#16141F] flex items-center justify-center">
      <div className="text-center">
        <div className="w-24 h-24 mx-auto mb-4">
          {/* Success checkmark SVG animation */}
          <svg 
            className="w-full h-full" 
            viewBox="0 0 100 100"
            xmlns="http://www.w3.org/2000/svg"
          >
            <circle 
              cx="50" 
              cy="50" 
              r="45" 
              fill="none" 
              stroke="#a855f7" 
              strokeWidth="7.5"
              strokeLinecap="round"
              strokeDasharray="283"
              strokeDashoffset="283"
              style={{
                animation: "circle-draw 0.6s ease-in-out forwards"
              }}
            />
            <path 
              d="M25,50 L45,70 L75,35" 
              fill="none" 
              stroke="#a855f7" 
              strokeWidth="7.5"
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeDasharray="100"
              strokeDashoffset="100"
              style={{
                animation: "checkmark-draw 0.3s ease-in-out forwards 0.6s"
              }}
            />
          </svg>
        </div>
        <h1 className="text-2xl font-bold text-white mb-2">Login Successful!</h1>
        <p className="text-purple-400">Redirecting to menu...</p>
      </div>
      {/* CSS Animation Keyframes */}
      <style>{`
        @keyframes circle-draw {
          0% {
            stroke-dashoffset: 283;
          }
          100% {
            stroke-dashoffset: 0;
          }
        }
        @keyframes checkmark-draw {
          0% {
            stroke-dashoffset: 100;
          }
          100% {
            stroke-dashoffset: 0;
          }
        }
      `}</style>
    </div>
  );
};
export default LoginSuccess;
</file>

<file path="src/pages/OrderConfirmation.tsx">
import React, { useState, useEffect, useCallback } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import { useOrders } from '@/context/OrdersContext';
import { useAuth } from '@/context/AuthContext';
import { Button } from '@/components/ui/button';
import { CheckCircle, Clock, Loader2, ShoppingBag, AlertTriangle, ChevronLeft } from 'lucide-react';
import TableHeader from '@/components/TableHeader';
import { useTableInfo } from '@/context/TableContext';
import { getOrderById } from '@/api/orderService';
import { formatDistanceToNow } from 'date-fns';
import { toast } from 'sonner';
import { Badge } from '@/components/ui/badge';
// Status badge component
const StatusBadge: React.FC<{ status: string }> = ({ status }) => {
  switch (status?.toLowerCase()) {
    case 'pending':
      return <Badge className="bg-amber-500 hover:bg-amber-600">Pending</Badge>;
    case 'processing':
    case 'preparing':
      return <Badge className="bg-purple-600 hover:bg-purple-700">Preparing</Badge>;
    case 'ready':
      return <Badge className="bg-blue-600 hover:bg-blue-700">Ready</Badge>;
    case 'delivered':
      return <Badge className="bg-green-600 hover:bg-green-700">Delivered</Badge>;
    case 'completed':
      return <Badge className="bg-green-600 hover:bg-green-700">Completed</Badge>;
    case 'cancelled':
      return <Badge className="bg-destructive hover:bg-destructive/90">Cancelled</Badge>;
    default:
      return <Badge className="bg-gray-600 hover:bg-gray-700">{status}</Badge>;
  }
};
// Payment status badge component
const PaymentStatusBadge: React.FC<{ status: string }> = ({ status }) => {
  switch (status?.toLowerCase()) {
    case 'paid':
      return <Badge className="bg-green-600 hover:bg-green-700">Paid</Badge>;
    case 'pending':
      return <Badge className="bg-amber-500 hover:bg-amber-600">Payment Pending</Badge>;
    case 'failed':
      return <Badge className="bg-destructive hover:bg-destructive/90">Payment Failed</Badge>;
    case 'refunded':
      return <Badge className="bg-blue-600 hover:bg-blue-700">Refunded</Badge>;
    default:
      return null;
  }
};
const OrderConfirmation: React.FC = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const { addOrder } = useOrders();
  const { isAuthenticated, token } = useAuth();
  const { restaurantName, tableId } = useTableInfo();
  const [order, setOrder] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const orderId = location.state?.orderId;
  const [pollingActive, setPollingActive] = useState(true);
  // Function to get token from all possible sources (cookies, localStorage)
  const getTokenFromAllSources = (): string | null => {
    try {
      // First check cookies
      const cookies = document.cookie.split(';');
      const tokenCookie = cookies.find(cookie => 
        cookie.trim().startsWith('auth_token=') || 
        cookie.trim().startsWith('access_token=')
      );
      if (tokenCookie) {
        const cookieToken = tokenCookie.split('=')[1].trim();
        return cookieToken;
      }
      // Then check localStorage
      const localToken = localStorage.getItem('auth_token');
      if (localToken) {
        return localToken;
      }
    } catch (error) {
      console.error('Error getting token in OrderConfirmation:', error);
    }
    return null;
  };
  const fetchOrder = useCallback(async () => {
    if (!orderId) {
      setError('Order ID is missing. Please check your orders in the My Orders page.');
      setLoading(false);
      return null;
    }
    try {
      setLoading(true);
      // First check if we have a token either from context or from cookies/localStorage
      let authToken = token;
      // If no token in context, check all possible sources (cookies, localStorage)
      if (!authToken) {
        authToken = getTokenFromAllSources();
      }
      // Use the API service to get the latest order data if we have a token
      if (authToken) {
        const orderData = await getOrderById(orderId, authToken);
        if (!orderData) {
          setError('Order not found. It may have been cancelled or deleted.');
          setLoading(false);
          return null;
        }
        setOrder(orderData);
        // Add or update the order in the context
        addOrder({
          id: orderData._id,
          items: orderData.items.map((item: any) => ({
            id: item._id || item.menuItem,
            menuItemId: item.menuItem,
            name: item.name,
            price: item.price,
            quantity: item.quantity,
            image: '', // Image may not be available from API
            modifiers: item.modifiers || []
          })),
          subtotal: orderData.subtotal,
          tax: orderData.tax,
          total: orderData.total,
          status: orderData.status.toLowerCase(),
          timestamp: new Date(orderData.createdAt),
          tableNumber: tableId || orderData.tableId
        });
        // Check if order is in final state
        const isFinalState = ['completed', 'delivered', 'cancelled'].includes(
          orderData.status.toLowerCase()
        );
        if (isFinalState) {
          setPollingActive(false);
        }
        return isFinalState;
      } else {
        // If we couldn't find a token anywhere, redirect to login
        navigate('/login', { state: { returnUrl: `/order-confirmation/${orderId}` } });
        return true; // Stop polling
      }
    } catch (error) {
      console.error('Failed to fetch order:', error);
      setError('Failed to load order details. Please try again.');
      return false;
    } finally {
      setLoading(false);
    }
  }, [orderId, token, addOrder, navigate, tableId]);
  // Only fetch order data once on component mount
  useEffect(() => {
    // Create reference to track component mounted state
    let isMounted = true;
    const loadOrderOnce = async () => {
      // Check if we need to attempt auth refresh before starting
      if (!token && getTokenFromAllSources()) {
        console.log('Found token in cookies but not in context');
      }
      // Only make one API call to get initial order data
      await fetchOrder();
      // After getting order, check if polling should continue based on order status
      if (isMounted && order && ['completed', 'delivered', 'cancelled'].includes(order.status?.toLowerCase())) {
        setPollingActive(false);
      }
    };
    // Only run initial fetch if we have an order ID
    if (orderId) {
      loadOrderOnce();
    } else {
      setError('Order ID is missing. Please check your orders in the My Orders page.');
      setLoading(false);
    }
    return () => {
      isMounted = false;
    };
  }, [orderId]); // Only depend on orderId to prevent re-fetching
  // Set up controlled polling with a fixed refresh rate
  useEffect(() => {
    // Don't set up polling if it's disabled or no order ID
    if (!pollingActive || !orderId) return;
    let isMounted = true;
    // Create polling interval - refresh every 60 seconds (reduced from 30s)
    const pollInterval = setInterval(async () => {
      if (isMounted) {
        // Get latest order status
        const isFinalState = await fetchOrder();
        if (isFinalState) {
          clearInterval(pollInterval);
        }
      }
    }, 60000); // 60 seconds
    return () => {
      isMounted = false;
      clearInterval(pollInterval);
    };
  }, [fetchOrder, orderId, pollingActive]);
  // Helper functions for order display
  const getOrderStatusTitle = (status: string): string => {
    switch (status?.toLowerCase()) {
      case 'completed':
      case 'delivered':
        return 'Order Complete!';
      case 'cancelled':
        return 'Order Cancelled';
      case 'ready':
        return 'Order Ready!';
      case 'processing':
      case 'preparing':
        return 'Order is Being Prepared';
      case 'pending':
        return 'Order Received';
      default:
        return 'Order Status';
    }
  };
  const getOrderStatusDescription = (status: string): string => {
    switch (status?.toLowerCase()) {
      case 'completed':
      case 'delivered':
        return 'Your order has been delivered. Enjoy your meal!';
      case 'cancelled':
        return 'This order has been cancelled.';
      case 'ready':
        return 'Your order is ready for pickup or delivery.';
      case 'processing':
      case 'preparing':
        return 'Your order is being prepared in the kitchen.';
      case 'pending':
        return 'Your order is being processed. Check back for updates.';
      default:
        return 'Check back for updates on your order status.';
    }
  };
  if (loading) {
    return (
      <div className="min-h-screen bg-[#16141F] text-white">
        <TableHeader 
          venueName={restaurantName || 'Restaurant'}
          className="bg-[#16141F] text-white"
        />
        <div className="flex justify-center items-center h-[80vh]">
          <Loader2 className="h-8 w-8 animate-spin text-purple-500" />
        </div>
      </div>
    );
  }
  if (error) {
    return (
      <div className="min-h-screen bg-[#16141F] text-white">
        <TableHeader 
          venueName={restaurantName || 'Restaurant'}
          className="bg-[#16141F] text-white"
        />
        <div className="container max-w-2xl mx-auto px-4 py-8 mt-16">
          <div className="bg-destructive/20 border border-destructive text-destructive p-4 rounded-xl mb-6">
            <div className="flex items-center">
              <AlertTriangle className="h-5 w-5 mr-2" />
              <p>{error}</p>
            </div>
          </div>
          <div className="flex justify-center mt-6">
            <Button
              className="bg-purple-600 hover:bg-purple-700 text-white"
              onClick={() => navigate('/')}
            >
              Return to Menu
            </Button>
          </div>
        </div>
      </div>
    );
  }
  if (!order) return null;
  // Format relative time
  const orderTime = formatDistanceToNow(
    new Date(order.createdAt || new Date()),
    { addSuffix: true }
  );
  return (
    <div className="min-h-screen bg-[#16141F] text-white animate-fade-in pb-20">
      <TableHeader 
        venueName={restaurantName || 'Restaurant'}
        className="bg-[#16141F] text-white"
      />
      <div className="container max-w-2xl mx-auto px-4 py-8 mt-16 animate-fade-in">
        <div className="relative mb-6">
          <Button 
            variant="outline" 
            className="absolute -top-5 -left-2 border-purple-500 text-purple-400 hover:bg-purple-500/10" 
            onClick={() => navigate(-1)}
          >
            <ChevronLeft className="mr-1 h-4 w-4" />
            Back
          </Button>
        </div>
        <div className="flex flex-col items-center text-center mb-6">
          <div className="w-20 h-20 rounded-full bg-purple-600/20 flex items-center justify-center mb-4">
            {order.status?.toLowerCase() === 'completed' || order.status?.toLowerCase() === 'delivered' ? (
              <CheckCircle className="h-12 w-12 text-purple-500" />
            ) : order.status?.toLowerCase() === 'cancelled' ? (
              <AlertTriangle className="h-12 w-12 text-destructive" />
            ) : (
              <Clock className="h-12 w-12 text-purple-500" />
            )}
          </div>
          <h1 className="text-2xl font-bold mb-2 text-white">
            {getOrderStatusTitle(order.status || 'pending')}
          </h1>
          <p className="text-purple-300/80 mb-4">
            {getOrderStatusDescription(order.status || 'pending')}
          </p>
          <div className="flex items-center gap-2 text-sm mb-1">
            <span className="font-medium text-white">Order #</span>
            <span className="text-white">{order._id?.slice(-6) || 'Unknown'}</span>
            <span className="text-purple-400/70">â€¢</span>
            <span className="text-purple-400/70">
              {orderTime}
            </span>
          </div>
        </div>
        <div className="bg-[#1F1D2B] border border-purple-500/20 rounded-xl p-5 shadow-lg">
          <h2 className="text-lg font-semibold mb-4 text-white">Order Details</h2>
          <div className="space-y-4">
            {order.items && order.items.map((item: any, index: number) => (
              <div key={index} className="flex justify-between items-start">
                <div className="flex items-start">
                  <div className="w-6 h-6 bg-purple-600/20 rounded-full flex items-center justify-center mr-3 mt-0.5">
                    <ShoppingBag className="h-3 w-3 text-purple-500" />
                  </div>
                  <div>
                    <p className="font-medium text-white">{item.name}</p>
                    <p className="text-sm text-purple-300/80">Quantity: {item.quantity}</p>
                    <p className="text-xs text-purple-400/70 mt-1">
                      Order Status: <span className="text-purple-300">{order.status}</span>
                    </p>
                    {item.specialInstructions && (
                      <p className="text-sm text-purple-300/80 italic mt-1">
                        "{item.specialInstructions}"
                      </p>
                    )}
                    {item.modifiers && item.modifiers.length > 0 && (
                      <div className="text-sm text-purple-300/80 mt-1">
                        {item.modifiers.map((mod: any, idx: number) => (
                          <p key={idx}>â€¢ {mod.name}</p>
                        ))}
                      </div>
                    )}
                  </div>
                </div>
                <p className="font-medium text-white">${(item.price * item.quantity).toFixed(2)}</p>
              </div>
            ))}
          </div>
          <div className="border-t border-purple-500/10 my-4 pt-4">
            <div className="flex justify-between text-sm py-1">
              <span className="text-purple-300/80">Subtotal</span>
              <span className="text-white">${order.subtotal?.toFixed(2) || '0.00'}</span>
            </div>
            <div className="flex justify-between text-sm py-1">
              <span className="text-purple-300/80">Tax</span>
              <span className="text-white">${order.tax?.toFixed(2) || '0.00'}</span>
            </div>
            <div className="flex justify-between font-medium py-1">
              <span className="text-white">Total</span>
              <span className="text-white">${order.total?.toFixed(2) || '0.00'}</span>
            </div>
          </div>
          <div className="flex items-center text-purple-400 mt-4 bg-purple-600/10 p-3 rounded-md text-sm">
            <Clock className="h-4 w-4 mr-2 flex-shrink-0" />
            <span>Estimated Preparation Time: 15-20 minutes</span>
          </div>
        </div>
        <div className="flex justify-center w-full mt-6">
          <Button
            className="bg-purple-600 hover:bg-purple-700 text-white w-full max-w-xs"
            onClick={() => {
              // Check all possible sources of table ID
              const storedTableId = localStorage.getItem('currentTableId') || 
                                  localStorage.getItem('table_id') || 
                                  localStorage.getItem('tableId');
              if (storedTableId) {
                navigate(`/?table=${storedTableId}`);
              } else {
                navigate('/');
              }
            }}
          >
            Start New Order
          </Button>
        </div>
      </div>
    </div>
  );
};
export default OrderConfirmation;
</file>

<file path="src/pages/PaymentSuccess.tsx">
import { useEffect, useState } from 'react';
import { Link, useNavigate, useSearchParams } from 'react-router-dom';
import { useCart } from '@/context/CartContext';
import { useOrders } from '@/context/OrdersContext';
import { useTableInfo } from '@/context/TableContext';
import { checkPaymentStatus } from '@/api/paymentService';
import { CheckCircle, AlertCircle, Bug } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Spinner } from '@/components/ui/spinner';
import { useToast } from '@/components/ui/use-toast';
const PaymentSuccess = () => {
  const [searchParams] = useSearchParams();
  // Retrieve all URL parameters for debugging
  const allParams: Record<string, string> = {};
  searchParams.forEach((value, key) => {
    allParams[key] = value;
  });
  console.log('All URL parameters:', allParams);
  // Check for all possible session ID formats
  const sessionId = searchParams.get('sessionId') || 
                   searchParams.get('session_id') || 
                   searchParams.get('CHECKOUT_SESSION_ID') || 
                   searchParams.get('cs');
  // Check for all possible order ID formats
  const orderId = searchParams.get('orderId') || searchParams.get('order_id');
  const tableParam = searchParams.get('table');
  const navigate = useNavigate();
  const { clearCart } = useCart();
  const { addOrder } = useOrders();
  const { tableId, tableNumber, restaurantName, setTableInfo } = useTableInfo();
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const { toast } = useToast();
  // Debug info display
  const [debugInfo, setDebugInfo] = useState<any>({
    params: {
      ...allParams,
      sessionId,
      orderId,
      tableParam
    },
    attempts: 0,
    lastResponseData: null,
    verificationStatus: 'not_started'
  });
  const [showDebug, setShowDebug] = useState(true); // Show debug by default to help troubleshoot issues
  const [paymentData, setPaymentData] = useState<any>(null);
  const [attempts, setAttempts] = useState(0);
  const maxAttempts = 3;
  // Process and sanitize the table parameter
  useEffect(() => {
    if (tableParam) {
      // Decode the table parameter if it's URL encoded
      let tableId = tableParam;
      if (tableParam.includes('%')) {
        try {
          tableId = decodeURIComponent(tableParam);
        } catch (e) {
          console.error('Failed to decode table parameter:', e);
          tableId = tableParam;
        }
      }
      // Remove [object Object] if present
      if (tableId === '[object Object]') {
        console.error('Found [object Object] in table parameter');
        // Try to get table ID from localStorage instead
        const savedTableInfo = localStorage.getItem('tableInfo');
        if (savedTableInfo) {
          try {
            const parsedInfo = JSON.parse(savedTableInfo);
            if (parsedInfo.tableId && parsedInfo.tableId !== '[object Object]') {
              tableId = parsedInfo.tableId;
            }
          } catch (e) {
            console.error('Failed to parse tableInfo from localStorage:', e);
          }
        }
      }
      // Store table info regardless of source
      if (tableId && tableId !== '[object Object]') {
        console.log('Setting table info from URL parameter:', tableId);
        setTableInfo({
          tableId,
          tableNumber: tableId,
          restaurantName: 'Restaurant'
        });
      }
    }
  }, [tableParam, setTableInfo]);
  // Function to verify payment status
  const verifyPayment = async () => {
    try {
      // Stop if we've already tried too many times
      if (attempts >= maxAttempts) {
        console.log('Max attempts reached, stopping verification');
        setError('Payment verification failed after multiple attempts.');
        setLoading(false);
        return;
      }
      setAttempts(prev => prev + 1);
      // Get stripe session ID from URL or localStorage
      const stripeSessionFromUrl = sessionId;
      // Check for custom format (session_123456789) vs Stripe format (cs_test_...)
      const isCustomFormat = stripeSessionFromUrl && !stripeSessionFromUrl.startsWith('cs_');
      // Get effective session ID, prioritizing standard format
      let effectiveSessionId = '';
      if (stripeSessionFromUrl) {
        effectiveSessionId = stripeSessionFromUrl;
      } else {
        // Try to get from localStorage
        effectiveSessionId = localStorage.getItem('stripeSessionId') || '';
      }
      // Try to get order ID from different sources
      const effectiveOrderId = orderId || localStorage.getItem('currentPaymentOrderId') || '';
      console.log('Payment verification attempt', {
        effectiveSessionId, 
        effectiveOrderId, 
        stripeSessionFromUrl,
        isCustomFormat,
        attempt: attempts + 1 
      });
      // Use Stripe session ID from URL if available, otherwise use the effective session ID
      let sessionIdToUse = effectiveSessionId || stripeSessionFromUrl;
      // Special case: If we have orderId but no valid Stripe session ID
      if ((!sessionIdToUse || isCustomFormat) && effectiveOrderId) {
        console.log('Using order ID for verification instead of session ID');
        // Consider the payment successful if we have an order ID
        clearCart();
        setPaymentData({ orderId: effectiveOrderId, status: 'paid' });
        addOrder({ _id: effectiveOrderId } as any);
        setLoading(false);
        return;
      }
      // If no session ID from URL, try to get it from localStorage
      if (!sessionIdToUse) {
        // Try to get it from localStorage
        const storedSessionId = localStorage.getItem('stripeSessionId');
        const storedOrderId = localStorage.getItem('currentPaymentOrderId');
        console.log('No session ID in URL, checking localStorage:', { storedSessionId, storedOrderId });
        if (storedSessionId) {
          console.log('Found session ID in localStorage:', storedSessionId);
          sessionIdToUse = storedSessionId;
        } else if (storedOrderId) {
          // If we have an order ID but no session ID, we might still be able to verify the order directly
          console.log('No session ID, but found order ID in localStorage:', storedOrderId);
          setError('');
          setPaymentData({ orderId: storedOrderId, status: 'paid' });
          addOrder({ _id: storedOrderId } as any);
          setLoading(false);
          return;
        } else {
          setError('Missing session ID. Unable to verify payment.');
          setLoading(false);
          setDebugInfo(prev => ({ ...prev, verificationStatus: 'error' }));
          return;
        }
      }
      try {
        setLoading(true);
        // Use the sessionIdToUse we determined above
        const result = await checkPaymentStatus(sessionIdToUse);
        console.log('Payment status result:', result);
        // Update debug info with the response
        setDebugInfo(prev => ({
          ...prev,
          lastResponseData: result
        }));
        // SUCCESS PATH: Handle successful payment verification
        if (result && (result.status === 'paid' || result.paymentProviderStatus === 'paid')) {
          console.log('Payment verified as paid! Stopping verification process.');
          toast({
            title: "Payment Successful",
            description: "Your payment has been successfully processed."
          });
          setPaymentData(result);
          clearCart();
          // Add the order to the orders context if we have an order ID
          const orderIdToUse = result.orderId || effectiveOrderId;
          if (orderIdToUse) {
            console.log('Adding order to context:', orderIdToUse);
            addOrder({ _id: orderIdToUse } as any);
          }
          // Force stop loading state
          setLoading(false);
          setAttempts(maxAttempts); // Prevent further retries
          setDebugInfo(prev => ({ ...prev, verificationStatus: 'success' }));
          return;
        } 
        // PARTIAL SUCCESS: Payment received but might still be processing
        else if (result && result.status === 'pending' && result.paymentProviderStatus === 'processing') {
          console.log('Payment is processing - will retry');
          // Retry after delay
          setTimeout(() => {
            verifyPayment();
          }, 3000);
          return;
        }
        // FAILURE PATH: Payment verification failed
        else {
          throw new Error('Payment status verification failed. Please try again.');
        }
      } catch (error: any) {
        // Log error for debugging
        console.error('Error verifying payment:', error);
        // Check if we've reached max attempts
        if (attempts >= maxAttempts) {
          throw error; // This will be caught by the outer try/catch
        }
        // Retry after delay for network errors or when status is pending
        console.log(`Retry attempt ${attempts + 1} of ${maxAttempts} after 3 seconds...`);
        setTimeout(() => {
          verifyPayment();
        }, 3000);
      }
    } catch (error: any) {
      console.error('Payment verification failed after retries:', error);
      // Determine error message based on error type
      let errorMessage = 'Unable to verify payment status. Please check your order history.';
      if (error?.response?.status === 404) {
        errorMessage = 'Payment session not found. It may have expired or been cancelled.';
      } else if (error?.response?.status === 401 || error?.response?.status === 403) {
        errorMessage = 'Authorization error. Please log in again and try once more.';
      } else if (error.message) {
        errorMessage = error.message;
      }
      // Stop retrying after max attempts or for certain errors
      console.log('Stopping payment verification attempts due to error or max retries reached');
      setAttempts(maxAttempts); // Ensure no more retries
      setError(errorMessage);
      setLoading(false);
      toast({
        title: "Payment Verification Error",
        description: errorMessage,
        variant: "destructive"
      });
    }
  };
  // Run verification when component mounts
  useEffect(() => {
    verifyPayment();
  }, []);
  // Additional useEffect removed as it's now redundant
  return (
    <div className="flex flex-col items-center justify-center min-h-screen p-6 text-center dark:bg-slate-950">
      {/* Debug Panel - Show when debugging is needed */}
      {debugInfo && debugInfo.attempts > 0 && (
        <div className="fixed bottom-4 right-4 p-4 bg-black/80 text-white rounded-lg max-w-sm overflow-auto max-h-96 text-xs font-mono">
          <div className="flex items-center justify-between mb-2">
            <h4 className="font-semibold flex items-center">
              <Bug className="w-4 h-4 mr-1" /> Debug Info
            </h4>
            <button 
              onClick={() => setDebugInfo(null)} 
              className="text-gray-400 hover:text-white"
            >
              Close
            </button>
          </div>
          <div className="text-left">
            <p><span className="text-blue-400">Session ID:</span> {sessionId}</p>
            <p><span className="text-blue-400">Order ID:</span> {orderId}</p>
            <p><span className="text-blue-400">Status:</span> {debugInfo.verificationStatus}</p>
            <p><span className="text-blue-400">Attempts:</span> {debugInfo.attempts}</p>
            {debugInfo.lastResponseData && (
              <div className="mt-2">
                <p className="text-green-400">Last API Response:</p>
                <pre className="mt-1 text-[10px] whitespace-pre-wrap">
                  {JSON.stringify(debugInfo.lastResponseData, null, 2)}
                </pre>
              </div>
            )}
          </div>
        </div>
      )}
      {loading ? (
        <div className="flex flex-col items-center justify-center space-y-4">
          <Spinner size="lg" className="text-primary" />
          <h2 className="text-xl font-bold">Verifying Payment...</h2>
          <p className="text-gray-300 text-center">
            Please wait while we confirm your payment status.
          </p>
          <div className="text-sm text-gray-400">
            Attempt {attempts} of {maxAttempts}
          </div>
          {/* Always show some debugging info to help with troubleshooting */}
          <div className="mt-4 p-3 bg-gray-800 rounded-md text-xs text-left w-full">
            <p className="text-gray-400 mb-2">Verification Progress:</p>
            <div className="space-y-1">
              <p>â€¢ Session ID: {sessionId ? 'âœ… Found in URL' : 'âŒ Missing from URL'}</p>
              <p>â€¢ Order ID: {orderId ? 'âœ… Found in URL' : 'âŒ Missing from URL'}</p>
              <p>â€¢ Stored Session: {localStorage.getItem('stripeSessionId') ? 'âœ… Found in storage' : 'âŒ Missing from storage'}</p>
              <p>â€¢ Stored Order: {localStorage.getItem('currentPaymentOrderId') ? 'âœ… Found in storage' : 'âŒ Missing from storage'}</p>
            </div>
          </div>
        </div>
      ) : error ? (
        <div className="flex flex-col items-center space-y-4">
          <div className="w-20 h-20 rounded-full bg-red-100 flex items-center justify-center dark:bg-red-900/20">
            <AlertCircle className="w-10 h-10 text-red-600 dark:text-red-500" />
          </div>
          <h2 className="text-2xl font-semibold text-red-600 dark:text-red-500">Payment Verification Failed</h2>
          <p className="text-gray-700 dark:text-gray-300 max-w-md text-center">{error}</p>
          {/* Check localStorage and provide feedback */}
          {localStorage.getItem('stripeSessionId') && (
            <div className="p-3 bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-300 rounded-md text-sm">
              Your payment may have been processed successfully, but we couldn't verify it automatically.
            </div>
          )}
          {/* Recovery options */}
          <div className="mt-4 p-4 bg-amber-50 dark:bg-amber-950/40 border border-amber-200 dark:border-amber-800 rounded-lg max-w-md">
            <h3 className="font-medium text-amber-800 dark:text-amber-400 mb-2">What can you do now?</h3>
            <ul className="text-sm text-left list-disc pl-5 text-amber-700 dark:text-amber-300 space-y-1">
              <li>Return to the menu and try placing your order again</li>
              <li>Check your order history to see if your order was processed despite this error</li>
              <li>Contact restaurant staff if you need immediate assistance</li>
            </ul>
          </div>
          {/* Manual recovery button */}
          <Button 
            variant="outline"
            className="mt-2"
            onClick={() => {
              // Try to load orders page - the payment might have succeeded despite verification error
              navigate('/my-orders');
            }}
          >
            Check My Orders
          </Button>
          {/* Debug information for troubleshooting */}
          <div className="mt-6 p-3 bg-gray-100 dark:bg-gray-800 rounded-lg w-full max-w-md text-xs">
            <details>
              <summary className="font-medium text-gray-600 dark:text-gray-400 cursor-pointer">Debug Information</summary>
              <div className="mt-2 space-y-1 text-gray-500 dark:text-gray-400">
                <p>â€¢ Session ID: {sessionId || 'Not found in URL'}</p>
                <p>â€¢ Order ID: {orderId || 'Not found in URL'}</p>
                <p>â€¢ Stored Session: {localStorage.getItem('stripeSessionId') || 'None'}</p>
                <p>â€¢ Stored Order: {localStorage.getItem('currentPaymentOrderId') || 'None'}</p>
                <p>â€¢ URL Parameters: {JSON.stringify(allParams)}</p>
              </div>
            </details>
          </div>
          <div className="flex flex-col sm:flex-row gap-4 mt-6">
            <Button 
              onClick={() => navigate('/menu')}
              className="bg-primary hover:bg-primary/90 text-white font-medium px-6 py-2"
            >
              Return to Menu
            </Button>
            <Button 
              variant="outline" 
              className="border border-gray-300 dark:border-gray-700 hover:bg-gray-100 dark:hover:bg-gray-800"
              onClick={() => {
                window.location.reload();
              }}
            >
              Try Again
            </Button>
          </div>
        </div>
      ) : (
        <div className="flex flex-col items-center space-y-6">
          {/* Success Icon */}
          <div className="w-20 h-20 rounded-full bg-green-100 flex items-center justify-center dark:bg-green-900/20">
            <CheckCircle className="w-10 h-10 text-green-600 dark:text-green-500" />
          </div>
          {/* Success message */}
          <div>
            <h2 className="text-2xl font-semibold text-green-600 dark:text-green-500">Payment Successful!</h2>
            <p className="text-gray-600 dark:text-gray-400 mt-2">
              Your payment has been processed and your order is on its way.
            </p>
          </div>
          {/* Order details card */}
          <div className="mt-4 p-4 bg-white dark:bg-gray-800 rounded-lg shadow-md max-w-md w-full border border-gray-200 dark:border-gray-700">
            <h3 className="font-medium text-gray-900 dark:text-gray-100 mb-3">Order Details</h3>
            <div className="space-y-2 text-sm">
              {paymentData?.orderId && (
                <div className="flex justify-between">
                  <span className="text-gray-500 dark:text-gray-400">Order ID:</span>
                  <span className="font-medium text-gray-700 dark:text-gray-300">{paymentData.orderId}</span>
                </div>
              )}
              <div className="flex justify-between">
                <span className="text-gray-500 dark:text-gray-400">Status:</span>
                <span className="font-medium text-green-600 dark:text-green-500">Paid</span>
              </div>
              {paymentData?.stripeSession?.amountTotal && (
                <div className="flex justify-between">
                  <span className="text-gray-500 dark:text-gray-400">Amount:</span>
                  <span className="font-medium text-gray-700 dark:text-gray-300">
                    ${(paymentData.stripeSession.amountTotal / 100).toFixed(2)} {paymentData.stripeSession.currency?.toUpperCase()}
                  </span>
                </div>
              )}
              <div className="flex justify-between">
                <span className="text-gray-500 dark:text-gray-400">Table Number:</span>
                <span className="font-medium text-gray-700 dark:text-gray-300">{tableNumber || 'N/A'}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-gray-500 dark:text-gray-400">Restaurant:</span>
                <span className="font-medium text-gray-700 dark:text-gray-300">{restaurantName || 'InSeat'}</span>
              </div>
            </div>
          </div>
          {/* Order status card */}
          <div className="mt-2 p-4 bg-blue-50 dark:bg-blue-950/40 border border-blue-200 dark:border-blue-800 rounded-lg max-w-md w-full">
            <div className="flex items-center">
              <svg className="w-5 h-5 text-blue-600 dark:text-blue-400 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
              <h3 className="font-medium text-blue-800 dark:text-blue-400">What happens next?</h3>
            </div>
            <ol className="mt-2 ml-6 text-sm text-blue-700 dark:text-blue-300 list-decimal space-y-1">
              <li>Your order has been sent to the kitchen</li>
              <li>The kitchen staff will prepare your food</li>
              <li>A server will bring your order to your table</li>
            </ol>
          </div>
          <div className="flex flex-col sm:flex-row gap-4 mt-6">
            <Button 
              onClick={() => {
                // Get table ID from various possible sources
                const storedTableId = localStorage.getItem('currentTableId') || 
                                      localStorage.getItem('table_id') || 
                                      localStorage.getItem('tableId');
                // Use the table ID if available, otherwise navigate to default path
                if (storedTableId) {
                  navigate(`/?table=${storedTableId}`);
                } else {
                  navigate('/menu');
                }
              }}
              className="bg-primary hover:bg-primary/90 text-white font-medium px-6 py-2"
            >
              Continue Ordering
            </Button>
            <Button 
              variant="outline" 
              onClick={() => {
                // Get table ID from various possible sources
                const storedTableId = localStorage.getItem('currentTableId') || 
                                      localStorage.getItem('table_id') || 
                                      localStorage.getItem('tableId');
                // Ensure the order is properly formed before adding to context
                if (paymentData?.orderId) {
                  // Create a properly formed order object with all required fields
                  // Ensure every property used in MyOrders.tsx has a valid value
                  const completeOrder = {
                    // Required identifiers - guaranteed to exist
                    _id: paymentData.orderId,
                    id: paymentData.orderId,
                    orderNumber: paymentData.orderId.slice(-6),
                    // Status fields with default values to prevent undefined errors
                    status: 'completed', // Explicitly set status to avoid undefined
                    paymentStatus: 'paid',
                    // Financial information with defaults
                    totalAmount: paymentData.stripeSession?.amountTotal 
                      ? (paymentData.stripeSession.amountTotal / 100) 
                      : (paymentData.amount || 0),
                    // Order content information with defaults
                    items: paymentData.items || [],
                    // Time-related fields
                    createdAt: paymentData.createdAt || new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    // Add any additional fields that might be accessed in MyOrders.tsx
                    restaurant: paymentData.restaurant || {
                      name: restaurantName || 'Restaurant'
                    },
                    table: {
                      number: tableNumber || 'Unknown',
                      id: tableId || 'Unknown'
                    },
                    // Add a success flag for consistent checking
                    success: true
                  };
                  console.log('Adding complete order to context before navigation:', completeOrder);
                  // Ensure the order is added to context with all required fields
                  // Use type assertion with partial to handle missing properties
                  addOrder({
                    ...completeOrder,
                    subtotal: completeOrder.totalAmount || 0,
                    tax: 0,
                    tip: 0,
                    serviceFee: 0,
                    total: completeOrder.totalAmount || 0,
                    timestamp: new Date(completeOrder.createdAt || new Date().toISOString())
                  } as any);
                } else {
                  // Even if we don't have complete order data, try to add a minimal valid order
                  // This prevents errors when viewing orders
                  console.log('No complete order data available, creating minimal order object');
                  const minimalOrder = {
                    _id: orderId || `order_${Date.now()}`,
                    id: orderId || `order_${Date.now()}`,
                    status: 'completed',
                    paymentStatus: 'paid',
                    totalAmount: 0,
                    items: [],
                    createdAt: new Date().toISOString()
                  };
                  if (orderId) {
                    // Use type assertion with partial to handle missing properties
                    addOrder({
                      ...minimalOrder,
                      subtotal: minimalOrder.totalAmount || 0,
                      tax: 0,
                      tip: 0,
                      serviceFee: 0,
                      total: minimalOrder.totalAmount || 0,
                      timestamp: new Date(minimalOrder.createdAt || new Date().toISOString()),
                      tableId: tableId || 'unknown'
                    } as any);
                  }
                }
                // Use the table ID if available, otherwise navigate to default path
                if (storedTableId) {
                  navigate(`/my-orders?table=${storedTableId}`);
                } else {
                  navigate('/my-orders');
                }
              }}
              className="border border-gray-300 dark:border-gray-700 hover:bg-gray-100 dark:hover:bg-gray-800"
            >
              View My Orders
            </Button>
          </div>
        </div>
      )}
    </div>
  );
};
export default PaymentSuccess;
</file>

<file path="src/pages/Signup.tsx">
import React, { useState } from 'react';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { ArrowLeft, Gift, Loader2 } from 'lucide-react';
import { Checkbox } from '@/components/ui/checkbox';
import { Card, CardContent, CardFooter } from '@/components/ui/card';
import { toast } from 'sonner';
import { useAuth } from '@/context/AuthContext';
const Signup: React.FC = () => {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [agreeTerms, setAgreeTerms] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { signup, googleLogin, customerSignup, customerGoogleLogin } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  // Check for table ID in URL
  const getTableId = () => {
    const queryParams = new URLSearchParams(location.search);
    return queryParams.get('table');
  };
  const handleSignup = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!firstName || !lastName || !email || !password) {
      toast.error('Please fill all required fields');
      return;
    }
    if (!agreeTerms) {
      toast.error('You must agree to the Terms of Service and Privacy Policy');
      return;
    }
    setIsSubmitting(true);
    try {
      // Get table ID from multiple sources for reliability
      const tableIdFromUrl = getTableId();
      const locationState = location.state as { returnUrl?: string; tableId?: string } | null;
      const tableIdFromState = locationState?.tableId;
      const currentTableId = localStorage.getItem('currentTableId');
      const tableInfoStr = localStorage.getItem('tableInfo');
      let tableInfo;
      try {
        if (tableInfoStr) {
          tableInfo = JSON.parse(tableInfoStr);
        }
      } catch (e) {
        console.error('Error parsing tableInfo:', e);
      }
      // Use the first available table ID
      const effectiveTableId = tableIdFromUrl || tableIdFromState || currentTableId || (tableInfo?.id) || '';
      console.log('Signup with table context:', {
        tableIdFromUrl,
        tableIdFromState,
        currentTableId,
        tableInfoFromStorage: tableInfo?.id,
        effectiveTableId
      });
      // Store table ID in all possible locations for maximum compatibility
      if (effectiveTableId) {
        localStorage.setItem('currentTableId', effectiveTableId);
        localStorage.setItem('tableInfo', JSON.stringify({ id: effectiveTableId }));
        console.log('Stored table ID in localStorage before signup:', effectiveTableId);
      }
      // Try customer signup first (new customer authentication system)
      const success = await customerSignup(firstName, lastName, email, password);
      if (success) {
        toast.success('Account created successfully!');
        // Check if we have a return URL from the state
        const returnUrl = locationState?.returnUrl;
        if (returnUrl && returnUrl !== '/signup' && returnUrl !== '/login') {
          console.log(`Redirecting to return URL: ${returnUrl}`);
          navigate(returnUrl);
        } else if (effectiveTableId) {
          // If we have a table ID, redirect to the table page
          console.log(`Redirecting to table page with ID: ${effectiveTableId}`);
          navigate(`/?table=${effectiveTableId}`, { replace: true });
        } else {
          // Default home page
          navigate('/', { replace: true });
        }
        return;
      }
      // Fall back to regular signup if customer signup fails
      // This maintains backward compatibility
      const regularSuccess = await signup(firstName, lastName, email, password);
      if (regularSuccess) {
        toast.success('Account created successfully!');
        // Similar redirection logic for regular signup
        const returnUrl = locationState?.returnUrl;
        if (returnUrl && returnUrl !== '/signup' && returnUrl !== '/login') {
          navigate(returnUrl);
        } else if (effectiveTableId) {
          navigate(`/?table=${effectiveTableId}`, { replace: true });
        } else {
          navigate('/', { replace: true });
        }
      }
    } finally {
      setIsSubmitting(false);
    }
  };
  const handleGoogleSignup = async () => {
    setIsSubmitting(true);
    try {
      // Try customer Google login first (new customer authentication system)
      try {
        // Google login redirects, so we don't need to check return value
        customerGoogleLogin();
        // No need to navigate as Google OAuth will redirect
        return;
      } catch (error) {
        console.error('Customer Google signup failed, falling back to regular Google login', error);
        // Fall back to regular Google login if customer Google login fails
        // googleLogin may return a boolean or redirect
        googleLogin();
      }
    } finally {
      setIsSubmitting(false);
    }
  };
  return (
    <div className="container min-h-screen flex items-center justify-center px-6">
      <div className="w-full max-w-md space-y-6">
        <div className="space-y-2 text-center">
          <div className="w-14 h-14 bg-purple-100 dark:bg-purple-900/30 rounded-full flex items-center justify-center mx-auto mb-2">
            <Gift className="h-6 w-6 text-purple-600 dark:text-purple-400" />
          </div>
          <h1 className="text-2xl font-semibold text-white">Create an Account</h1>
          <p className="text-purple-200">Join our loyalty program and earn points with every order</p>
        </div>
        <form onSubmit={handleSignup}>
          <div className="space-y-4 pt-4">
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="first-name" className="text-sm">First Name</Label>
                <Input 
                  id="first-name" 
                  placeholder="John" 
                  value={firstName}
                  onChange={(e) => setFirstName(e.target.value)}
                  required
                  className="bg-background border-border"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="last-name" className="text-sm">Last Name</Label>
                <Input 
                  id="last-name" 
                  placeholder="Doe" 
                  value={lastName}
                  onChange={(e) => setLastName(e.target.value)}
                  required
                  className="bg-background border-border"
                />
              </div>
            </div>
            <div className="space-y-2">
              <Label htmlFor="email" className="text-sm">Email</Label>
              <Input 
                id="email" 
                type="email" 
                placeholder="your.email@example.com" 
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                className="bg-background border-border"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password" className="text-sm">Password</Label>
              <Input 
                id="password" 
                type="password" 
                placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢" 
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                minLength={8}
                className="bg-background border-border"
              />
            </div>
            <div className="flex items-start space-x-2 pt-2">
              <Checkbox 
                id="terms" 
                checked={agreeTerms}
                onCheckedChange={(checked) => setAgreeTerms(checked === true)}
                className="mt-1 border-border data-[state=checked]:bg-purple-600"
              />
              <div className="grid gap-1.5 leading-none">
                <label
                  htmlFor="terms"
                  className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
                >
                  I agree to the{' '}
                  <Link to="/terms" className="text-purple-400 hover:underline">
                    Terms of Service
                  </Link>{' '}
                  and{' '}
                  <Link to="/privacy" className="text-purple-400 hover:underline">
                    Privacy Policy
                  </Link>
                </label>
              </div>
            </div>
            <Button 
              type="submit" 
              className="w-full bg-purple-600 hover:bg-purple-700 text-white font-medium"
              disabled={isSubmitting}
            >
              {isSubmitting ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Creating Account...
                </>
              ) : 'Create Account'}
            </Button>
            <div className="relative">
              <div className="absolute inset-0 flex items-center">
                <div className="w-full border-t border-purple-500/20"></div>
              </div>
              <div className="relative flex justify-center text-sm">
                <span className="px-2 bg-[#16141F] text-purple-300">Or continue with</span>
              </div>
            </div>
            <Button 
              type="button"
              variant="outline" 
              className="w-full text-sm bg-white/5 border-purple-500/20 text-white hover:bg-white/10 hover:border-purple-500/30"
              onClick={handleGoogleSignup}
              disabled={isSubmitting}
            >
              <img 
                src="/google_g_logo.svg" 
                alt="Google logo" 
                className="mr-2 h-5 w-5" 
                onError={(e) => {
                  e.currentTarget.src = "https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg";
                }}
              />
              Sign up with Google
            </Button>
          </div>
        </form>
        <div className="flex flex-col items-center space-y-4 mt-6">
          <p className="text-center text-purple-200 text-sm">
            Already have an account?{' '}
            <Link to="/login" className="text-purple-400 hover:text-white font-semibold hover:underline">
              Log in
            </Link>
          </p>
          <Link 
            to="/" 
            className="inline-flex items-center text-sm text-purple-300 hover:text-white transition-colors"
          >
            <ArrowLeft className="mr-1 h-4 w-4" />
            Back to menu
          </Link>
        </div>
      </div>
    </div>
  );
};
export default Signup;
</file>

<file path="src/services/menuDataAdapter.ts">
import axios from 'axios';
import { MenuItem as UIMenuItem } from '@/types/menu';
import { API_BASE_URL } from '@/config/api';
// API Base URL imported from centralized configuration
// Restaurant ID - Cinema City Arabian Centre
const RESTAURANT_ID = "68187734a6d5090de7422456";
/**
 * API Data Interfaces
 */
export interface APICategory {
  _id: string;
  name: string;
  description: string;
  image: string;
  isActive: boolean;
  order: number;
  restaurantId: string;
}
export interface APISubcategory {
  _id: string;
  name: string;
  description: string;
  image: string;
  isActive: boolean;
  order: number;
  categoryId: string;
}
export interface APIMenuItem {
  _id: string;
  name: string;
  description: string;
  price: number;
  image: string;
  categories: string[];
  subCategories?: string[];
  isAvailable: boolean;
  isActive: boolean;
  tags?: string[];
  popular?: boolean;
  featured?: boolean;
}
/**
 * Maps from UI MenuItem format to API MenuItem format
 */
export const mapUIToAPIMenuItem = (
  uiItem: UIMenuItem, 
  categoryId: string, 
  subcategoryId?: string
): APIMenuItem => {
  return {
    _id: uiItem.id, // Keep the same ID for now
    name: uiItem.name,
    description: uiItem.description,
    price: uiItem.price,
    image: uiItem.image,
    categories: [categoryId],
    subCategories: subcategoryId ? [subcategoryId] : undefined,
    isAvailable: true,
    isActive: true,
    tags: uiItem.tags,
    popular: uiItem.popular,
    featured: uiItem.featured
  };
};
/**
 * Maps from API MenuItem format to UI MenuItem format
 */
export const mapAPIToUIMenuItem = (
  apiItem: APIMenuItem, 
  categoryMap: Record<string, APICategory>,
  subcategoryMap: Record<string, APISubcategory>
): UIMenuItem => {
  // Get the first category and subcategory IDs
  const categoryId = apiItem.categories && apiItem.categories.length > 0 
    ? apiItem.categories[0] 
    : '';
  const subcategoryId = apiItem.subCategories && apiItem.subCategories.length > 0 
    ? apiItem.subCategories[0] 
    : '';
  // Get category and subcategory names
  const category = categoryId && categoryMap[categoryId] 
    ? categoryMap[categoryId].name.toLowerCase() 
    : '';
  const subcategory = subcategoryId && subcategoryMap[subcategoryId] 
    ? subcategoryMap[subcategoryId].name 
    : undefined;
  return {
    id: apiItem._id,
    name: apiItem.name,
    description: apiItem.description,
    price: apiItem.price,
    image: apiItem.image,
    imageSearchTerm: apiItem.name, // Generate a search term from the name
    category,
    categoryId: categoryId,
    subcategory,
    featured: apiItem.featured || false,
    popular: apiItem.popular || false,
    tags: apiItem.tags || [],
  };
};
/**
 * Fetches categories from the API
 */
export const fetchCategories = async (): Promise<APICategory[]> => {
  try {
    const response = await axios.get(`${API_BASE_URL}/categories`);
    return response.data;
  } catch (error) {
    console.error('Error fetching categories:', error);
    throw new Error('Failed to fetch categories');
  }
};
/**
 * Creates a category in the API
 */
export const createCategory = async (category: Omit<APICategory, '_id'>): Promise<APICategory> => {
  try {
    const response = await axios.post(`${API_BASE_URL}/categories`, category);
    return response.data;
  } catch (error) {
    console.error('Error creating category:', error);
    throw new Error('Failed to create category');
  }
};
/**
 * Fetches subcategories for a category from the API
 */
export const fetchSubcategories = async (categoryId: string): Promise<APISubcategory[]> => {
  try {
    const response = await axios.get(`${API_BASE_URL}/categories/${categoryId}/subcategories`);
    return response.data;
  } catch (error) {
    console.error(`Error fetching subcategories for category ${categoryId}:`, error);
    throw new Error(`Failed to fetch subcategories for category ${categoryId}`);
  }
};
/**
 * Creates a subcategory in the API
 */
export const createSubcategory = async (
  categoryId: string, 
  subcategory: Omit<APISubcategory, '_id' | 'categoryId'>
): Promise<APISubcategory> => {
  try {
    const subcategoryWithCategoryId = {
      ...subcategory,
      categoryId
    };
    const response = await axios.post(
      `${API_BASE_URL}/categories/${categoryId}/subcategories`, 
      subcategoryWithCategoryId
    );
    return response.data;
  } catch (error) {
    console.error(`Error creating subcategory in category ${categoryId}:`, error);
    throw new Error(`Failed to create subcategory in category ${categoryId}`);
  }
};
/**
 * Fetches menu items from the API
 */
export const fetchMenuItems = async (
  categoryId?: string, 
  subcategoryId?: string
): Promise<APIMenuItem[]> => {
  try {
    let url = `${API_BASE_URL}/menu-items`;
    const params = new URLSearchParams();
    if (categoryId) params.append('categoryId', categoryId);
    if (subcategoryId) params.append('subcategoryId', subcategoryId);
    if (params.toString()) {
      url += `?${params.toString()}`;
    }
    const response = await axios.get(url);
    return response.data;
  } catch (error) {
    console.error('Error fetching menu items:', error);
    throw new Error('Failed to fetch menu items');
  }
};
/**
 * Creates a menu item in the API
 */
export const createMenuItem = async (menuItem: Omit<APIMenuItem, '_id'>): Promise<APIMenuItem> => {
  try {
    const response = await axios.post(`${API_BASE_URL}/menu-items`, menuItem);
    return response.data;
  } catch (error) {
    console.error('Error creating menu item:', error);
    throw new Error('Failed to create menu item');
  }
};
/**
 * Transforms our existing menu data to match API format and creates items
 * @param existingMenuItems The UI-formatted menu items from our existing data
 */
export const migrateMenuItemsToAPI = async (
  existingMenuItems: UIMenuItem[]
): Promise<Record<string, string>> => {
  try {
    // Step 1: Create the categories
    const categoryMap: Record<string, APICategory> = {};
    const uniqueCategories = [...new Set(existingMenuItems.map(item => item.category))];
    for (let i = 0; i < uniqueCategories.length; i++) {
      const categoryName = uniqueCategories[i];
      const categoryData = {
        name: categoryName.charAt(0).toUpperCase() + categoryName.slice(1), // Capitalize first letter
        description: `${categoryName.charAt(0).toUpperCase() + categoryName.slice(1)} selection`,
        image: existingMenuItems.find(item => item.category === categoryName)?.image || '',
        isActive: true,
        order: i + 1,
        restaurantId: RESTAURANT_ID
      };
      const category = await createCategory(categoryData);
      categoryMap[categoryName] = category;
    }
    // Step 2: Create subcategories
    const subcategoryMap: Record<string, APISubcategory> = {};
    const categoryToSubcategories: Record<string, string[]> = {};
    // Group subcategories by category
    existingMenuItems.forEach(item => {
      if (item.subcategory) {
        if (!categoryToSubcategories[item.category]) {
          categoryToSubcategories[item.category] = [];
        }
        if (!categoryToSubcategories[item.category].includes(item.subcategory)) {
          categoryToSubcategories[item.category].push(item.subcategory);
        }
      }
    });
    // Create subcategories for each category
    for (const [category, subcategories] of Object.entries(categoryToSubcategories)) {
      const categoryId = categoryMap[category]._id;
      for (let i = 0; i < subcategories.length; i++) {
        const subcategoryName = subcategories[i];
        const subcategoryData = {
          name: subcategoryName,
          description: `${subcategoryName} items`,
          image: existingMenuItems.find(
            item => item.category === category && item.subcategory === subcategoryName
          )?.image || '',
          isActive: true,
          order: i + 1
        };
        const subcategory = await createSubcategory(categoryId, subcategoryData);
        // Create a unique key to identify this subcategory
        const key = `${category}:${subcategoryName}`;
        subcategoryMap[key] = subcategory;
      }
    }
    // Step 3: Create menu items
    const idMap: Record<string, string> = {};
    for (const item of existingMenuItems) {
      const categoryId = categoryMap[item.category]._id;
      const subcategoryKey = item.subcategory ? `${item.category}:${item.subcategory}` : undefined;
      const subcategoryId = subcategoryKey ? subcategoryMap[subcategoryKey]._id : undefined;
      const apiItem = mapUIToAPIMenuItem(item, categoryId, subcategoryId);
      const createdItem = await createMenuItem(apiItem);
      // Store the mapping between the old UI id and the new API _id
      idMap[item.id] = createdItem._id;
    }
    return idMap;
  } catch (error) {
    console.error('Error migrating menu items to API:', error);
    throw new Error(`Failed to migrate menu items: ${error instanceof Error ? error.message : String(error)}`);
  }
};
/**
 * Fetches all data from API and transforms to UI format
 */
export const fetchAllMenuDataForUI = async (): Promise<UIMenuItem[]> => {
  try {
    // Fetch all categories and create a lookup map
    const categories = await fetchCategories();
    const categoryMap: Record<string, APICategory> = {};
    categories.forEach(category => {
      categoryMap[category._id] = category;
    });
    // Fetch all subcategories and create a lookup map
    const subcategoryMap: Record<string, APISubcategory> = {};
    for (const category of categories) {
      const subcategories = await fetchSubcategories(category._id);
      subcategories.forEach(subcategory => {
        subcategoryMap[subcategory._id] = subcategory;
      });
    }
    // Fetch all menu items and convert to UI format
    const menuItems = await fetchMenuItems();
    return menuItems.map(item => mapAPIToUIMenuItem(item, categoryMap, subcategoryMap));
  } catch (error) {
    console.error('Error fetching all menu data for UI:', error);
    throw new Error('Failed to fetch menu data');
  }
};
</file>

<file path="vite.config.ts">
import { defineConfig, loadEnv } from "vite";
import react from "@vitejs/plugin-react-swc";
import path from "path";
import { componentTagger } from "lovable-tagger";
// https://vitejs.dev/config/
export default defineConfig(({ mode }) => {
  // Load environment variables based on mode (development/production)
  const env = loadEnv(mode, process.cwd());
  console.log(`Building for ${mode} environment`);
  return {
    server: {
      host: "::",
      port: 8080,
    },
    plugins: [
      react({
        plugins: [],
        jsxImportSource: 'react',
        swcOptions: {
          jsc: {
            parser: {
              syntax: "typescript",
              tsx: true,
              decorators: false,
              dynamicImport: true
            },
            transform: {
              react: {
                runtime: "automatic",
                development: mode === "development",
                refresh: mode === "development"
              }
            },
            target: "es2020",
            loose: false,
            externalHelpers: false,
            keepClassNames: false
          },
          minify: mode === "production"
        }
      }),
      mode === 'development' &&
      componentTagger(),
    ].filter(Boolean),
    resolve: {
      alias: {
        "@": path.resolve(__dirname, "./src"),
      },
    },
    // Make environment variables available in the app
    define: {
      'process.env.VITE_CUSTOMER_URL': JSON.stringify(env.VITE_CUSTOMER_URL),
      'process.env.NODE_ENV': JSON.stringify(mode)
    }
  };
});
</file>

<file path="src/api/orderService.ts">
import { API_BASE_URL } from '@/config/constants';
import { CartItem, Order, OrderStatus, PaymentStatus, CartItemModifier } from '@/types';
import apiClient from './apiClient';
import authService, { getEffectiveToken } from '@/api/authService';
// Order type enum to match API
export enum OrderType {
  DINE_IN = 'DINE_IN',
  TAKEOUT = 'TAKEOUT',
  DELIVERY = 'DELIVERY'
}
// Constants for calculations
const TAX_RATE = 0.08;
const SERVICE_FEE_RATE = 0.05;
// Order item interface for API
export interface OrderItem {
  menuItem: string;
  name: string;
  quantity: number;
  price: number;
  subtotal: number;
  specialInstructions?: string;
  modifiers?: Array<{
    name: string;
    price: number;
  }>;
}
// Order data interface for API
export interface OrderData {
  restaurantId: string;
  tableId: string;
  items: OrderItem[];
  subtotal: number;
  tax: number;
  serviceFee: number;
  tip: number;
  total: number;
  orderType: OrderType;
  specialInstructions?: string;
}
/**
 * Interface for decoded JWT payload
 */
interface JWTPayload {
  id: string;
  email: string;
  role: string;
  exp: number;
  iat: number;
}
/**
 * Response interface for fetching multiple orders
 */
interface OrdersResponse {
  success: boolean;
  data: {
    orders: OrderResponseData[];
    pagination: {
      total: number;
      limit: number;
      page: number;
      pages: number;
    };
  };
  error?: {
    message: string;
    code: string;
  };
}
/**
 * Order data returned from API
 */
export interface OrderResponseData {
  _id: string;
  orderNumber: string;
  restaurantId: string;
  tableId: string;
  items: OrderItem[];
  status: OrderStatus;
  paymentStatus: PaymentStatus;
  subtotal: number;
  tax: number;
  serviceFee: number;
  tip: number;
  total: number;
  orderType: OrderType;
  specialInstructions?: string;
  createdAt: string;
  updatedAt: string;
}
/**
 * Response interface for single order operations
 */
interface OrderResponse {
  success: boolean;
  data: OrderResponseData;
  error?: {
    message: string;
    code: string;
  };
}
/**
 * Response interface for cancelling an order
 */
interface CancelOrderResponse {
  success: boolean;
  data: {
    _id: string;
    status: OrderStatus;
    updatedAt: string;
  };
  error?: {
    message: string;
    code: string;
  };
}
/**
 * Response interface for updating order status
 */
interface UpdateOrderStatusResponse {
  success: boolean;
  data: {
    _id: string;
    status: OrderStatus;
    updatedAt: string;
  };
  error?: {
    message: string;
    code: string;
  };
}
/**
 * Response interface for updating payment status
 */
interface UpdatePaymentStatusResponse {
  success: boolean;
  data: {
    _id: string;
    paymentStatus: PaymentStatus;
    updatedAt: string;
  };
  error?: {
    message: string;
    code: string;
  };
}
// Extract restaurant ID safely from table ID or use default
// Note: This is a fallback function in case restaurantId isn't provided directly
export const extractRestaurantIdFromTableId = (tableId: string): string => {
  if (!tableId || tableId.indexOf('-') === -1) {
    return '65f456b06c9dfd001b6b1234'; // Default restaurant ID
  }
  return tableId.split('-')[0];
};
// Helper function to generate a stable ID from modifier name
export const generateModifierId = (name: string): string => {
  return `mod_${name.toLowerCase().replace(/[^a-z0-9]/g, '_')}`;
};
// Converts API order response to frontend Order type
export const convertApiOrderToFrontend = (apiOrder: OrderResponseData): Order => ({
  id: apiOrder._id,
  orderNumber: apiOrder.orderNumber,
  items: apiOrder.items.map(item => ({
    id: item.menuItem,
    menuItemId: item.menuItem,
    name: item.name,
    price: item.price,
    quantity: item.quantity,
    specialInstructions: item.specialInstructions,
    modifiers: item.modifiers?.map(mod => ({
      id: generateModifierId(mod.name),
      name: mod.name,
      price: mod.price
    }))
  })),
  subtotal: apiOrder.subtotal,
  tax: apiOrder.tax,
  serviceFee: apiOrder.serviceFee,
  tip: apiOrder.tip,
  total: apiOrder.total,
  status: apiOrder.status,
  paymentStatus: apiOrder.paymentStatus,
  timestamp: new Date(apiOrder.createdAt),
  tableId: apiOrder.tableId,
  specialInstructions: apiOrder.specialInstructions
});
/**
 * Utility function to parse cookies into an object
 * @returns Object with cookie name-value pairs
 */
const parseCookies = (): { [key: string]: string } => {
  try {
    // Debug the raw cookie string
    console.log('Raw document.cookie:', document.cookie);
    // Skip parsing if cookie string is empty
    if (!document.cookie) {
      console.log('No cookies found in document.cookie');
      return {};
    }
    const cookies = document.cookie
      .split(';')
      .map(c => c.trim())
      .reduce((acc: {[key: string]: string}, curr) => {
        // More robust parsing - handle edge cases
        if (!curr) return acc;
        const eqPos = curr.indexOf('=');
        if (eqPos === -1) return acc;
        const key = curr.substring(0, eqPos).trim();
        const value = curr.substring(eqPos + 1).trim();
        if (key && value) acc[key] = value;
        return acc;
      }, {});
    // Debug the parsed cookies
    console.log('Parsed cookies:', cookies);
    return cookies;
  } catch (error) {
    console.error('Error parsing cookies:', error);
    return {};
  }
};
// Test helper functions - only included in development
if (process.env.NODE_ENV === 'development') {
  // Expose functions needed for testing
  (window as any).parseCookies = parseCookies;
  (window as any).validateJwtToken = (token: string) => {
    try {
      // Split token and validate format
      const tokenParts = token.split('.');
      if (tokenParts.length !== 3) {
        throw new Error('Invalid token format: missing segments');
      }
      const [, payload] = tokenParts;
      if (!payload) throw new Error('Invalid token format: missing payload');
      // Add padding to base64 if needed
      const base64 = payload.replace(/-/g, '+').replace(/_/g, '/');
      const padded = base64.padEnd(base64.length + (4 - base64.length % 4) % 4, '=');
      const decodedPayload = JSON.parse(atob(padded)) as JWTPayload;
      // Validate required fields
      if (!decodedPayload.id || !decodedPayload.exp || !decodedPayload.role) {
        throw new Error('Invalid token payload: missing required fields');
      }
      // Check if role is allowed
      if (!['customer', 'admin', 'staff'].includes(decodedPayload.role)) {
        throw new Error('Invalid token payload: invalid role');
      }
      const tokenExpiry = decodedPayload.exp * 1000;
      const currentTime = Date.now();
      return {
        isAuthenticated: tokenExpiry > currentTime,
        userId: decodedPayload.id,
        role: decodedPayload.role,
        expiresIn: Math.floor((tokenExpiry - currentTime) / 1000)
      };
    } catch (error) {
      console.warn('Token validation failed:', error instanceof Error ? error.message : 'Unknown error');
      return {
        isAuthenticated: false,
        userId: null,
        role: null,
        expiresIn: 0
      };
    }
  };
  // Only expose parseCookies and validateJwtToken here
  console.log('Initial test helper functions initialized in development mode');
}
/**
 * Helper function to prepare request headers with auth token
 * Only checks for access_token in cookies and sets proper Bearer token
 * @returns Object with appropriate headers including auth token if available
 */
const getAuthHeaders = (): HeadersInit => {
  const headers: HeadersInit = {
    'Content-Type': 'application/json'
  };
  // Get token using authService's method
  const token = getEffectiveToken();
  if (token && token !== 'http-only-cookie-present') {
    headers['Authorization'] = `Bearer ${token}`;
    console.log('Added Authorization header with token');
  } else {
    // Try to directly extract tokens from cookie string as a fallback
    const rawCookie = document.cookie;
    console.log('Raw cookie string in getAuthHeaders:', rawCookie);
    // Parse cookies using our utility function
    const cookies = parseCookies();
    console.log('All parsed cookies:', Object.keys(cookies));
    // Check for access_token first (for backward compatibility)
    if (cookies['access_token']) {
      headers['Authorization'] = `Bearer ${cookies['access_token']}`;
      console.log('Using access_token from cookies for request');
    // Then check for auth_token if access_token isn't found
    } else if (cookies['auth_token']) {
      headers['Authorization'] = `Bearer ${cookies['auth_token']}`;
      console.log('Using auth_token from cookies for request');
    } else {
      // Fallback: Try to manually extract the token from raw cookie string
      const accessTokenMatch = rawCookie.match(/access_token=([^;]+)/);
      const authTokenMatch = rawCookie.match(/auth_token=([^;]+)/);
      if (accessTokenMatch && accessTokenMatch[1]) {
        headers['Authorization'] = `Bearer ${accessTokenMatch[1]}`;
        console.log('Using access_token extracted directly from cookie string');
      } else if (authTokenMatch && authTokenMatch[1]) {
        headers['Authorization'] = `Bearer ${authTokenMatch[1]}`;
        console.log('Using auth_token extracted directly from cookie string');
      } else {
        console.log('No auth token found in cookies (checked parsed cookies and raw string)');
      }
    }
  }
  // Log the final headers being used
  console.log('Final authorization header set:', headers.Authorization ? 'Yes' : 'No');
  return headers;
};
/**
 * Creates a new order in the system
 * 
 * @param cartItems - Array of cart items to be included in the order
 * @param tableId - ID of the table where the order is placed
 * @param restaurantId - ID of the restaurant
 * @param customOrderData - Optional custom order data
 * @param navigate - Optional navigation function for redirecting if auth fails
 * @returns Promise resolving to the created order data
 * @throws Error if API request fails
 */
export const createOrder = async (
  cartItems: CartItem[], 
  tableId: string, 
  restaurantId: string,
  customOrderData?: OrderData,
  navigate?: (path: string, options?: any) => void
): Promise<OrderResponseData> => {
  try {
    console.log('createOrder called with credentials included');
    console.log('tableId:', tableId);
    console.log('restaurantId:', restaurantId);
    // Check authentication status first
    const token = getEffectiveToken();
    if (!token || token === 'http-only-cookie-present') {
      console.log('No valid token found, attempting to refresh...');
      const refreshSuccess = await authService.refreshToken();
      if (!refreshSuccess) {
        console.log('Token refresh failed, redirecting to login');
        if (cartItems.length > 0) {
          localStorage.setItem('pendingCart', JSON.stringify({
            items: cartItems,
            tableId
          }));
        }
        if (navigate) {
          navigate('/login', { state: { from: '/cart', tableId } });
        } else {
          window.location.href = `/login?redirect=${encodeURIComponent('/cart')}&tableId=${tableId}`;
        }
        throw new Error('Authentication required. Please log in to place an order.');
      }
    }
    // Get or generate a device ID for guest users
    const getDeviceId = (): string => {
      // Check localStorage for existing device ID
      let deviceId = localStorage.getItem('device_id');
      if (!deviceId) {
        // Generate a new device ID if none exists
        deviceId = `device_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
        localStorage.setItem('device_id', deviceId);
      }
      return deviceId;
    };
    const deviceId = getDeviceId();
    console.log('Device ID for order:', deviceId);
    // Prepare order data
    let formattedOrderData: OrderData;
    if (customOrderData) {
      formattedOrderData = customOrderData;
    } else {
      const subtotal = cartItems.reduce((total, item) => {
        if (item.getItemTotal) {
          return total + item.getItemTotal();
        }
        const modifierPrice = item.modifiers ? 
          item.modifiers.reduce((sum, mod) => sum + mod.price, 0) : 0;
        return total + ((item.price + modifierPrice) * item.quantity);
      }, 0);
      const tax = subtotal * TAX_RATE;
      const serviceFee = subtotal * SERVICE_FEE_RATE;
      const tipAmount = 0;
      const total = subtotal + tax + serviceFee + tipAmount;
      const formattedItems = cartItems.map(item => {
        const itemTotal = item.getItemTotal 
          ? item.getItemTotal() 
          : (item.price * item.quantity) + (item.modifiers?.reduce((sum, mod) => sum + mod.price, 0) || 0);
        return {
          menuItem: item.menuItemId || item.id,
          name: item.name,
          quantity: item.quantity,
          price: item.price,
          subtotal: itemTotal,
          specialInstructions: item.specialInstructions || '',
          modifiers: item.modifiers?.map(mod => ({
            name: mod.name,
            price: mod.price
          })) || []
        };
      });
      const safeRestaurantId = restaurantId === 'InSeat' 
        ? '65f456b06c9dfd001b6b1234' 
        : restaurantId || extractRestaurantIdFromTableId(tableId);
      formattedOrderData = {
        restaurantId: safeRestaurantId,
        tableId,
        items: formattedItems,
        subtotal,
        tax,
        serviceFee,
        tip: tipAmount,
        total,
        orderType: OrderType.DINE_IN,
        specialInstructions: ''
      };
    }
    // Prepare complete order data with device ID
    const completeOrderData = {
      ...formattedOrderData,
      status: OrderStatus.PENDING,
      paymentStatus: PaymentStatus.PENDING,
      orderNumber: `ORD-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
      deviceId // Include device ID for tracking
    };
    // Log data preparation
    console.log('Prepared order data:', {
      orderNumber: completeOrderData.orderNumber,
      hasDeviceId: Boolean(deviceId)
    });
    // Get fresh headers after potential token refresh
    const headers = getAuthHeaders();
    console.log('Sending order request with credentials included');
    console.log('Request headers prepared:', {
      hasAuthorization: !!headers.Authorization,
      contentType: headers['Content-Type']
    });
    // Log the request details for debugging
    console.log('Order request details:', {
      url: `${API_BASE_URL}/api/orders`,
      method: 'POST',
      headers: headers,
      body: JSON.stringify(completeOrderData).substring(0, 100) + '...',
      withCredentials: true
    });
    // Send the request with credentials: 'include' to send cookies
    const response = await fetch(`${API_BASE_URL}/api/orders`, {
      method: 'POST',
      headers,
      body: JSON.stringify(completeOrderData),
      credentials: 'include' // This ensures cookies are sent automatically
    });
    if (!response.ok) {
      let errorMessage: string;
      try {
        const errorData = await response.json();
        errorMessage = errorData.message || errorData.error || `Order creation failed with status: ${response.status}`;
      } catch (e) {
        errorMessage = `Order creation failed with status: ${response.status}`;
        console.error('Could not parse error response:', e);
      }
      // Special handling for authentication errors
      if (response.status === 401) {
        console.log('Authentication required - redirecting to login');
        console.log('Server requires authentication despite cookies being sent automatically');
        // Save cart state before redirect
        if (cartItems.length > 0) {
          localStorage.setItem('pendingCart', JSON.stringify({
            items: cartItems,
            tableId
          }));
        }
        // Use navigate function if provided, otherwise use default redirect
        if (navigate) {
          navigate('/login', { state: { from: '/cart', tableId } });
        } else {
          // Default fallback redirect
          if (typeof window !== 'undefined') {
            window.location.href = `/login?redirect=${encodeURIComponent('/cart')}&tableId=${tableId}`;
          }
        }
        throw new Error('Authentication required. Please log in to place an order.');
      }
      throw new Error(errorMessage);
    }
    const data = await response.json();
    const orderData = data.data || data; // Handle different response formats
    console.log('Order created successfully:', orderData);
    return orderData;
  } catch (error) {
    console.error('Error creating order:', error);
    throw error instanceof Error ? error : new Error('An unexpected error occurred during order creation.');
  }
};
/**
 * Fetches all orders for the currently authenticated user
 * 
 * @returns Promise resolving to orders data with pagination
 * @throws Error if API request fails
 */
export const fetchUserOrders = async (): Promise<OrdersResponse['data']> => {
  try {
    console.log('Fetching user orders with credentials included');
    const response = await fetch(`${API_BASE_URL}/api/orders/my-orders`, {
      method: 'GET',
      headers: getAuthHeaders(),
      credentials: 'include' // Send cookies
    });
    if (!response.ok) {
      if (response.status === 401) {
        throw new Error('Authentication required');
      }
      throw new Error(`Failed to fetch orders: ${response.status}`);
    }
    const data = await response.json();
    // Handle different response formats
    if (Array.isArray(data)) {
      return {
        orders: data,
        pagination: {
          total: data.length,
          limit: data.length,
          page: 1,
          pages: 1
        }
      };
    } else if (data.success) {
      return data.data;
    } else if (data.orders) {
      return data;
    }
    return {
      orders: [],
      pagination: { total: 0, limit: 10, page: 1, pages: 0 }
    };
  } catch (error) {
    console.error('Error fetching user orders:', error);
    throw error instanceof Error ? error : new Error('Failed to fetch orders');
  }
};
/**
 * Cancels an existing order
 * 
 * @param orderId - ID of the order to cancel
 * @returns Promise that resolves when the order is cancelled
 * @throws Error if API request fails
 */
export const cancelOrder = async (orderId: string): Promise<void> => {
  try {
    const response = await fetch(`${API_BASE_URL}/api/orders/${orderId}/cancel`, {
      method: 'POST',
      headers: getAuthHeaders(),
      credentials: 'include'
    });
    if (!response.ok) {
      throw new Error(`Failed to cancel order: ${response.status}`);
    }
    console.log('Order cancelled successfully');
  } catch (error) {
    console.error('Error cancelling order:', error);
    throw error instanceof Error ? error : new Error('Failed to cancel order');
  }
};
/**
 * Retrieves an order by its ID
 * 
 * @param orderId - ID of the order to retrieve
 * @returns Promise resolving to the order data
 * @throws Error if API request fails
 */
export const getOrderById = async (orderId: string): Promise<Order> => {
  try {
    const response = await fetch(`${API_BASE_URL}/api/orders/${orderId}`, {
      method: 'GET',
      headers: getAuthHeaders(),
      credentials: 'include'
    });
    if (!response.ok) {
      throw new Error(`Failed to fetch order: ${response.status}`);
    }
    const data = await response.json();
    // Handle different response formats
    if (data.success) {
      return convertApiOrderToFrontend(data.data);
    } else if (data._id) {
      return convertApiOrderToFrontend(data);
    }
    throw new Error('Invalid order data received');
  } catch (error) {
    console.error('Error fetching order:', error);
    throw error instanceof Error ? error : new Error('Failed to fetch order');
  }
};
/**
 * Updates the status of an existing order
 * 
 * @param orderId - ID of the order to update
 * @param status - New status to set
 * @returns Promise resolving to the updated order status data
 * @throws Error if API request fails
 */
export const updateOrderStatus = async (
  orderId: string,
  status: OrderStatus
): Promise<UpdateOrderStatusResponse['data']> => {
  try {
    const response = await fetch(`${API_BASE_URL}/api/orders/${orderId}/status`, {
      method: 'PATCH',
      headers: getAuthHeaders(),
      body: JSON.stringify({ status }),
      credentials: 'include'
    });
    if (!response.ok) {
      throw new Error(`Failed to update order status: ${response.status}`);
    }
    const data = await response.json();
    return data.data;
  } catch (error) {
    console.error('Error updating order status:', error);
    throw error instanceof Error ? error : new Error('Failed to update order status');
  }
};
/**
 * Updates the payment status of an existing order
 * 
 * @param orderId - ID of the order to update
 * @param paymentStatus - New payment status to set
 * @returns Promise resolving to the updated payment status data
 * @throws Error if API request fails
 */
export const updatePaymentStatus = async (
  orderId: string,
  paymentStatus: PaymentStatus
): Promise<UpdatePaymentStatusResponse['data']> => {
  try {
    const response = await fetch(`${API_BASE_URL}/api/orders/${orderId}/payment`, {
      method: 'PATCH',
      headers: getAuthHeaders(),
      body: JSON.stringify({ paymentStatus }),
      credentials: 'include'
    });
    if (!response.ok) {
      throw new Error(`Failed to update payment status: ${response.status}`);
    }
    const data = await response.json();
    return data.data;
  } catch (error) {
    console.error('Error updating payment status:', error);
    throw error instanceof Error ? error : new Error('Failed to update payment status');
  }
};
// Export additional test helpers after all functions are defined
if (process.env.NODE_ENV === 'development') {
  (window as any).createOrder = createOrder;
  console.log('Additional test helper functions (createOrder) initialized in development mode');
}
</file>

<file path="src/config/api.ts">
// Configuration interface
interface ApiConfig {
  baseUrl: string;
  authUrl: string;
  socketUrl: string;
  customerUrl: string;
}
// Environment variable validation
const requiredEnvVars = [
  'VITE_API_BASE_URL',
  'VITE_AUTH_API_URL',
  'VITE_SOCKET_URL',
  'VITE_CUSTOMER_URL',
] as const;
// Check for missing environment variables
const missingEnvVars = requiredEnvVars.filter(
  (envVar) => !import.meta.env[envVar]
);
if (missingEnvVars.length > 0) {
  console.warn(
    `Missing required environment variables: ${missingEnvVars.join(', ')}`
  );
}
// Import the base URL from the main constants file
import { API_BASE_URL as ConstantsBaseUrl } from '@/constants';
// Extract domain without /api if present
const baseDomain = typeof ConstantsBaseUrl === 'string' && ConstantsBaseUrl.includes('/api') 
  ? ConstantsBaseUrl.split('/api')[0] 
  : ConstantsBaseUrl;
// API configuration
export const apiConfig: ApiConfig = {
  baseUrl: import.meta.env.VITE_API_BASE_URL || `${baseDomain}/api`,
  authUrl: import.meta.env.VITE_AUTH_API_URL || `${baseDomain}/api/auth`,
  socketUrl: import.meta.env.VITE_SOCKET_URL || baseDomain,
  customerUrl: import.meta.env.VITE_CUSTOMER_URL || 'https://menu.inseat.achievengine.com',
};
// Export individual URLs for convenience
export const API_BASE_URL = apiConfig.baseUrl;
export const AUTH_API_URL = apiConfig.authUrl;
export const SOCKET_URL = apiConfig.socketUrl;
export const CUSTOMER_URL = apiConfig.customerUrl;
export default apiConfig;
</file>

<file path="src/context/AuthContext.tsx">
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { toast } from 'sonner';
import { AuthService, getAuthHeader } from '@/services/AuthService';
import customerAuthService from '@/api/customerAuthService';
import { useNavigate } from 'react-router-dom';
import CartContext, { useCart } from '@/context/CartContext';
// Define types for authentication
interface AuthUser {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: string;
  loyaltyPoints: number;
  name: string;
  createdAt: string;
  orders: any[];
  _id?: string; // Optional MongoDB _id
}
// Extended user data that might come from the API
interface ApiUserData {
  id?: string;
  _id?: string;
  email: string;
  firstName?: string;
  lastName?: string;
  role?: string;
  loyaltyPoints?: number;
  name?: string;
  createdAt?: string | Date;
  orders?: any[];
  token?: string;
  refreshToken?: string;
}
// Response type from auth service
interface AuthResponseUser {
  success?: boolean;
  message?: string;
  user?: ApiUserData;
  token?: string;
  refreshToken?: string;
}
interface UserWithToken extends AuthUser {
  success?: boolean;
  token?: string;
  user?: ApiUserData;
}
type AuthContextType = {
  user: AuthUser | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  token: string | null;
  login: (email: string, password: string) => Promise<boolean>;
  signup: (firstName: string, lastName: string, email: string, password: string) => Promise<boolean>;
  logout: () => Promise<void>;
  googleLogin: () => void;
  guestLogin: (tableId?: string) => Promise<boolean>;
  customerLogin: (email: string, password: string) => Promise<boolean>;
  customerSignup: (firstName: string, lastName: string, email: string, password: string) => Promise<boolean>;
  customerGoogleLogin: () => void;
  updateUser: (userData: Partial<AuthUser>) => void;
  addLoyaltyPoints: (points: number) => void;
  refreshToken: () => Promise<boolean>;
  setIsAuthenticated: (value: boolean) => void;
};
const AuthContext = createContext<AuthContextType | undefined>(undefined);
const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<AuthUser | null>(null);
  const [loading, setLoading] = useState(true);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [token, setToken] = useState<string | null>(null);
  const navigate = useNavigate();
  // Helper function to get token from all possible sources
  function getTokenFromAllSources(): string | null {
    // Only check cookies for tokens
    try {
      const cookies = document.cookie.split(';');
      // First check for access_token (from Google OAuth)
      const accessTokenCookie = cookies.find(cookie => cookie.trim().startsWith('access_token='));
      if (accessTokenCookie) {
        const token = accessTokenCookie.split('=')[1].trim();
        console.log('Found access_token in cookies:', token);
        return token;
      }
      // Then check for auth_token
      const authTokenCookie = cookies.find(cookie => cookie.trim().startsWith('auth_token='));
      if (authTokenCookie) {
        const token = authTokenCookie.split('=')[1].trim();
        console.log('Found auth_token in cookies:', token);
        return token;
      }
    } catch (error) {
      console.error('Error getting token from cookies:', error);
    }
    console.log('No token found in cookies');
    return null;
  }
  // Check authentication status on mount
  useEffect(() => {
    const checkAuth = async () => {
      try {
        setLoading(true);
        // First check if we have a valid token
        const token = getTokenFromAllSources();
        if (token) {
          console.log('Found token during initialization');
          setToken(token);
          // Set authenticated to true immediately when token is found
          setIsAuthenticated(true);
        } else {
          console.log('No token found during initialization');
          setLoading(false);
          return;
        }
        // Try to get user data from the auth/me endpoint (avoiding double /api/ prefix)
        try {
          console.log('Attempting to fetch user profile');
          // Make sure we're using the correct endpoint without duplicate /api/ prefix
          const userData = await AuthService.getCurrentUser();
          if (userData) {
            console.log('Successfully fetched user profile:', userData);
            // Explicitly set isAuthenticated to true when we have valid user data
            setIsAuthenticated(true);
            // Helper function to safely get date string
            const getDateString = (date: string | Date | undefined): string => {
              if (!date) return new Date().toISOString();
              return typeof date === 'string' ? date : date.toISOString();
            };
            // Helper to safely access nested properties
            const safeGet = (obj: any, path: string, defaultValue: any): any => {
              return path.split('.').reduce((acc, key) => acc?.[key], obj) ?? defaultValue;
            };
            // Get the ID, preferring id over _id
            const userId = (safeGet(userData, 'id', '') || safeGet(userData, '_id', '')).toString();
            // Generate a display name from available fields
            const firstName = safeGet(userData, 'firstName', '');
            const lastName = safeGet(userData, 'lastName', '');
            const email = safeGet(userData, 'email', '');
            const displayName = safeGet(userData, 'name', '') || 
              (firstName || lastName ? `${firstName} ${lastName}`.trim() : email || 'User');
            // Create the normalized user object with all required fields
            const normalizedUser: AuthUser = {
              id: userId,
              email: email,
              firstName: firstName,
              lastName: lastName,
              role: safeGet(userData, 'role', 'customer'),
              loyaltyPoints: safeGet(userData, 'loyaltyPoints', 0),
              name: displayName,
              createdAt: getDateString(safeGet(userData, 'createdAt', undefined)),
              orders: safeGet(userData, 'orders', []),
            };
            setUser(normalizedUser);
            setIsAuthenticated(true);
            localStorage.setItem('user', JSON.stringify(normalizedUser));
            console.log('Authentication successful, user set');
            return; // Exit early on success
          } else {
            console.warn('Failed to get valid user data, but token exists - trying fallback');
            // If we have a token but can't get user data, try to create a minimal user from token
            try {
              // Decode JWT to get basic user info
              const tokenParts = token.split('.');
              if (tokenParts.length === 3) {
                const payload = JSON.parse(atob(tokenParts[1]));
                console.log('Token payload:', payload);
                if (payload.id && payload.email) {
                  const fallbackUser: AuthUser = {
                    id: payload.id,
                    email: payload.email,
                    firstName: payload.firstName || 'User',
                    lastName: payload.lastName || '',
                    role: payload.role || 'customer',
                    loyaltyPoints: 0,
                    name: payload.name || `${payload.firstName || 'User'} ${payload.lastName || ''}`.trim(),
                    createdAt: new Date().toISOString(),
                    orders: [],
                  };
                  setUser(fallbackUser);
                  setIsAuthenticated(true);
                  localStorage.setItem('user', JSON.stringify(fallbackUser));
                  console.log('Created fallback user from token');
                  return;
                }
              }
            } catch (tokenError) {
              console.error('Error decoding token for fallback user:', tokenError);
            }
            // Clear invalid auth data
            localStorage.removeItem('auth_token');
            localStorage.removeItem('user');
            setUser(null);
            setIsAuthenticated(false);
          }
        } catch (error) {
          console.error('Error fetching user profile:', error);
          // If we have a token but can't reach the server, try to create a minimal user from token
          try {
            const tokenParts = token.split('.');
            if (tokenParts.length === 3) {
              const payload = JSON.parse(atob(tokenParts[1]));
              console.log('Token payload for offline fallback:', payload);
              if (payload.id && payload.email) {
                const fallbackUser: AuthUser = {
                  id: payload.id,
                  email: payload.email,
                  firstName: payload.firstName || 'User',
                  lastName: payload.lastName || '',
                  role: payload.role || 'customer',
                  loyaltyPoints: 0,
                  name: payload.name || `${payload.firstName || 'User'} ${payload.lastName || ''}`.trim(),
                  createdAt: new Date().toISOString(),
                  orders: [],
                };
                setUser(fallbackUser);
                setIsAuthenticated(true);
                localStorage.setItem('user', JSON.stringify(fallbackUser));
                console.log('Created offline fallback user from token');
                return;
              }
            }
          } catch (tokenError) {
            console.error('Error decoding token for offline fallback:', tokenError);
          }
          setIsAuthenticated(false);
          setUser(null);
        }
      } finally {
        setLoading(false);
      }
    };
    checkAuth();
  }, []);
  // Save user data to localStorage whenever it changes
  useEffect(() => {
    if (user) {
      localStorage.setItem('user', JSON.stringify(user));
      // Ensure isAuthenticated is true whenever we have a user
      if (!isAuthenticated) {
        setIsAuthenticated(true);
      }
    } else {
      localStorage.removeItem('user');
    }
  }, [user, isAuthenticated]);
  // Listen for auth state changes from other components
  useEffect(() => {
    const handleAuthStateChange = (event: any) => {
      if (event.detail && typeof event.detail.isAuthenticated === 'boolean') {
        setIsAuthenticated(event.detail.isAuthenticated);
      }
    };
    window.addEventListener('auth-state-changed', handleAuthStateChange);
    return () => {
      window.removeEventListener('auth-state-changed', handleAuthStateChange);
    };
  }, []);
  const login = async (email: string, password: string): Promise<boolean> => {
    setLoading(true);
    try {
      const response = await AuthService.login({ email, password });
      console.log('Login response:', response);
      if (response.success && response.user) {
        // Transform the user object to match our frontend expectations
        const userData: AuthUser = {
          id: response.user.id || (response.user as any)._id || '',  // Handle both id and _id with type assertion
          email: response.user.email || '',
          firstName: response.user.firstName || '',
          lastName: response.user.lastName || '',
          role: response.user.role || 'customer',
          loyaltyPoints: response.user.loyaltyPoints || 0,
          name: `${response.user.firstName || ''} ${response.user.lastName || ''}`.trim() || response.user.email || '',
          createdAt: response.user.createdAt?.toString() || new Date().toISOString(),
          orders: response.user.orders || [],
        };
        setUser(userData);
        // Get token from cookies after login
        const accessToken = getTokenFromAllSources();
        console.log('Token after login:', accessToken);
        if (accessToken) {
          console.log('Setting token after login:', accessToken);
          setToken(accessToken);
          setIsAuthenticated(true);
        } else {
          console.log('No token found in cookies after login!');
        }
        toast.success('Login successful!');
        return true;
      }
      toast.error('Invalid email or password');
      return false;
    } catch (error) {
      console.error('Login error:', error);
      toast.error(error instanceof Error ? error.message : 'Login failed. Please try again.');
      return false;
    } finally {
      setLoading(false);
    }
  };
  const signup = async (firstName: string, lastName: string, email: string, password: string): Promise<boolean> => {
    setLoading(true);
    try {
      const response = await AuthService.register({
        firstName,
        lastName,
        email,
        password
      });
      console.log('Signup response:', response);
      if (response.success && response.user) {
        // Transform the user object to match our frontend expectations
        const userData: AuthUser = {
          id: response.user.id || (response.user as any)._id || '',  // Handle both id and _id with type assertion
          email: response.user.email || '',
          firstName: response.user.firstName || '',
          lastName: response.user.lastName || '',
          role: response.user.role || 'customer',
          loyaltyPoints: response.user.loyaltyPoints || 0,
          name: `${response.user.firstName || ''} ${response.user.lastName || ''}`.trim() || response.user.email || '',
          createdAt: response.user.createdAt?.toString() || new Date().toISOString(),
          orders: response.user.orders || [],
        };
        setUser(userData);
        // Get token from cookies after signup
        const accessToken = getTokenFromAllSources();
        if (accessToken) {
          setToken(accessToken);
          setIsAuthenticated(true);
        }
        toast.success('Registration successful!');
        return true;
      }
      toast.error('Registration failed. Please try again.');
      return false;
    } catch (error) {
      console.error('Signup error:', error);
      toast.error(error instanceof Error ? error.message : 'Registration failed. Please try again.');
      return false;
    } finally {
      setLoading(false);
    }
  };
  const logout = async (): Promise<void> => {
    try {
      await AuthService.logout();
      // Clear auth state
      setUser(null);
      setToken(null);
      setIsAuthenticated(false);
      // Clear localStorage
      localStorage.removeItem('user');
      localStorage.removeItem('auth_token');
      // Clear cookies by setting expiration to past date
      document.cookie = 'auth_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
      document.cookie = 'access_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
      // Notify other components about the authentication state change
      window.dispatchEvent(new CustomEvent('auth-state-changed', { detail: { isAuthenticated: false } }));
      toast.success('Logged out successfully');
    } catch (error) {
      console.error('Logout error:', error);
      toast.error('Error during logout');
    }
  };
  const googleLogin = (): void => {
    // Get the base URL without the /api/auth path
    const baseUrl = import.meta.env.VITE_AUTH_API_URL?.split('/api/auth')[0] || import.meta.env.VITE_API_BASE_URL || 'https://api.inseat.achievengine.com';
    const googleAuthUrl = `${baseUrl}/api/auth/google`;
    console.log('Google login redirecting to:', googleAuthUrl);
    window.location.href = googleAuthUrl;
  };
  /**
   * Initialize guest login for users who don't want to create an account
   */
  const guestLogin = async (tableId?: string): Promise<boolean> => {
    setLoading(true);
    try {
      console.log('Attempting guest login via AuthService...');
      // Create a device ID if not already stored
      const deviceId = localStorage.getItem('device_id') || `device_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
      if (!localStorage.getItem('device_id')) {
        localStorage.setItem('device_id', deviceId);
      }
      // Use the correct endpoint: guest-token
      const response = await AuthService.guestLogin(tableId || '');
      if (response.success && response.token) {
        // Set token in cookie for cross-page consistency
        document.cookie = `auth_token=${response.token}; path=/; max-age=86400; SameSite=Lax`;
        // Create a minimal user object
        const guestUser: AuthUser = {
          id: response.user?.id || 'guest',
          email: response.user?.email || 'guest@example.com',
          firstName: 'Guest',
          lastName: 'User',
          role: 'guest',
          loyaltyPoints: 0,
          name: 'Guest User',
          createdAt: new Date().toISOString(),
          orders: [],
        };
        setUser(guestUser);
        setToken(response.token);
        setIsAuthenticated(true);
        console.log('Guest login successful');
        return true;
      }
      console.error('Guest login failed:', response);
      return false;
    } catch (error) {
      console.error('Guest login error:', error);
      return false;
    } finally {
      setLoading(false);
    }
  };
  /**
   * Attempt to refresh the authentication token
   */
  const refreshToken = async (): Promise<boolean> => {
    try {
      console.log('Attempting to refresh token...');
      // Try to refresh the token with the server
      await AuthService.refreshToken();
      // Get the latest token
      const newToken = getTokenFromAllSources();
      if (newToken) {
        console.log('Got new token after refresh');
        setToken(newToken);
        setIsAuthenticated(true);
        return true;
      }
      // Check if we're authenticated after refresh
      const isAuthenticated = await AuthService.isAuthenticated();
      console.log('Authentication status after refresh:', isAuthenticated);
      if (isAuthenticated) {
        // If no token found but we're authenticated, try to get user data
        const userData = await AuthService.getCurrentUser() as any as UserWithToken;
        if (userData && (userData.success || userData.id)) {
          const email = userData.email || (userData.user?.email || '');
          console.log('Got user data after refresh:', email);
          setIsAuthenticated(true);
          // If we got a token in the response, save it
          if (userData.token) {
            console.log('Got new token from user data after refresh');
            setToken(userData.token);
            // Only using cookies for token storage, not localStorage
            // Set token in cookie for cross-page consistency
            document.cookie = `auth_token=${userData.token}; path=/; max-age=86400; SameSite=Lax`;
          }
          return true;
        }
      }
      console.log('Token refresh failed');
      return false;
    } catch (error) {
      console.error('Error refreshing token:', error);
      // Clear authentication state on error
      localStorage.removeItem('user');
      localStorage.removeItem('auth_token');
      setUser(null);
      setToken(null);
      setIsAuthenticated(false);
      return false;
    }
  };
  const updateUser = (userData: Partial<AuthUser>) => {
    if (user) {
      setUser({ ...user, ...userData });
    } else {
      setUser(userData as AuthUser);
    }
    // Ensure isAuthenticated is set to true when updating user data
    setIsAuthenticated(true);
  };
  const addLoyaltyPoints = (points: number) => {
    if (user) {
      const updatedUser = {
        ...user,
        loyaltyPoints: (user.loyaltyPoints || 0) + points
      };
      setUser(updatedUser);
      localStorage.setItem('user', JSON.stringify(updatedUser));
      toast.success(`Added ${points} loyalty points!`);
    }
  };
  const customerLogin = async (email: string, password: string): Promise<boolean> => {
    setLoading(true);
    try {
      const response = await customerAuthService.login(email, password);
      if (response.success && response.user) {
        // Transform the user object to match our frontend expectations
        const userData: AuthUser = {
          id: response.user.id || (response.user as any)._id || '',
          email: response.user.email || '',
          firstName: response.user.firstName || '',
          lastName: response.user.lastName || '',
          role: 'customer',
          loyaltyPoints: response.user.loyaltyPoints || 0,
          name: `${response.user.firstName || ''} ${response.user.lastName || ''}`.trim() || response.user.email || '',
          createdAt: response.user.createdAt?.toString() || new Date().toISOString(),
          orders: response.user.orders || [],
        };
        setUser(userData);
        // Get token from cookies after login
        const accessToken = getTokenFromAllSources();
        if (accessToken) {
          setToken(accessToken);
          setIsAuthenticated(true);
        }
        toast.success('Login successful!');
        return true;
      }
      toast.error('Invalid email or password');
      return false;
    } catch (error) {
      console.error('Customer login error:', error);
      toast.error(error instanceof Error ? error.message : 'Login failed. Please try again.');
      return false;
    } finally {
      setLoading(false);
    }
  };
  const customerSignup = async (firstName: string, lastName: string, email: string, password: string): Promise<boolean> => {
    setLoading(true);
    try {
      const response = await customerAuthService.register({
        firstName,
        lastName,
        email,
        password
      });
      if (response.success && response.user) {
        // Transform the user object to match our frontend expectations
        const userData: AuthUser = {
          id: response.user.id || (response.user as any)._id || '',
          email: response.user.email || '',
          firstName: response.user.firstName || '',
          lastName: response.user.lastName || '',
          role: 'customer',
          loyaltyPoints: response.user.loyaltyPoints || 0,
          name: `${response.user.firstName || ''} ${response.user.lastName || ''}`.trim() || response.user.email || '',
          createdAt: response.user.createdAt?.toString() || new Date().toISOString(),
          orders: response.user.orders || [],
        };
        setUser(userData);
        // Get token from cookies after signup
        const accessToken = getTokenFromAllSources();
        if (accessToken) {
          setToken(accessToken);
          setIsAuthenticated(true);
        }
        toast.success('Registration successful!');
        return true;
      }
      toast.error('Registration failed. Please try again.');
      return false;
    } catch (error) {
      console.error('Customer signup error:', error);
      toast.error('An error occurred during registration. Please try again.');
      return false;
    } finally {
      setLoading(false);
    }
  };
  const customerGoogleLogin = () => {
    const baseUrl = import.meta.env.VITE_AUTH_API_URL?.split('/api/auth')[0] || import.meta.env.VITE_API_BASE_URL || 'https://api.inseat.achievengine.com';
    const googleAuthUrl = `${baseUrl}/api/customer/google`;
    console.log('Customer Google login redirecting to:', googleAuthUrl);
    window.location.href = googleAuthUrl;
  };
  return (
    <AuthContext.Provider
      value={{
        user,
        isLoading: loading,
        isAuthenticated,
        token,
        login,
        signup,
        logout,
        googleLogin,
        guestLogin,
        customerLogin,
        customerSignup,
        customerGoogleLogin,
        updateUser,
        addLoyaltyPoints,
        refreshToken,
        setIsAuthenticated
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};
// Create a custom hook to use the auth context
const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
// Export all components and hooks from a single location
export { AuthContext, AuthProvider, useAuth };
</file>

<file path="src/context/TableContext.tsx">
import React, { createContext, useContext, useState, useEffect, useCallback, useRef } from 'react';
import { useParams, useNavigate, UNSAFE_NavigationContext } from 'react-router-dom';
import { TableInfo } from '@/types';
import { verifyTableStatus } from '@/api/menuService';
type SetTableInfoAction = TableInfo | ((prev: TableInfo) => TableInfo);
type TableContextType = TableInfo & {
  setTableInfo: (tableInfo: SetTableInfoAction) => void;
  clearTableInfo: () => void;
  isLoadingTable: boolean;
  tableVerified: boolean;
};
const defaultTableInfo: TableInfo = {
  tableNumber: '',
  restaurantName: 'InSeat',
  tableId: ''
};
const TableContext = createContext<TableContextType | undefined>(undefined);
export const TableProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  // Check if we're in a router context before using router hooks
  const navigation = React.useContext(UNSAFE_NavigationContext);
  const inRouterContext = navigation !== null;
  // State for table verification status
  const [isLoadingTable, setIsLoadingTable] = useState(false);
  const [tableVerified, setTableVerified] = useState(false);
  // Ref to track if initial load has happened
  const initialLoadComplete = useRef(false);
  // Only use router hooks if we're in a router context
  const params = inRouterContext ? useParams<{ tableId: string }>() : { tableId: undefined };
  const { tableId } = params;
  // Get navigate function once
  const navigate = inRouterContext ? useNavigate() : null;
  // Safe navigation function that only uses navigate when available
  const safeNavigate = useCallback((path: string) => {
    if (navigate) {
      navigate(path);
    } else {
      console.warn('Navigation attempted outside Router context');
    }
  }, [navigate]);
  // Helper function to ensure values are strings
  const ensureString = (value: any): string => {
    if (value === null || value === undefined) return '';
    if (typeof value === 'string') return value;
    if (typeof value === 'number') return value.toString();
    // If it's an object, return a meaningful string instead of [object Object]
    if (typeof value === 'object') {
      try {
        // If it has an id property, use that
        if (value.id) return value.id;
        // If it has a _id property (MongoDB style), use that
        if (value._id) return value._id;
        // Try to stringify it, but catch any circular references
        const stringified = JSON.stringify(value);
        if (stringified === '{}') return '';
        if (stringified.length < 30) return stringified;
        return '';
      } catch (e) {
        console.error('Error stringifying object:', e);
        return '';
      }
    }
    return String(value);
  };
  // Initialize with saved data or defaults
  const [tableInfo, setTableInfo] = useState<TableInfo>(() => {
    // Try to get table ID from URL search params first
    const urlParams = new URLSearchParams(window.location.search);
    const urlTableId = urlParams.get('table');
    // If found in URL, use it and store it
    if (urlTableId) {
      const newTableInfo = { 
        tableNumber: ensureString(urlTableId), 
        restaurantName: 'InSeat', 
        tableId: ensureString(urlTableId) 
      };
      localStorage.setItem('tableInfo', JSON.stringify(newTableInfo));
      sessionStorage.setItem('tableInfo', JSON.stringify(newTableInfo));
      return newTableInfo;
    }
    // Otherwise check localStorage and sessionStorage
    const sessionTableInfo = sessionStorage.getItem('tableInfo');
    const savedTableInfo = localStorage.getItem('tableInfo');
    // Try sessionStorage first (more recent)
    if (sessionTableInfo) {
      try {
        const parsed = JSON.parse(sessionTableInfo);
        // Ensure all values are strings
        return {
          tableNumber: ensureString(parsed.tableNumber),
          restaurantName: parsed.restaurantName || 'InSeat',
          tableId: ensureString(parsed.tableId)
        };
      } catch (e) {
        console.error('Error parsing session stored table info:', e);
        sessionStorage.removeItem('tableInfo');
      }
    }
    // Then try localStorage
    if (savedTableInfo) {
      try {
        const parsed = JSON.parse(savedTableInfo);
        // Ensure all values are strings
        return {
          tableNumber: ensureString(parsed.tableNumber),
          restaurantName: parsed.restaurantName || 'InSeat',
          tableId: ensureString(parsed.tableId)
        };
      } catch (e) {
        console.error('Error parsing local stored table info:', e);
        localStorage.removeItem('tableInfo');
      }
    }
    // Last resort: use from URL params or defaults
    return { 
      tableNumber: ensureString(tableId) || '', 
      restaurantName: 'InSeat', 
      tableId: ensureString(tableId) || '' 
    };
  });
  // Debounced localStorage update function
  const debouncedLocalStorageUpdate = useCallback((data: TableInfo) => {
    const timeoutId = setTimeout(() => {
      localStorage.setItem('tableInfo', JSON.stringify(data));
    }, 300);
    return () => clearTimeout(timeoutId);
  }, []);
  // Function to verify table exists
  const verifyTable = useCallback(async (id: string) => {
    if (!id) return false;
    try {
      setIsLoadingTable(true);
      console.log(`Verifying table ID: ${id}`);
      const result = await verifyTableStatus(id);
      setTableVerified(result.exists);
      if (result.exists && result.venue) {
        // Update restaurant name if available
        setTableInfo(prev => ({
          ...prev,
          restaurantName: result.venue?.name || prev.restaurantName
        }));
      }
      return result.exists;
    } catch (error) {
      console.error('Error verifying table:', error);
      setTableVerified(false);
      return false;
    } finally {
      setIsLoadingTable(false);
    }
  }, []);
  // Enhanced URL parameter handling for better persistence across redirects
  useEffect(() => {
    if (!inRouterContext) return;
    // Check URL parameters first (highest priority)
    const urlParams = new URLSearchParams(window.location.search);
    const urlTableId = urlParams.get('table');
    // Check localStorage for saved table information
    const savedTableInfo = localStorage.getItem('tableInfo');
    const parsedSavedInfo = savedTableInfo ? JSON.parse(savedTableInfo) : null;
    // Check sessionStorage for even more persistence
    const sessionTableInfo = sessionStorage.getItem('tableInfo');
    const parsedSessionInfo = sessionTableInfo ? JSON.parse(sessionTableInfo) : null;
    // Decision logic for which table ID to use
    let effectiveTableId = urlTableId;
    // If no table ID in URL but we have one in storage, use that
    if (!effectiveTableId) {
      // First try session storage for most recent value
      if (parsedSessionInfo && parsedSessionInfo.tableId) {
        effectiveTableId = parsedSessionInfo.tableId;
        console.log(`Restoring table ID from sessionStorage: ${effectiveTableId}`);
      }
      // Then try localStorage as fallback
      else if (parsedSavedInfo && parsedSavedInfo.tableId) {
        effectiveTableId = parsedSavedInfo.tableId;
        console.log(`Restoring table ID from localStorage: ${effectiveTableId}`);
      }
    }
    // Only update if we have a table ID and it's different from what we have
    if (effectiveTableId && effectiveTableId !== tableInfo.tableId && !isLoadingTable) {
      console.log(`Setting table info from effective source: ${effectiveTableId}`);
      const updatedInfo = {
        ...tableInfo,
        tableId: effectiveTableId,
        tableNumber: effectiveTableId
      };
      // Set in context
      setTableInfo(updatedInfo);
      // Store in both localStorage and sessionStorage for maximum persistence
      localStorage.setItem('tableInfo', JSON.stringify(updatedInfo));
      sessionStorage.setItem('tableInfo', JSON.stringify(updatedInfo));
      // Verify the table
      verifyTable(effectiveTableId);
      // If we're on a payment success page, redirect back to table page
      if (window.location.pathname.includes('/payment/success') || 
          window.location.pathname.includes('/payment/cancel')) {
        setTimeout(() => {
          safeNavigate(`/table/${effectiveTableId}`);
        }, 1000);
      }
    }
    // Mark initial load as complete
    initialLoadComplete.current = true;
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [inRouterContext, window.location.search, window.location.pathname]);
  // Clear table info - used when scanning new QR code
  const clearTableInfo = useCallback(() => {
    localStorage.removeItem('tableInfo');
    sessionStorage.removeItem('tableInfo');
    setTableInfo(defaultTableInfo);
    setTableVerified(false);
  }, []);
  // Helper function to update table info with optimization to prevent unnecessary updates
  const updateTableInfo = useCallback((tableInfoOrFunction: SetTableInfoAction) => {
    let newTableInfo: TableInfo;
    if (typeof tableInfoOrFunction === 'function') {
      setTableInfo(prev => {
        // Get the new table info by calling the function
        const rawNewTableInfo = tableInfoOrFunction(prev);
        // Sanitize the values to prevent [object Object]
        newTableInfo = {
          tableNumber: ensureString(rawNewTableInfo.tableNumber),
          restaurantName: rawNewTableInfo.restaurantName || 'InSeat',
          tableId: ensureString(rawNewTableInfo.tableId)
        };
        // Only update if something changed
        if (JSON.stringify(newTableInfo) !== JSON.stringify(prev)) {
          // Trigger table verification if table ID changed
          if (newTableInfo.tableId !== prev.tableId) {
            verifyTable(newTableInfo.tableId);
          }
          // Store in both localStorage and sessionStorage
          localStorage.setItem('tableInfo', JSON.stringify(newTableInfo));
          sessionStorage.setItem('tableInfo', JSON.stringify(newTableInfo));
          return newTableInfo;
        }
        return prev;
      });
    } else {
      // Sanitize the direct object values
      const sanitizedTableInfo = {
        tableNumber: ensureString(tableInfoOrFunction.tableNumber),
        restaurantName: tableInfoOrFunction.restaurantName || 'InSeat',
        tableId: ensureString(tableInfoOrFunction.tableId)
      };
      // Only update if something changed
      if (JSON.stringify(sanitizedTableInfo) !== JSON.stringify(tableInfo)) {
        newTableInfo = sanitizedTableInfo;
        setTableInfo(newTableInfo);
        // Store in both localStorage and sessionStorage
        localStorage.setItem('tableInfo', JSON.stringify(newTableInfo));
        sessionStorage.setItem('tableInfo', JSON.stringify(newTableInfo));
        // Trigger table verification if table ID changed
        if (newTableInfo.tableId !== tableInfo.tableId) {
          verifyTable(newTableInfo.tableId);
        }
      }
    }
  }, [tableInfo, verifyTable]);
  // On initial mount, verify table if we have an ID
  useEffect(() => {
    if (!initialLoadComplete.current && tableInfo.tableId) {
      verifyTable(tableInfo.tableId);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  return (
    <TableContext.Provider
      value={{
        ...tableInfo,
        setTableInfo: updateTableInfo,
        clearTableInfo,
        isLoadingTable,
        tableVerified
      }}
    >
      {children}
    </TableContext.Provider>
  );
};
export const useTableInfo = () => {
  const context = useContext(TableContext);
  if (context === undefined) {
    throw new Error('useTableInfo must be used within a TableProvider');
  }
  return context;
};
</file>

<file path="src/pages/CategoryDetail.tsx">
import React, { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import axios from 'axios';
import { ChevronLeft, Plus, AlertCircle } from 'lucide-react';
import { motion } from 'framer-motion';
import { Button } from '@/components/ui/button';
import { Drawer, DrawerContent, DrawerTrigger } from '@/components/ui/drawer';
import { cn } from '@/lib/utils';
import TableHeader from '@/components/TableHeader';
import MenuItemCard from '@/components/menu/MenuItemCard';
import { ItemDetailDrawer } from '@/components/ItemDetailDrawer';
// Removed import for local api service
import { Category, MenuItem, SubCategory } from '@/types/menu';
import { API_BASE_URL } from '@/constants';
import { useTableInfo } from '@/context/TableContext';
const CategoryDetail: React.FC = () => {
  const { categoryId } = useParams<{ categoryId: string }>();
  const navigate = useNavigate();
  const { tableId, restaurantName } = useTableInfo();
  const [selectedSubCategory, setSelectedSubCategory] = useState<string | null>(null);
  const [selectedItem, setSelectedItem] = useState<MenuItem | null>(null);
  const [drawerOpen, setDrawerOpen] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  // Get table ID from URL query params
  useEffect(() => {
    const queryParams = new URLSearchParams(window.location.search);
    const tableParam = queryParams.get('table');
    if (tableParam) {
      console.log('Setting tableId from URL:', tableParam);
      // Removed setting tableId from URL
    } else {
      console.warn('No table ID found in URL');
    }
  }, []);
  // Debug log to ensure tableId is being set correctly
  useEffect(() => {
    console.log('Current tableId state:', tableId);
  }, [tableId]);
  // We'll use a more reliable approach for demo - hard code the category data
  // In a real app you'd fetch this from the API but for reliability in demo we hardcode
  const categoryMap = {
    '681a585c1a12c59b214b3acc': {
      _id: '681a585c1a12c59b214b3acc',
      name: 'Popcorn & Snacks',
      description: 'Cinema classics and movie munchies',
      image: 'https://images.pexels.com/photos/2983098/pexels-photo-2983098.jpeg',
      isActive: true
    },
    '681a585d1a12c59b214b3ada': {
      _id: '681a585d1a12c59b214b3ada',
      name: 'Beverages',
      description: 'Refreshing drinks for your movie',
      image: 'https://images.pexels.com/photos/2983098/pexels-photo-2983098.jpeg',
      isActive: true
    },
    '681a585f1a12c59b214b3ae8': {
      _id: '681a585f1a12c59b214b3ae8',
      name: 'Meals',
      description: 'Substantial food options for cinema dining',
      image: 'https://images.pexels.com/photos/2955819/pexels-photo-2955819.jpeg',
      isActive: true
    }
  };
  // Fetch category details - with hardcoded fallback for reliability
  const { data: category, isLoading: isCategoryLoading } = useQuery({
    queryKey: ['category', categoryId],
    queryFn: async () => {
      if (!categoryId) {
        setError("No category ID provided");
        throw new Error("No category ID provided");
      }
      try {
        // First check our hardcoded data (for reliability)
        if (categoryMap[categoryId]) {
          console.log('Using hardcoded category data for demo');
          return categoryMap[categoryId];
        }
        // If not in our hardcoded data, try the API
        if (tableId) {
          const response = await axios.get<Category>(
            `${API_BASE_URL}/categories/${categoryId}`,
            { timeout: 5000 }
          );
          console.log('Category fetched from API:', response.data);
          return response.data;
        } else {
          setError("Missing table information");
          throw new Error("Missing table information");
        }
      } catch (error) {
        console.error("Error fetching category data:", error);
        // Last resort - if we have the categoryId in our map,
        // return it even if the API call failed
        if (categoryMap[categoryId]) {
          return categoryMap[categoryId];
        }
        setError("Failed to load category data. Please try again later.");
        throw error;
      }
    },
    enabled: !!categoryId,
    retry: 1,
  });
  // Fetch subcategories if needed
  const { data: subCategories = [] } = useQuery({
    queryKey: ['subcategories', categoryId, tableId],
    queryFn: async () => {
      if (tableId) {
        try {
          const response = await axios.get<SubCategory[]>(
            `${API_BASE_URL}/subcategories?categoryId=${categoryId}`
          );
          return response.data;
        } catch (error) {
          console.error("Error fetching subcategories:", error);
          return [];
        }
      }
      return [];
    },
    enabled: !!categoryId && !!tableId && !error,
  });
  // Fetch menu items
  const { data: menuItems = [], isLoading: isItemsLoading } = useQuery({
    queryKey: ['menuItemsByCategory', categoryId, selectedSubCategory, tableId],
    queryFn: async () => {
      if (tableId) {
        try {
          // Construct query params for API
          const params = new URLSearchParams();
          if (categoryId) params.append('categoryId', categoryId);
          if (selectedSubCategory) params.append('subCategoryId', selectedSubCategory);
          const response = await axios.get<MenuItem[]>(
            `${API_BASE_URL}/menu-items?${params.toString()}`
          );
          return response.data;
        } catch (error) {
          console.error("Error fetching menu items:", error);
          return [];
        }
      } else {
        // No tableId, return empty array
        console.error("Missing table information for menu items");
        return [];
      }
    },
    enabled: !!categoryId && !!tableId && !error,
  });
  // Get venue information from the context
  // Fallback to 'Screen 3' if not available
  const handleBack = () => {
    navigate(tableId ? `/?table=${tableId}` : '/');
  };
  const handleSubCategorySelect = (subCategoryId: string) => {
    setSelectedSubCategory(subCategoryId === selectedSubCategory ? null : subCategoryId);
  };
  const handleSelectItem = (item: MenuItem) => {
    setSelectedItem(item);
    setDrawerOpen(true);
  };
  const handleCloseDrawer = () => {
    setDrawerOpen(false);
    // Allow some time for the drawer animation before clearing the selected item
    setTimeout(() => setSelectedItem(null), 300);
  };
  // Show error state if category not found
  if (error) {
    return (
      <div className="min-h-screen p-4 flex flex-col items-center justify-center">
        <div className="bg-red-50 dark:bg-red-900/20 p-6 rounded-lg max-w-md text-center">
          <div className="mx-auto flex h-16 w-16 flex-shrink-0 items-center justify-center rounded-full bg-red-100 dark:bg-red-900/30 mb-4">
            <AlertCircle className="h-8 w-8 text-red-600 dark:text-red-400" aria-hidden="true" />
          </div>
          <h2 className="text-xl font-bold mb-4">Category not found</h2>
          <p className="text-muted-foreground mb-6">{error}</p>
          <Button variant="default" onClick={handleBack}>
            Back to Categories
          </Button>
        </div>
      </div>
    );
  }
  if (isCategoryLoading) {
    console.log('Category data is loading');
    return (
      <div className="min-h-screen p-4 flex justify-center items-center">
        <div className="animate-pulse space-y-4 max-w-md w-full">
          <div className="h-8 bg-muted rounded w-48 mb-4"></div>
          <div className="h-8 bg-muted rounded w-32"></div>
          <div className="h-64 bg-muted rounded w-full"></div>
        </div>
      </div>
    );
  }
  // Log the category data to help debug
  console.log('Rendering with category data:', category);
  if (!category) {
    return (
      <div className="min-h-screen p-4 flex flex-col items-center justify-center">
        <div className="bg-amber-50 dark:bg-amber-900/20 p-6 rounded-lg max-w-md text-center">
          <h2 className="text-xl font-bold mb-4">Unable to load category</h2>
          <p className="text-muted-foreground mb-6">The requested category could not be loaded. Please try again later.</p>
          <Button variant="secondary" onClick={handleBack}>
            Back to Categories
          </Button>
        </div>
      </div>
    );
  }
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      className="min-h-screen pb-24"
    >
      {/* TableHeader for consistent experience */}
      <TableHeader 
        venueName={restaurantName || 'Screen 3'} 
        className="bg-[#16141F] text-white"
      />
      {/* Category Header */}
      <div 
        className="relative h-40 bg-cover bg-center flex items-end mt-14" 
        style={{ 
          backgroundImage: `linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.5)), url(${category.image})` 
        }}
      >
        <Button
          variant="ghost"
          className="absolute top-4 left-4 text-white bg-black/30 hover:bg-black/40 p-2 rounded-full" 
          onClick={handleBack}
          aria-label="Back"
        >
          <ChevronLeft className="h-5 w-5" />
        </Button>
        <div className="p-6 text-white w-full">
          <h1 className="text-2xl font-bold">{category.name}</h1>
          <p className="text-sm opacity-90">{menuItems.length} Items</p>
        </div>
      </div>
      {/* Subcategories horizontal scroll */}
      {subCategories.length > 0 && (
        <div className="p-4 overflow-x-auto">
          <div className="flex gap-2 pb-2">
            {subCategories.map((subCategory) => (
              <Button
                key={subCategory._id}
                variant={selectedSubCategory === subCategory._id ? "default" : "outline"}
                className="rounded-full whitespace-nowrap"
                onClick={() => handleSubCategorySelect(subCategory._id)}
              >
                {subCategory.name}
              </Button>
            ))}
          </div>
        </div>
      )}
      {/* Menu Items - Grid with 2 columns for all screen sizes */}
      <div className="container mx-auto p-4">
        {isItemsLoading ? (
          <div className="grid grid-cols-2 gap-3">
            {[1, 2, 3, 4].map((i) => (
              <div key={i} className="animate-pulse">
                <div className="aspect-video bg-muted rounded mb-2"></div>
                <div className="h-4 bg-muted rounded w-3/4 mb-2"></div>
                <div className="h-4 bg-muted rounded w-1/2"></div>
              </div>
            ))}
          </div>
        ) : menuItems.length > 0 ? (
          <div className="grid grid-cols-2 gap-3">
            {menuItems.map((item) => (
              <div key={item.id} className="relative group">
                <MenuItemCard 
                  item={item} 
                  onClick={() => handleSelectItem(item)}
                />
                <Button 
                  variant="default"
                  size="icon" 
                  className="absolute bottom-2 right-2 h-8 w-8 rounded-full bg-purple-600 hover:bg-purple-700 transition-opacity"
                  onClick={(e) => {
                    e.stopPropagation();
                    handleSelectItem(item);
                  }}
                >
                  <Plus className="h-4 w-4" />
                </Button>
              </div>
            ))}
          </div>
        ) : (
          <div className="text-center py-8">
            <p className="text-muted-foreground">No items found in this category</p>
            <Button
              variant="outline"
              className="mt-4"
              onClick={handleBack}
            >
              Back to Categories
            </Button>
          </div>
        )}
      </div>
      {/* Item Detail Drawer */}
      <Drawer 
        open={drawerOpen} 
        onOpenChange={setDrawerOpen}
        onClose={handleCloseDrawer}
      >
        <DrawerContent className="h-[80vh]">
          {selectedItem && (
            <ItemDetailDrawer 
              item={selectedItem} 
              onClose={handleCloseDrawer}
            />
          )}
        </DrawerContent>
      </Drawer>
    </motion.div>
  );
};
export default CategoryDetail;
</file>

<file path="src/pages/Login.tsx">
import React, { useState } from 'react';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { ArrowLeft, Loader2, User } from 'lucide-react';
import { Card, CardHeader, CardContent, CardFooter } from '@/components/ui/card';
import { useAuth } from '@/context/AuthContext';
import { toast } from 'sonner';
const Login: React.FC = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { login, googleLogin, customerLogin, customerGoogleLogin, guestLogin } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    try {
      // Get table ID from location state or localStorage
      const locationState = location.state as { returnUrl?: string; tableId?: string } | null;
      const tableIdFromState = locationState?.tableId;
      const currentTableId = localStorage.getItem('currentTableId');
      const tableInfoStr = localStorage.getItem('tableInfo');
      let tableInfo;
      try {
        if (tableInfoStr) {
          tableInfo = JSON.parse(tableInfoStr);
        }
      } catch (e) {
        console.error('Error parsing tableInfo:', e);
      }
      // Use the first available table ID
      const effectiveTableId = tableIdFromState || currentTableId || (tableInfo?.id) || '';
      console.log('Login with table context:', {
        tableIdFromState,
        currentTableId,
        tableInfoFromStorage: tableInfo?.id,
        effectiveTableId
      });
      // Store table ID in all possible locations for maximum compatibility
      if (effectiveTableId) {
        localStorage.setItem('currentTableId', effectiveTableId);
        localStorage.setItem('tableInfo', JSON.stringify({ id: effectiveTableId }));
        console.log('Stored table ID in localStorage before login:', effectiveTableId);
      }
      // First try customer-specific login endpoint
      const customerSuccess = await customerLogin(email, password);
      if (customerSuccess) {
        // Check if we have a return URL from the state
        const returnUrl = locationState?.returnUrl;
        if (returnUrl && returnUrl !== '/login') {
          console.log(`Redirecting to return URL: ${returnUrl}`);
          navigate(returnUrl);
        } else if (effectiveTableId) {
          // If we have a table ID, redirect to the table page
          console.log(`Redirecting to table page with ID: ${effectiveTableId}`);
          navigate(`/?table=${effectiveTableId}`);
        } else {
          // Default success page
          navigate('/login/success');
        }
        return;
      }
      // Fall back to regular login if customer login fails
      // This maintains backward compatibility
      const regularSuccess = await login(email, password);
      if (regularSuccess) {
        // Similar redirection logic for regular login
        const returnUrl = locationState?.returnUrl;
        if (returnUrl && returnUrl !== '/login') {
          navigate(returnUrl);
        } else if (effectiveTableId) {
          navigate(`/?table=${effectiveTableId}`);
        } else {
          navigate('/login/success');
        }
      }
    } finally {
      setIsSubmitting(false);
    }
  };
  const handleGoogleLogin = () => {
    googleLogin(); // Directly call the regular Google login
  };
  const handleGuestContinue = async () => {
    setIsSubmitting(true);
    try {
      // Get table ID from local storage (if previously scanned)
      const tableId = localStorage.getItem('tableId');
      // Call guestLogin function to create a guest token
      const success = await guestLogin(tableId || undefined);
      if (success) {
        toast.success('Continuing as guest');
        navigate('/');
      } else {
        toast.error('Failed to create guest session');
      }
    } catch (error) {
      console.error('Error creating guest session:', error);
      toast.error('Failed to create guest session');
    } finally {
      setIsSubmitting(false);
    }
  };
  return (
    <div className="container min-h-screen flex items-center justify-center px-6">
      <div className="w-full max-w-md space-y-6">
        <div className="space-y-2 text-center">
          <div className="w-14 h-14 bg-purple-100 dark:bg-purple-900/30 rounded-full flex items-center justify-center mx-auto mb-2">
            <User className="h-6 w-6 text-purple-600 dark:text-purple-400" />
          </div>
          <h1 className="text-2xl font-semibold text-white">Welcome Back</h1>
          <p className="text-purple-200">Log in to access your loyalty points and order history</p>
        </div>
        <form onSubmit={handleLogin}>
          <div className="space-y-4 pt-4">
            <div className="space-y-2">
              <Label htmlFor="email" className="text-sm">Email</Label>
              <Input 
                id="email" 
                type="email" 
                placeholder="your.email@example.com" 
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className="bg-background border-border"
              />
            </div>
            <div className="space-y-2">
              <div className="flex justify-between items-center">
                <Label htmlFor="password" className="text-sm">Password</Label>
                <Button 
                  variant="link" 
                  className="text-xs p-0 h-auto text-purple-400 hover:text-purple-300"
                  type="button"
                  onClick={() => toast.info('Password reset functionality would be implemented here')}
                >
                  Forgot password?
                </Button>
              </div>
              <Input 
                id="password" 
                type="password" 
                placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢" 
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="bg-background border-border"
              />
            </div>
            <Button 
              type="submit" 
              className="w-full bg-purple-600 hover:bg-purple-700 text-white font-medium"
              disabled={isSubmitting}
            >
              {isSubmitting ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Logging in...
                </>
              ) : (
                'Log In'
              )}
            </Button>
            <div className="relative">
              <div className="absolute inset-0 flex items-center">
                <div className="w-full border-t border-purple-500/20"></div>
              </div>
              <div className="relative flex justify-center text-sm">
                <span className="px-2 bg-[#16141F] text-purple-300">Or continue with</span>
              </div>
            </div>
            <Button 
              type="button" 
              variant="outline" 
              className="w-full mb-3 text-sm bg-white/5 border-purple-500/20 text-white hover:bg-white/10 hover:border-purple-500/30"
              onClick={handleGoogleLogin}
              disabled={isSubmitting}
            >
              <img 
                src="/google_g_logo.svg" 
                alt="Google logo" 
                className="mr-2 h-5 w-5" 
                onError={(e) => {
                  // Fallback to a reliable CDN if local file is not available
                  e.currentTarget.src = "https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg";
                }}
              />
              Sign in with Google
            </Button>
            <Button 
              type="button"
              variant="outline" 
              className="w-full mb-3 text-sm bg-purple-600/10 border-purple-500/30 text-purple-200 hover:bg-purple-600/20 hover:border-purple-500/50"
              onClick={handleGuestContinue}
              disabled={isSubmitting}
            >
              {isSubmitting ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Creating guest session...
                </>
              ) : (
                'Continue as Guest'
              )}
            </Button>
          </div>
        </form>
        <div className="flex flex-col items-center space-y-4 mt-6">
          <p className="text-center text-purple-200 text-sm">
            Don't have an account?{' '}
            <Link to="/signup" className="text-purple-400 hover:text-white font-semibold hover:underline">
              Sign up now
            </Link>
          </p>
          <div className="w-full p-4 bg-purple-600/10 backdrop-blur-sm rounded-xl border border-purple-500/20 text-sm">
            <div className="flex items-start space-x-3">
              <div className="p-2 bg-purple-500/20 rounded-lg">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-purple-400">
                  <path d="M12 2v4"></path>
                  <path d="m16 6 3 3"></path>
                  <path d="M18 12h4"></path>
                  <path d="m6 20.7 3.5-3.5c.2-.2.4-.2.6-.2.2 0 .4.1.6.2l2.6 2.6c.2.2.5.2.7 0l2.6-2.6c.2-.2.4-.2.6-.2.2 0 .4.1.6.2l3.5 3.5"></path>
                  <path d="m8 16.3-3.5-3.5c-.2-.2-.4-.2-.6-.2-.2 0-.4.1-.6.2l-2.6 2.6c-.2.2-.5.2-.7 0l-2.6-2.6c-.2-.2-.4-.2-.6-.2-.2 0-.4.1-.6.2l-3.5 3.5"></path>
                  <path d="M2 12h4"></path>
                  <path d="m6 6-3-3"></path>
                </svg>
              </div>
              <div>
                <p className="font-semibold text-purple-200">Join our Loyalty Program</p>
                <p className="text-purple-300/90 text-xs mt-1">Earn points with every order and unlock exclusive rewards!</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};
export default Login;
</file>

<file path="src/pages/MyOrders.tsx">
import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { useAuth } from '@/context/AuthContext';
import { ClipboardList, Clock, ChevronRight, CheckCircle2, Loader2, AlertTriangle, RefreshCw } from 'lucide-react';
import { getEffectiveToken } from '@/api/authService';
import apiClient from '@/api/apiClient';
import { Badge } from '@/components/ui/badge';
import { Link, useNavigate } from 'react-router-dom';
import TableHeader from '@/components/TableHeader';
import { useTableInfo } from '@/context/TableContext';
import { fetchUserOrders, cancelOrder, updatePaymentStatus } from '@/api/orderService';
import { PaymentStatus } from '@/types/Order';
import { toast } from 'sonner';
import { formatDistanceToNow } from 'date-fns';
import { useOrders } from '@/context/OrdersContext';
import { Skeleton } from '@/components/ui/skeleton';
// Format date to relative time
const formatRelativeTime = (dateString: string) => {
  try {
    return formatDistanceToNow(new Date(dateString), { addSuffix: true });
  } catch (error) {
    return 'Unknown date';
  }
};
// Status badge component
const StatusBadge: React.FC<{ status: string }> = ({ status }) => {
  switch (status?.toLowerCase()) {
    case 'pending':
      return <Badge className="bg-amber-500 hover:bg-amber-600">Pending</Badge>;
    case 'processing':
    case 'preparing':
      return <Badge className="bg-purple-600 hover:bg-purple-700">Preparing</Badge>;
    case 'ready':
      return <Badge className="bg-blue-600 hover:bg-blue-700">Ready</Badge>;
    case 'delivered':
      return <Badge className="bg-green-600 hover:bg-green-700">Delivered</Badge>;
    case 'completed':
      return <Badge className="bg-green-600 hover:bg-green-700">Completed</Badge>;
    case 'cancelled':
      return <Badge className="bg-destructive hover:bg-destructive/90">Cancelled</Badge>;
    default:
      return <Badge className="bg-gray-600 hover:bg-gray-700">{status}</Badge>;
  }
};
const PaymentStatusBadge: React.FC<{ status: string }> = ({ status }) => {
  switch (status?.toLowerCase()) {
    case 'paid':
      return <Badge className="bg-green-600 hover:bg-green-700">Paid</Badge>;
    case 'pending':
      return <Badge className="bg-amber-500 hover:bg-amber-600">Payment Pending</Badge>;
    case 'failed':
      return <Badge className="bg-destructive hover:bg-destructive/90">Payment Failed</Badge>;
    case 'refunded':
      return <Badge className="bg-blue-600 hover:bg-blue-700">Refunded</Badge>;
    default:
      return null;
  }
};
const MyOrders: React.FC = () => {
  const { isAuthenticated, token, isLoading } = useAuth();
  const { tableId, restaurantName } = useTableInfo();
  const { orders: contextOrders } = useOrders();
  const navigate = useNavigate();
  const [orders, setOrders] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [cancellingOrderId, setCancellingOrderId] = useState<string | null>(null);
  const [processingPaymentOrderId, setProcessingPaymentOrderId] = useState<string | null>(null);
  // Order card skeleton component
  const OrderCardSkeleton = () => (
    <div className="p-4 rounded-xl bg-[#1F1D2B]/70 border border-purple-500/10 backdrop-blur-sm mb-4">
      <div className="flex justify-between items-start mb-4">
        <div>
          <div className="flex items-center gap-2 mb-1">
            <Skeleton className="h-5 w-32" />
            <Skeleton className="h-6 w-20" />
          </div>
          <div className="flex items-center mt-1">
            <Skeleton className="h-4 w-24" />
          </div>
        </div>
        <Skeleton className="h-6 w-16" />
      </div>
      <div className="space-y-2.5 mb-4 border-t border-purple-500/10 pt-3">
        <div className="flex justify-between text-sm">
          <Skeleton className="h-4 w-40" />
          <Skeleton className="h-4 w-16" />
        </div>
        <div className="flex justify-between text-sm">
          <Skeleton className="h-4 w-32" />
          <Skeleton className="h-4 w-16" />
        </div>
        <div className="flex justify-between text-sm">
          <Skeleton className="h-4 w-36" />
          <Skeleton className="h-4 w-16" />
        </div>
      </div>
      <div className="flex gap-2 mt-3 pt-3 border-t border-purple-500/10">
        <Skeleton className="h-9 w-full" />
      </div>
    </div>
  );
  // Fetch orders on component mount
  useEffect(() => {
    const loadOrders = async () => {
      try {
        // Don't load orders if still checking authentication
        if (isLoading) {
          return;
        }
        // Check authentication state
        if (!isAuthenticated) {
          console.log('Not authenticated, redirecting to login');
          navigate('/login', { state: { returnUrl: '/my-orders' } });
          setLoading(false);
          return;
        }
        // Always set loading to true first and clear previous orders
        setLoading(true);
        setOrders([]);
        setError(null);
        // Use apiClient instead of direct fetch
        const response = await apiClient.get('/api/orders/my-orders');
        // Response will already be JSON parsed by axios
        const responseData = response.data;
        // Handle different response formats
        let ordersData = [];
        if (Array.isArray(responseData)) {
          ordersData = responseData;
        } else if (responseData.orders && Array.isArray(responseData.orders)) {
          ordersData = responseData.orders;
        } else if (responseData.data && responseData.data.orders && Array.isArray(responseData.data.orders)) {
          ordersData = responseData.data.orders;
        }
        console.log(`Fetched ${ordersData.length} orders from API`);
        // Format orders with proper types and defaults
        const formattedOrders = ordersData.map((order: any) => ({
          ...order,
          _id: order._id || order.id || `order-${Math.random().toString(36).substr(2, 9)}`,
          orderNumber: order.orderNumber || `ORD-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
          totalAmount: order.total || order.totalAmount || 0,
          items: order.items || [],
          status: order.status || 'PENDING',
          paymentStatus: order.paymentStatus || 'PENDING',
          createdAt: order.createdAt || new Date().toISOString(),
          updatedAt: order.updatedAt || new Date().toISOString()
        }));
        // Update state with the fetched orders
        setOrders(formattedOrders);
        // If no orders found, show a message
        if (formattedOrders.length === 0) {
          console.log('No orders found for this user');
        }
      } catch (err) {
        console.error('Error loading orders:', err);
        // Handle authentication errors
        if (err.response?.status === 401) {
          console.log('Authentication failed, redirecting to login');
          navigate('/login', { state: { returnUrl: '/my-orders' } });
          return;
        }
        setError(err instanceof Error ? err.message : 'Failed to load orders');
      } finally {
        setLoading(false);
      }
    };
    loadOrders();
  }, [navigate, isAuthenticated, isLoading]);
  // Handle post-login payment processing
  useEffect(() => {
    const processPendingPayment = async () => {
      const pendingOrderId = localStorage.getItem('pendingPaymentOrderId');
      if (pendingOrderId && token) {
        localStorage.removeItem('pendingPaymentOrderId');
        handlePayOrder(pendingOrderId);
      }
    };
    processPendingPayment();
  }, [token]); // Run when token changes
  // We're now always fetching from API, so we don't need to use context orders
  // Remove this effect to prevent showing stale data during loading
  // Handle order payment using Stripe Checkout
  const handlePayOrder = async (orderId: string) => {
    try {
      // Get token using authService's getEffectiveToken
      const token = getEffectiveToken();
      if (!token) {
        // Save order ID for after login
        localStorage.setItem('pendingPaymentOrderId', orderId);
        // Redirect to login
        navigate('/login', { 
          state: { 
            from: '/my-orders',
            orderId 
          } 
        });
        return;
      }
      setProcessingPaymentOrderId(orderId);
      console.log('Payment requested for order ID:', orderId);
      // Find the order to pay
      const orderToPay = orders.find(order => order.id === orderId || order._id === orderId);
      if (!orderToPay) {
        toast.error('Order not found');
        return;
      }
      // Use the _id field if it exists (MongoDB ObjectId) or fall back to id
      const effectiveOrderId = orderToPay._id || orderToPay.id || orderId;
      console.log('Using effective order ID for payment:', effectiveOrderId);
      try {
        // Extract required data from the order for the checkout session
        const cartItems = orderToPay.items || [];
        const tableId = orderToPay.tableId || '';
        const restaurantId = orderToPay.restaurantId || '';
        // Format line items for Stripe - this is the expected format for the backend
        const lineItems = cartItems.map(item => {
          // Calculate the total price including modifiers
          const modifierPrice = item.modifiers 
            ? item.modifiers.reduce((sum, mod) => sum + mod.price, 0) 
            : 0;
          const totalItemPrice = (item.price + modifierPrice) * 100; // Convert to cents for Stripe
          // Format description including modifiers
          let description = item.name;
          if (item.modifiers && item.modifiers.length > 0) {
            const modifierNames = item.modifiers.map(mod => mod.name).join(', ');
            description += ` with ${modifierNames}`;
          }
          if (item.specialInstructions) {
            description += `. Note: ${item.specialInstructions}`;
          }
          return {
            price_data: {
              currency: 'usd',
              product_data: {
                name: item.name,
                description: description,
                images: item.image ? [item.image] : undefined
              },
              unit_amount: totalItemPrice // Amount in cents
            },
            quantity: item.quantity
          };
        });
        console.log('Creating checkout session with:', {
          lineItems: lineItems.length,
          tableId,
          restaurantId,
          orderId: effectiveOrderId
        });
        // Create Stripe checkout session using apiClient
        const response = await apiClient.post('/api/payments/create-checkout-session', {
          lineItems,
          tableId,
          restaurantId,
          orderId: effectiveOrderId, // Pass this for reference
          successUrl: `${window.location.origin}/payment/success?order_id=${effectiveOrderId}`,
          cancelUrl: `${window.location.origin}/payment/cancel?order_id=${effectiveOrderId}`
        });
        if (!response.data.success) {
          throw new Error(response.data.error?.message || 'Failed to create payment session');
        }
        // Store the session information
        if (response.data.sessionId) {
          localStorage.setItem('stripeSessionId', response.data.sessionId);
          localStorage.setItem('currentPaymentOrderId', effectiveOrderId);
        }
        // Redirect to Stripe checkout
        if (response.data.url) {
          window.location.href = response.data.url;
        } else {
          throw new Error('No checkout URL received');
        }
      } catch (error) {
        console.error('Payment session creation failed:', error);
        if (error.response?.status === 401) {
          toast.error('Please log in again to complete payment');
          navigate('/login', { 
            state: { 
              from: '/my-orders',
              orderId 
            } 
          });
          return;
        }
        // If Stripe is not available, try direct payment update
        // Don't update payment status here - webhook will handle this
        toast.error('Payment service is currently unavailable. Please try again later.');
        // Log for debugging purposes
        console.log('Falling back to manual payment flow is disabled - payment should be processed by Stripe');
      }
    } catch (err) {
      console.error('Error processing payment:', err);
      // Check if error is due to authentication
      if (err.response?.status === 401) {
        toast.error('Please log in again to complete payment');
        navigate('/login', { 
          state: { 
            from: '/my-orders',
            orderId 
          } 
        });
        return;
      }
      toast.error('Failed to process payment. Please try again.');
    } finally {
      setProcessingPaymentOrderId(null);
    }
  };
  // Handle order cancellation
  const handleCancelOrder = async (orderId: string) => {
    try {
      // Check authentication using getEffectiveToken
      const token = getEffectiveToken();
      if (!token) {
        console.log('No token found, redirecting to login');
        navigate('/login', { 
          state: { 
            returnUrl: '/my-orders',
            orderId 
          } 
        });
        return;
      }
      setCancellingOrderId(orderId);
      // Use apiClient for cancellation
      await apiClient.post(`/api/orders/${orderId}/cancel`);
      // Refresh orders after cancellation using apiClient
      const response = await apiClient.get('/api/orders/my-orders');
      // Handle different response formats
      let ordersData = [];
      if (Array.isArray(response.data)) {
        ordersData = response.data;
      } else if (response.data.orders) {
        ordersData = response.data.orders;
      } else if (response.data.data?.orders) {
        ordersData = response.data.data.orders;
      }
      setOrders(ordersData);
      toast.success('Order cancelled successfully');
    } catch (err) {
      console.error('Error cancelling order:', err);
      // Handle authentication errors
      if (err.response?.status === 401) {
        toast.error('Please log in again to cancel the order');
        navigate('/login', { 
          state: { 
            returnUrl: '/my-orders',
            orderId 
          } 
        });
        return;
      }
      setError('Failed to cancel order. Please try again.');
      toast.error('Failed to cancel order');
    } finally {
      setCancellingOrderId(null);
    }
  };
  // Refresh orders
  const refreshOrders = async () => {
    try {
      // Check authentication using getEffectiveToken
      const token = getEffectiveToken();
      if (!token) {
        console.log('No token found, redirecting to login');
        navigate('/login', { state: { returnUrl: '/my-orders' } });
        return;
      }
      setLoading(true);
      const response = await apiClient.get('/api/orders/my-orders');
      // Handle different response formats
      let ordersData = [];
      if (Array.isArray(response.data)) {
        ordersData = response.data;
      } else if (response.data.orders) {
        ordersData = response.data.orders;
      } else if (response.data.data?.orders) {
        ordersData = response.data.data.orders;
      }
      setOrders(ordersData);
      setError(null);
    } catch (err) {
      console.error('Error refreshing orders:', err);
      // Handle authentication errors
      if (err.response?.status === 401) {
        console.log('Authentication failed, redirecting to login');
        navigate('/login', { state: { returnUrl: '/my-orders' } });
        return;
      }
      setError('Failed to refresh orders. Please try again.');
      toast.error('Failed to refresh orders');
    } finally {
      setLoading(false);
    }
  };
  // Show loading state while checking authentication
  if (isLoading) {
    return (
      <div className="min-h-screen bg-[#16141F] text-white animate-fade-in pb-20">
        <TableHeader 
          venueName={restaurantName || 'Restaurant'}
          className="bg-[#16141F] text-white"
        />
        <div className="container px-4 py-8 mt-16 animate-fade-in">
          <div className="text-center py-16">
            <p className="text-gray-400">Loading...</p>
          </div>
        </div>
      </div>
    );
  }
  return (
    <div className="min-h-screen bg-[#16141F] text-white animate-fade-in pb-20">
      {/* Use the same TableHeader as the menu page */}
      <TableHeader 
        venueName={restaurantName || 'Restaurant'}
        className="bg-[#16141F] text-white"
      />
      <div className="container px-4 py-8 mt-16 animate-fade-in">
        <div className="flex items-center justify-between mb-6">
          <h1 className="text-2xl font-bold">My Orders</h1>
          <Button 
            variant="outline" 
            className="border-purple-600 text-purple-400 hover:bg-purple-600/10 hover:text-purple-300 transition-colors"
            onClick={refreshOrders}
            disabled={loading}
          >
            <RefreshCw size={16} className={`mr-2 ${loading ? 'animate-spin' : ''}`} />
            <span>Refresh</span>
          </Button>
        </div>
        {loading ? (
          // Show skeleton loaders while loading
          <div className="space-y-4">
            {[...Array(3)].map((_, index) => (
              <OrderCardSkeleton key={`skeleton-${index}`} />
            ))}
          </div>
        ) : error ? (
          <div className="bg-destructive/20 border border-destructive text-destructive p-4 rounded-xl mb-6">
            <div className="flex items-center">
              <AlertTriangle className="h-5 w-5 mr-2" />
              <p>{typeof error === 'string' ? error : 'Failed to load orders'}</p>
            </div>
          </div>
        ) : orders.length === 0 ? (
          <div className="text-center py-16">
            <p className="text-gray-400 mb-4">You don't have any orders yet</p>
            <Button 
              className="bg-delft-blue hover:bg-delft-blue/90 text-white"
              onClick={() => navigate('/')}
            >
              Browse Menu
            </Button>
          </div>
        ) : (
          <div className="space-y-4">
            {orders.map(order => (
              <div 
                key={order._id} 
                className="bg-[#1F1D2B] border border-purple-500/20 rounded-xl p-5 animate-slide-up shadow-lg hover:shadow-purple-500/10 transition-all duration-300"
              >
                <div className="flex justify-between items-start mb-4">
                  <div>
                    <div className="flex items-center gap-2 mb-1">
                      <h3 className="font-medium text-purple-100">Order #{order._id ? order._id.slice(-6) : order.orderNumber || "Unknown"}</h3>
                      <StatusBadge status={order.status} />
                    </div>
                    <p className="text-sm text-purple-300/80 flex items-center mt-1">
                      <Clock className="h-3.5 w-3.5 mr-1.5 text-purple-400/70" />
                      {formatRelativeTime(order.createdAt)}
                    </p>
                  </div>
                  <span className="font-bold text-lg bg-gradient-to-r from-purple-500 to-purple-600 bg-clip-text text-transparent">
                    ${(order.totalAmount || order.total || 0).toFixed(2)}
                  </span>
                </div>
                <div className="space-y-2.5 mb-4 border-t border-purple-500/10 pt-3">
                  {order.items && order.items.slice(0, 3).map((item: any, idx: number) => (
                    <div key={idx} className="flex justify-between text-sm group">
                      <span className="text-purple-100 group-hover:text-white transition-colors">
                        {item.quantity}Ã— {item.name}
                      </span>
                      <span className="text-purple-300 font-medium">
                        ${((item.price || 0) * (item.quantity || 1)).toFixed(2)}
                      </span>
                    </div>
                  ))}
                  {order.items && order.items.length > 3 && (
                    <p className="text-sm text-gray-400">
                      +{order.items.length - 3} more items
                    </p>
                  )}
                  {/* Payment status as text */}
                  {order.paymentStatus && (
                    <div className="flex justify-between items-center text-sm mt-2 pt-2 border-t border-purple-500/10">
                      <span className="text-gray-400">Payment Status</span>
                      <span className={`font-medium ${order.paymentStatus.toLowerCase() === 'paid' ? 'text-purple-400' : 
                        order.paymentStatus.toLowerCase() === 'failed' ? 'text-red-400' : 
                        order.paymentStatus.toLowerCase() === 'refunded' ? 'text-blue-400' : 'text-amber-400'}`}>
                        {order.paymentStatus}
                      </span>
                    </div>
                  )}
                </div>
                <div className="flex items-center justify-between border-t border-purple-500/10 pt-3">
                  <Button 
                    variant="link" 
                    className="p-0 h-auto text-purple-400 hover:text-purple-300 transition-colors"
                    onClick={() => navigate('/order-confirmation', { state: { orderId: order._id } })}
                  >
                    <span className="flex items-center">
                      View Details
                      <ChevronRight className="h-4 w-4 ml-1" />
                    </span>
                  </Button>
                  <div className="flex gap-2">
                    {/* Add Pay Now button for orders with pending payment */}
                    {((order.paymentStatus || '').toLowerCase() === 'pending' || !order.paymentStatus) && (
                      <Button 
                        variant="outline" 
                        size="sm"
                        className="border-green-600 text-green-600 hover:bg-green-600/10"
                        onClick={() => handlePayOrder(order._id)}
                        disabled={processingPaymentOrderId === order._id}
                      >
                        {processingPaymentOrderId === order._id ? (
                          <Loader2 className="h-4 w-4 animate-spin" />
                        ) : 'Pay Now'}
                      </Button>
                    )}
                    {(order.status || '').toLowerCase() === 'pending' && (
                      <Button 
                        variant="outline" 
                        size="sm"
                        className="border-destructive text-destructive hover:bg-destructive/10"
                        onClick={() => handleCancelOrder(order._id)}
                        disabled={cancellingOrderId === order._id}
                      >
                        {cancellingOrderId === order._id ? (
                          <Loader2 className="h-4 w-4 animate-spin" />
                        ) : 'Cancel'}
                      </Button>
                    )}
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};
export default MyOrders;
</file>

<file path="src/services/api.ts">
import { Category, MenuItem } from '@/types';
import { API_BASE_URL } from '@/config/constants';
import apiClient from '@/api/apiClient';
// Map the data from API response to match our types
const mapMenuItem = (item: any): MenuItem => {
  return {
    ...item,
    category: item.categoryId || '',  // Assign categoryId to category for compatibility
    imageSearchTerm: item.imageSearchTerm || '',  // Ensure imageSearchTerm exists
    preparationTime: item.preparationTime || '',  // Ensure preparationTime exists
    nutritionInfo: item.nutritionInfo || null,    // Ensure nutritionInfo exists
  };
};
// API Services
export const api = {
  // Get all categories
  getCategories: async (): Promise<Category[]> => {
    try {
      // Don't use API_BASE_URL since apiClient already has the base URL configured
      const response = await apiClient.get('/api/categories');
      // More flexible response handling
      if (response?.data) {
        // Handle success response with data property
        if (response.data.success && Array.isArray(response.data.data)) {
          return response.data.data;
        }
        // Handle direct array response
        else if (Array.isArray(response.data)) {
          return response.data;
        }
        // Handle object with categories property
        else if (response.data.categories && Array.isArray(response.data.categories)) {
          return response.data.categories;
        }
      }
      console.error('Unexpected categories response format:', response?.data);
      throw new Error('Failed to fetch categories');
    } catch (error) {
      console.error('Error fetching categories:', error);
      throw error;
    }
  },
  // Get all menu items
  getMenuItems: async (): Promise<MenuItem[]> => {
    try {
      // Don't use API_BASE_URL since apiClient already has the base URL configured
      const response = await apiClient.get('/api/menu-items');
      // More flexible response handling
      if (response?.data) {
        // Handle success response with data property
        if (response.data.success && Array.isArray(response.data.data)) {
          return response.data.data.map(mapMenuItem);
        }
        // Handle direct array response
        else if (Array.isArray(response.data)) {
          return response.data.map(mapMenuItem);
        }
        // Handle object with menuItems property
        else if (response.data.menuItems && Array.isArray(response.data.menuItems)) {
          return response.data.menuItems.map(mapMenuItem);
        }
        // Handle object with items property
        else if (response.data.items && Array.isArray(response.data.items)) {
          return response.data.items.map(mapMenuItem);
        }
      }
      console.error('Unexpected menu items response format:', response?.data);
      throw new Error('Failed to fetch menu items');
    } catch (error) {
      console.error('Error fetching menu items:', error);
      throw error;
    }
  },
  // Get menu items by category
  getMenuItemsByCategory: async (categoryId: string): Promise<MenuItem[]> => {
    try {
      // Don't use API_BASE_URL since apiClient already has the base URL configured
      const response = await apiClient.get(`/api/categories/${categoryId}/menu-items`);
      if (response?.data?.success) {
        return response.data.data.map(mapMenuItem);
      }
      throw new Error('Failed to fetch menu items by category');
    } catch (error) {
      console.error('Error fetching menu items by category:', error);
      throw error;
    }
  },
  // Get a single menu item by ID
  getMenuItem: async (id: string): Promise<MenuItem | undefined> => {
    try {
      const response = await apiClient.get(`${API_BASE_URL}/api/menu-items/${id}`);
      if (response?.data?.success) {
        return mapMenuItem(response.data.data);
      }
      throw new Error('Failed to fetch menu item');
    } catch (error) {
      console.error('Error fetching menu item:', error);
      throw error;
    }
  },
  // Get featured menu items
  getFeaturedItems: async (): Promise<MenuItem[]> => {
    try {
      const response = await apiClient.get(`${API_BASE_URL}/api/menu-items/featured`);
      if (response?.data?.success) {
        return response.data.data.map(mapMenuItem);
      }
      throw new Error('Failed to fetch featured items');
    } catch (error) {
      console.error('Error fetching featured items:', error);
      throw error;
    }
  },
  // Get popular menu items
  getPopularItems: async (): Promise<MenuItem[]> => {
    try {
      const response = await apiClient.get(`${API_BASE_URL}/api/menu-items/popular`);
      if (response?.data?.success) {
        return response.data.data.map(mapMenuItem);
      }
      throw new Error('Failed to fetch popular items');
    } catch (error) {
      console.error('Error fetching popular items:', error);
      throw error;
    }
  },
  // Search menu items
  searchMenuItems: async (query: string): Promise<MenuItem[]> => {
    try {
      const response = await apiClient.get(`${API_BASE_URL}/api/menu-items/search?query=${encodeURIComponent(query)}`);
      if (response?.data?.success) {
        return response.data.data.map(mapMenuItem);
      }
      throw new Error('Failed to search menu items');
    } catch (error) {
      console.error('Error searching menu items:', error);
      throw error;
    }
  }
};
</file>

<file path="src/services/AuthService.ts">
import axios from 'axios';
import { toast } from 'sonner';
// API URL configuration
// Extract base URL without any trailing /api to prevent double prefixes
let API_BASE = import.meta.env.VITE_API_URL || 'http://localhost:3001';
// Remove any trailing /api if present to avoid double prefix
if (API_BASE.endsWith('/api')) {
  API_BASE = API_BASE.slice(0, -4);
}
const API_URL = `${API_BASE}/api`;
console.log('Auth Service API URL:', API_URL);
// User interface
export interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: string;
  loyaltyPoints?: number;
  name?: string;
  createdAt?: string;
  orders?: any[];
}
// Login credentials interface
export interface LoginCredentials {
  email: string;
  password: string;
}
// Register credentials interface
export interface RegisterCredentials {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
}
// Configure axios to include credentials
axios.defaults.withCredentials = true;
// Function to get the auth token from cookies ONLY
const getEffectiveToken = (): string | null => {
  // First check cookies for access_token (set by backend after Google auth)
  const cookies = document.cookie.split(';').map(c => c.trim());
  const accessTokenCookie = cookies.find(c => c.startsWith('access_token='));
  if (accessTokenCookie) {
    const token = accessTokenCookie.split('=')[1];
    console.log('Found access_token in cookies');
    return token;
  }
  // Then check for auth_token in cookies
  const authTokenCookie = cookies.find(c => c.startsWith('auth_token='));
  if (authTokenCookie) {
    const token = authTokenCookie.split('=')[1];
    console.log('Found auth_token in cookies');
    return token;
  }
  console.log('No authentication token found in cookies');
  return null;
};
// Function to get Authorization header with properly formatted token
export const getAuthHeader = (): { Authorization: string } | {} => {
  const token = getEffectiveToken();
  if (token) {
    return { Authorization: `Bearer ${token}` };
  }
  return {};
};
export const AuthService = {
  // Login user
  login: async (credentials: LoginCredentials): Promise<{ success: boolean; user?: User; error?: string }> => {
    try {
      const response = await axios.post(`${API_URL}/auth/login`, credentials);
      if (response.data.success) {
        return {
          success: true,
          user: response.data.user
        };
      }
      return { success: false, error: 'Login failed' };
    } catch (error: any) {
      console.error('Login error:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'Login failed. Please try again.'
      };
    }
  },
  // Register new user
  register: async (credentials: RegisterCredentials): Promise<{ success: boolean; user?: User; error?: string }> => {
    try {
      const response = await axios.post(`${API_URL}/auth/register`, credentials);
      if (response.data.success) {
        return {
          success: true,
          user: response.data.user
        };
      }
      return { success: false, error: 'Registration failed' };
    } catch (error: any) {
      console.error('Registration error:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'Registration failed. Please try again.'
      };
    }
  },
  // Logout user
  logout: async (): Promise<{ success: boolean; error?: string }> => {
    try {
      await axios.post(`${API_URL}/auth/logout`);
      toast.success('Logged out successfully');
      return { success: true };
    } catch (error: any) {
      console.error('Logout error:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'Logout failed. Please try again.'
      };
    }
  },
  // Check if user is authenticated
  isAuthenticated: async (): Promise<boolean> => {
    try {
      const response = await axios.get(`${API_URL}/auth/check`, {
        headers: { ...getAuthHeader() }
      });
      return response.data.isAuthenticated;
    } catch (error) {
      console.error('Auth check error:', error);
      return false;
    }
  },
  // Get current user
  getCurrentUser: async (): Promise<User | null> => {
    try {
      const response = await axios.get(`${API_URL}/auth/me`, {
        headers: { ...getAuthHeader() }
      });
      if (response.data.success) {
        return response.data.user;
      }
      return null;
    } catch (error) {
      console.error('Error getting current user:', error);
      return null;
    }
  },
  // Refresh token
  refreshToken: async (): Promise<boolean> => {
    try {
      const response = await axios.post(`${API_URL}/auth/refresh-token`);
      return response.data.success;
    } catch (error) {
      console.error('Token refresh error:', error);
      return false;
    }
  },
  // Guest login with table ID
  guestLogin: async (tableId: string): Promise<{ success: boolean; token?: string; user?: User; error?: string }> => {
    try {
      // Create a device ID if not already stored
      const deviceId = localStorage.getItem('device_id') || `device_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
      if (!localStorage.getItem('device_id')) {
        localStorage.setItem('device_id', deviceId);
      }
      // Use the correct endpoint: guest-token
      const response = await axios.post(`${API_URL}/auth/guest-token`, {
        tableId,
        deviceId
      });
      if (response.data.success && response.data.token) {
        // Store the token in localStorage as a fallback
        // Only using cookies for token storage, not localStorage
        // Set token in cookie for cross-page consistency
        document.cookie = `auth_token=${response.data.token}; path=/; max-age=86400; SameSite=Lax`;
        document.cookie = `access_token=${response.data.token}; path=/; max-age=86400; SameSite=Lax`;
        // Create a guest user object from the response data
        const guestUser: User = {
          id: response.data.user?.id || `guest-${deviceId}`,
          email: response.data.user?.email || `${deviceId}@guest.inseat.com`,
          firstName: response.data.user?.firstName || 'Guest',
          lastName: response.data.user?.lastName || 'User',
          role: 'guest'
        };
        return {
          success: true,
          token: response.data.token,
          user: guestUser
        };
      }
      return { success: false, error: 'Guest login failed' };
    } catch (error: any) {
      console.error('Guest login error:', error);
      return {
        success: false,
        error: error.response?.data?.message || 'Guest login failed. Please try again.'
      };
    }
  },
  // Google OAuth login
  loginWithGoogle: (): void => {
    // Store current table ID before redirecting
    const tableId = localStorage.getItem('currentTableId') || 
                   localStorage.getItem('tableId') || 
                   localStorage.getItem('table_id');
    if (tableId) {
      // Store in sessionStorage to survive the redirect
      sessionStorage.setItem('tableId', tableId);
      console.log('Stored table ID in session storage before Google login:', tableId);
      // Add table ID to the redirect URL as a query parameter
      window.location.href = `${API_URL}/auth/google?table=${tableId}`;
    } else {
      window.location.href = `${API_URL}/auth/google`;
    }
  }
};
</file>

<file path="src/types/index.ts">
export interface MenuItem {
  id: string;
  _id?: string; // Added for API compatibility
  name: string;
  description: string;
  price: number;
  image: string;
  category: string;
  imageSearchTerm?: string; // Added for fallback image generation
  featured?: boolean;
  popular?: boolean;
  tags?: string[];
  modifiers?: MenuItemModifierGroup[];
}
// Represents an option within a modifier group (e.g., "Small", "Medium", "Large" for Size)
export interface ModifierOption {
  name: string;
  price: number;
}
// Represents a group of modifiers for a menu item (e.g., "Size", "Toppings")
export interface MenuItemModifierGroup {
  name: string;
  type: 'single-select' | 'multi-select'; // Determines how the options are presented
  required?: boolean;
  options: ModifierOption[]; // The available choices for this modifier group
}
// --- Removed old MenuItemModifier interface ---
export interface CookingPreference {
  id: string;
  name: string;
}
export interface Category {
  id: string;
  name: string;
  image?: string;
  subCategories?: string[]; // Add this for compatibility with existing code
  imageSearchTerm?: string; // Add this for image searches
  restaurantId?: string;
}
export interface CartItem {
  id: string;
  menuItemId?: string;  // Make optional as it might be derived from id in some cases
  name: string;
  price: number;
  quantity: number;
  image?: string;  // Make optional as it might not be available from API
  modifiers?: CartItemModifier[];
  cookingPreference?: string;
  specialInstructions?: string;
  // Helper method to calculate the total price including modifiers
  getItemTotal?: () => number;
}
/**
 * Represents a modifier selected for a cart item
 */
export interface CartItemModifier {
  id: string;
  name: string;
  price: number;
}
export interface Order {
  id: string;
  _id?: string; // MongoDB ObjectId format for backend compatibility
  orderNumber: string;
  items: CartItem[];
  subtotal: number;
  tax: number;
  serviceFee: number;
  tip: number;
  total: number;
  status: OrderStatus;
  paymentStatus: PaymentStatus;
  timestamp: Date;
  tableId: string; // Changed from tableNumber to match API
  specialInstructions?: string;
}
// Export new enum types to replace the string literal types
export enum OrderStatus {
  PENDING = 'PENDING',
  PREPARING = 'PREPARING',
  READY = 'READY',
  DELIVERED = 'DELIVERED',
  COMPLETED = 'COMPLETED',
  CANCELLED = 'CANCELLED'
}
export enum PaymentStatus {
  PENDING = 'PENDING',
  PROCESSING = 'PROCESSING',
  PAID = 'PAID',
  FAILED = 'FAILED',
  REFUNDED = 'REFUNDED'
}
export type CartContextType = {
  cartItems: CartItem[];  // Renamed from items to cartItems for consistency with API
  addItem: (item: MenuItem, quantity: number, modifiers?: CartItemModifier[], cookingPreference?: string, specialInstructions?: string) => void;
  removeFromCart: (id: string) => void;  // Renamed from removeItem for clarity
  updateQuantity: (id: string, quantity: number) => void;
  clearCart: () => void;
  itemCount: number;  // Renamed from totalItems for clarity
  cartTotal: number;  // Renamed from subtotal to cartTotal for clarity
};
export type FavoritesContextType = {
  favorites: string[];
  addFavorite: (itemId: string) => void;
  removeFavorite: (itemId: string) => void;
  isFavorite: (itemId: string) => boolean;
};
export interface OrdersContextType {
  orders: Order[];
  loading: boolean;
  addOrder: (order: Order) => void;
  getOrderById: (id: string) => Promise<Order | null>;
  updateOrder?: (id: string, updates: Partial<Order>) => void;
  clearOrders: () => void;
}
export interface TableInfo {
  tableNumber?: string; // Make optional since we'll use tableId
  restaurantName: string;
  tableId: string; // Make required to match API
}
// Re-export all types
export * from './menu';
export * from './Order';
</file>

<file path="src/App.tsx">
import React from "react";
import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { CartProvider } from "@/context/CartContext";
import { FavoritesProvider } from "@/context/FavoritesContext";
import { OrdersProvider } from "@/context/OrdersContext";
import { TableProvider } from "@/context/TableContext";
import { AuthProvider } from "@/context/AuthContext";
import { ThemeProvider } from "next-themes";
import { ProtectedRoute } from "@/components/ProtectedRoute";
import Layout from "./pages/Layout";
import Index from "./pages/Index";
import Menu from "./pages/Menu";
import MenuItemDetail from "./pages/MenuItemDetail";
import MyOrders from "./pages/MyOrders";
import CallWaiter from "./pages/CallWaiter";
import Bill from "./pages/Bill";
import Checkout from "./pages/Checkout";
import OrderConfirmation from "./pages/OrderConfirmation";
import Login from "./pages/Login";
import LoginSuccess from "./pages/LoginSuccess";
import Signup from "./pages/Signup";
import Account from "./pages/Account";
import NotFound from "./pages/NotFound";
import CategoryDetail from "./pages/CategoryDetail";
import ScanTable from "./pages/ScanTable";
import PaymentSuccess from "./pages/PaymentSuccess";
import PaymentCancel from "./pages/PaymentCancel";
// Create a new client with proper configuration
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      staleTime: 1000 * 60 * 5, // 5 minutes
    },
  },
});
const App = () => {
  return (
    <React.StrictMode>
      <QueryClientProvider client={queryClient}>
        <ThemeProvider attribute="class" defaultTheme="dark" forcedTheme="dark">
          <BrowserRouter>
            <AuthProvider>
              <TableProvider>
                <CartProvider>
                  <OrdersProvider>
                    <FavoritesProvider>
                      <TooltipProvider>
                        <Toaster />
                        <Sonner position="top-right" closeButton />
                        <Routes>
                          <Route element={<Layout />}>
                            <Route path="/" element={<Index />} />
                            <Route path="/scan" element={<ScanTable />} />
                            <Route path="/menu" element={<Menu />} />
                            <Route path="/menu/:id" element={<MenuItemDetail />} />
                            <Route path="/category/:categoryId" element={<CategoryDetail />} />
                            <Route path="/my-orders" element={
                              <ProtectedRoute>
                                <MyOrders />
                              </ProtectedRoute>
                            } />
                            <Route path="/call-waiter" element={<CallWaiter />} />
                            <Route path="/bill" element={<Bill />} />
                            <Route path="/checkout" element={
                              <ProtectedRoute>
                                <Checkout />
                              </ProtectedRoute>
                            } />
                            <Route path="/order-confirmation" element={<OrderConfirmation />} />
                            <Route path="/payment/success" element={<PaymentSuccess />} />
                            <Route path="/payment/cancel" element={<PaymentCancel />} />
                            <Route path="/login" element={<Login />} />
                            <Route path="/login/success" element={<LoginSuccess />} />
                            <Route path="/signup" element={<Signup />} />
                            <Route path="/account" element={
                              <ProtectedRoute>
                                <Account />
                              </ProtectedRoute>
                            } />
                            <Route path="*" element={<NotFound />} />
                          </Route>
                        </Routes>
                      </TooltipProvider>
                    </FavoritesProvider>
                  </OrdersProvider>
                </CartProvider>
              </TableProvider>
            </AuthProvider>
          </BrowserRouter>
        </ThemeProvider>
      </QueryClientProvider>
    </React.StrictMode>
  );
};
export default App;
// 
// 
//
</file>

<file path="package.json">
{
  "name": "inseat-menu",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:dev": "vite build --mode development",
    "lint": "eslint .",
    "preview": "vite preview",
    "seed": "node --experimental-modules src/seed.js"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.9.0",
    "@radix-ui/react-accordion": "^1.2.0",
    "@radix-ui/react-alert-dialog": "^1.1.1",
    "@radix-ui/react-aspect-ratio": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.0",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-collapsible": "^1.1.0",
    "@radix-ui/react-context-menu": "^2.2.1",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-hover-card": "^1.1.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-menubar": "^1.1.1",
    "@radix-ui/react-navigation-menu": "^1.2.0",
    "@radix-ui/react-popover": "^1.1.1",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-radio-group": "^1.2.0",
    "@radix-ui/react-scroll-area": "^1.1.0",
    "@radix-ui/react-select": "^2.1.1",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slider": "^1.2.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.0",
    "@radix-ui/react-tabs": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.1",
    "@radix-ui/react-toggle": "^1.1.0",
    "@radix-ui/react-toggle-group": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.4",
    "@tanstack/react-query": "^5.56.2",
    "axios": "^1.9.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "date-fns": "^3.6.0",
    "embla-carousel-autoplay": "^8.5.2",
    "embla-carousel-react": "^8.3.0",
    "framer-motion": "^12.6.3",
    "html5-qrcode": "^2.3.8",
    "input-otp": "^1.2.4",
    "jsqr": "^1.4.0",
    "lucide-react": "^0.462.0",
    "next-themes": "^0.4.6",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.53.0",
    "react-qr-scanner": "^1.0.0-alpha.11",
    "react-resizable-panels": "^2.1.3",
    "react-router-dom": "^6.26.2",
    "recharts": "^2.12.7",
    "sonner": "^1.5.0",
    "tailwind-merge": "^2.5.2",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^0.9.9",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.0",
    "@stagewise/toolbar-react": "^0.1.2",
    "@tailwindcss/typography": "^0.5.15",
    "@types/lodash": "^4.17.16",
    "@types/node": "^22.5.5",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react-swc": "^3.5.0",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.9.0",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.9",
    "globals": "^15.9.0",
    "lovable-tagger": "^1.1.7",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.11",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.0.1",
    "vite": "^5.4.1"
  }
}
</file>

<file path="src/api/apiClient.ts">
import axios from 'axios';
import { API_BASE_URL } from '@/config/constants';
// Extract the base URL without any /api/auth path if present
const extractedBaseUrl = typeof API_BASE_URL === 'string' && API_BASE_URL.includes('/api/auth') 
  ? API_BASE_URL.split('/api/auth')[0] 
  : API_BASE_URL;
// Define the final BASE_URL used for API requests
const BASE_URL = extractedBaseUrl || 'https://api.inseat.achievengine.com';
// For debugging
console.log('API_BASE_URL:', API_BASE_URL);
console.log('Extracted BASE_URL for API client:', BASE_URL);
// Helper function to get token from various sources
const getEffectiveToken = (): string | null => {
  // Try localStorage first
  const localToken = localStorage.getItem('auth_token');
  if (localToken) {
    return localToken;
  }
  // Then try cookies
  const cookies = document.cookie.split(';');
  const tokenCookie = cookies.find(cookie => 
    cookie.trim().startsWith('auth_token=') || 
    cookie.trim().startsWith('access_token=')
  );
  if (tokenCookie) {
    return tokenCookie.split('=')[1].trim();
  }
  return null;
};
// Create a consistent API client with proper CORS and cookie handling
const apiClient = axios.create({
  baseURL: BASE_URL,
  withCredentials: true, // Essential for sending cookies with requests
  headers: {
    'Content-Type': 'application/json',
    'X-Requested-With': 'XMLHttpRequest',
    'Accept': 'application/json'
  },
  // Add timeout to prevent hanging requests
  timeout: 15000,
});
// Add request interceptor to include Authorization header when token is available
apiClient.interceptors.request.use(
  (config) => {
    // FIXED: Handle API URLs correctly
    if (config.url) {
      // Remove any automatic /api/ prefixing - we'll just handle double prefixes
      if (config.url.includes('/api/api/')) {
        console.warn('âš ï¸ Double /api/ prefix detected in URL:', config.url);
        config.url = config.url.replace('/api/api/', '/api/');
        console.log('ðŸ”§ Fixed URL:', config.url);
      }
      // Log the final URL for debugging
      console.log('ðŸ“ Final request URL:', config.url);
    }
    // Track request method for debugging
    console.log(`ðŸ”· Making ${config.method?.toUpperCase()} request to ${config.url}`);
    const token = getEffectiveToken();
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
      console.log('âœ… Added token to request headers');
    } else {
      console.log('âš ï¸ No token available for request, relying on HttpOnly cookies');
    }
    // Log request info for debugging
    console.log('Request URL:', `${config.baseURL}${config.url}`);
    console.log('Request headers:', config.headers);
    return config;
  },
  (error) => {
    console.error('âŒ Request configuration error:', error.message);
    return Promise.reject(error);
  }
);
// Token refresh mechanism
let isRefreshing = false;
let refreshSubscribers: ((token: string) => void)[] = [];
// Function to add callbacks to the refresh subscriber queue
const subscribeTokenRefresh = (callback: (token: string) => void) => {
  refreshSubscribers.push(callback);
};
// Function to notify all subscribers about the new token
const onTokenRefreshed = (token: string) => {
  refreshSubscribers.forEach(callback => callback(token));
  refreshSubscribers = [];
};
// Function to handle token refresh failure
const onRefreshFailure = (error: any) => {
  refreshSubscribers = [];
  // Clear authentication data
  localStorage.removeItem('auth_token');
  localStorage.removeItem('refresh_token');
  localStorage.removeItem('user');
  // Redirect to login if needed
  if (window.location.pathname !== '/login' && 
      window.location.pathname !== '/signup' && 
      !window.location.pathname.includes('/table/')) {
    console.log('Redirecting to login page due to authentication failure');
    window.location.href = '/login';
  }
};
// Function to refresh the token
const refreshAuthToken = async (): Promise<string | null> => {
  try {
    console.log('ðŸ”„ Attempting to refresh token...');
    // Try to refresh using the dedicated endpoint
    try {
      // First try the /api/auth/refresh-token endpoint
      const response = await axios.post(`${BASE_URL}/api/auth/refresh-token`, {}, { 
        headers: { 'Content-Type': 'application/json' },
        withCredentials: true
      });
      if (response.data?.token) {
        const newToken = response.data.token;
        // Save the new token
        localStorage.setItem('auth_token', newToken);
        // If a new refresh token is provided, save it
        if (response.data.refreshToken) {
          localStorage.setItem('refresh_token', response.data.refreshToken);
        }
        console.log('âœ… Token refreshed successfully');
        return newToken;
      }
    } catch (refreshError) {
      console.log('First refresh attempt failed, trying alternative method...');
      // Try with refresh token if available
      const refreshToken = localStorage.getItem('refresh_token');
      if (refreshToken) {
        try {
          const response = await axios.post(`${BASE_URL}/api/auth/refresh-token`, 
            { refreshToken },
            { 
              headers: { 'Content-Type': 'application/json' },
              withCredentials: true
            }
          );
          if (response.data?.token) {
            const newToken = response.data.token;
            // Save the new token
            localStorage.setItem('auth_token', newToken);
            // If a new refresh token is provided, save it
            if (response.data.refreshToken) {
              localStorage.setItem('refresh_token', response.data.refreshToken);
            }
            console.log('âœ… Token refreshed successfully with refresh token');
            return newToken;
          }
        } catch (secondRefreshError) {
          console.error('Second refresh attempt failed:', secondRefreshError);
        }
      }
    }
    return null;
  } catch (error) {
    console.error('âŒ Token refresh failed:', error);
    return null;
  }
};
// Add response interceptor for better error handling
apiClient.interceptors.response.use(
  (response) => {
    console.log(`âœ… API response success: ${response.config.method?.toUpperCase()} ${response.config.url} (${response.status})`);
    // Check if response data is usable
    if (response.data === undefined || response.data === null) {
      console.warn('âš ï¸ Response does not contain data property');
    }
    return response;
  },
  async (error) => {
    if (error.code === 'ECONNABORTED') {
      console.error('âŒ Request timeout:', error.message);
    } else if (error.response) {
      // The server responded with a status code outside of 2xx range
      console.error(`âŒ API request failed with status ${error.response.status}: ${error.config?.method?.toUpperCase()} ${error.config?.url}`);
      // Handle 401 Unauthorized errors with token refresh
      if (error.response.status === 401) {
        console.error('ðŸ”‘ Authentication failed - invalid or expired token');
        // Check if token refresh is needed based on response
        const needsRefresh = error.response.data?.needsRefresh === true;
        if (needsRefresh && error.config && !error.config._retry) {
          if (isRefreshing) {
            // If already refreshing, wait for the new token
            try {
              const retryOriginalRequest = new Promise<any>((resolve) => {
                subscribeTokenRefresh((token: string) => {
                  // Replace the expired token with the new one
                  error.config.headers['Authorization'] = `Bearer ${token}`;
                  error.config._retry = true;
                  resolve(apiClient(error.config));
                });
              });
              return retryOriginalRequest;
            } catch (refreshError) {
              return Promise.reject(refreshError);
            }
          }
          // Start refreshing process
          isRefreshing = true;
          error.config._retry = true;
          try {
            // Attempt to refresh the token
            const newToken = await refreshAuthToken();
            if (newToken) {
              // Notify all subscribers about the new token
              onTokenRefreshed(newToken);
              // Retry the original request with the new token
              error.config.headers['Authorization'] = `Bearer ${newToken}`;
              return apiClient(error.config);
            } else {
              // Handle refresh failure
              onRefreshFailure(error);
              return Promise.reject(error);
            }
          } catch (refreshError) {
            // Handle refresh error
            onRefreshFailure(refreshError);
            return Promise.reject(refreshError);
          } finally {
            isRefreshing = false;
          }
        }
      } else if (error.response.status === 403) {
        console.error('ðŸ”’ Authorization failed - insufficient permissions');
      } else if (error.response.status === 404) {
        console.error('ðŸ” Resource not found');
      } else if (error.response.status === 500) {
        console.error('ðŸ’¥ Server error');
      }
      // Log response data details
      if (error.response.data) {
        console.log('Response data:', error.response.data);
      }
    } else if (error.request) {
      console.error('âŒ No response received:', error.message);
    } else {
      console.error('âŒ Request error:', error.message);
    }
    return Promise.reject(error);
  }
);
export default apiClient;
</file>

<file path="src/api/customerAuthService.ts">
import axios, { AxiosError, AxiosResponse } from 'axios';
import { getEffectiveToken } from './authService';
// Define base API URL - should come from environment variables in production
const API_BASE_URL = import.meta.env.VITE_AUTH_API_URL;
// Extract the base URL without the auth path
const BASE_URL = API_BASE_URL.includes('/api/auth') 
  ? API_BASE_URL.split('/api/auth')[0] 
  : API_BASE_URL;
// Customer API endpoint is at /api/customer
const CUSTOMER_API_ENDPOINT = `${BASE_URL}/api/customer`;
console.log('Customer API endpoint:', CUSTOMER_API_ENDPOINT);
// Helper function to handle API errors
const handleApiError = (error: unknown): AuthResponse => {
  console.error('API Error:', error);
  if (axios.isAxiosError(error)) {
    const axiosError = error as AxiosError;
    if (axiosError.response) {
      // Server responded with an error status code
      const responseData = axiosError.response.data as any;
      return {
        success: false,
        message: responseData?.message || 'An error occurred. Please try again.'
      };
    } else if (axiosError.request) {
      // Request was made but no response received
      return {
        success: false,
        message: 'Unable to connect to the server. Please check your internet connection.'
      };
    }
  }
  // Unknown error
  return {
    success: false,
    message: 'An unexpected error occurred. Please try again.'
  };
};
// Types
export interface LoginCredentials {
  email: string;
  password: string;
}
export interface RegisterData {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
}
export interface AuthResponse {
  success: boolean;
  user?: {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    role: string;
    loyaltyPoints?: number;
  };
  token?: string;
  accessToken?: string;
  refreshToken?: string;
  jwt?: string;
  message?: string;
}
// Axios instance with credentials (for cookies)
const api = axios.create({
  baseURL: CUSTOMER_API_ENDPOINT,
  withCredentials: true, // This allows cookies to be sent and received
  headers: {
    'Content-Type': 'application/json',
  },
});
// Set up request interceptor to add auth token to all requests
api.interceptors.request.use(
  (config) => {
    const token = getEffectiveToken();
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
      console.log('Added token to request headers');
    } else {
      console.log('No token available for request');
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);
const customerAuthService = {
  // Register a new customer
  async register(userData: RegisterData): Promise<AuthResponse> {
    try {
      console.log('Registering customer with data:', {
        ...userData,
        password: '[REDACTED]'
      });
      const response = await api.post<AuthResponse>('/register', userData, {
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        timeout: 10000 // 10 seconds timeout
      });
      console.log('Customer registration response:', response.data);
      // Store the token if available
      const { token, refreshToken } = response.data;
      if (token) {
        localStorage.setItem('auth_token', token);
        console.log('Auth token stored in localStorage');
      }
      if (refreshToken) {
        localStorage.setItem('refresh_token', refreshToken);
        console.log('Refresh token stored in localStorage');
      }
      return response.data;
    } catch (error) {
      return handleApiError(error);
    }
  },
  // Login with email and password
  async login(credentials: LoginCredentials): Promise<AuthResponse> {
    try {
      console.log('Logging in customer with email:', credentials.email);
      const response = await api.post<AuthResponse>('/login', credentials, {
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        withCredentials: true, // Ensure cookies are sent/received
        timeout: 10000 // 10 seconds timeout
      });
      console.log('Customer login response:', response.data);
      // Store the tokens if available
      const { token, refreshToken } = response.data;
      if (token) {
        // Store in localStorage
        localStorage.setItem('auth_token', token);
        // Also set as a cookie for cross-request authentication
        document.cookie = `auth_token=${token}; path=/; max-age=86400; SameSite=Lax`;
        console.log('Auth token stored in localStorage and cookie');
      }
      if (refreshToken) {
        localStorage.setItem('refresh_token', refreshToken);
        document.cookie = `refresh_token=${refreshToken}; path=/; max-age=604800; SameSite=Lax`;
        console.log('Refresh token stored in localStorage and cookie');
      }
      return response.data;
    } catch (error) {
      console.error('Login error:', error);
      return handleApiError(error);
    }
  },
  // Logout customer (clear cookies on server)
  async logout(): Promise<void> {
    try {
      console.log('Logging out customer user');
      // Use the customer-specific logout endpoint that doesn't require authentication
      await api.post('/logout', {}, {
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        timeout: 5000 // 5 seconds timeout
      });
      // Clear all auth tokens from localStorage
      localStorage.removeItem('auth_token');
      localStorage.removeItem('refresh_token');
      console.log('Auth tokens cleared from localStorage');
    } catch (error) {
      console.error('Logout error:', error);
      // Even if the server request fails, still clear local tokens
      localStorage.removeItem('auth_token');
      localStorage.removeItem('refresh_token');
      console.log('Auth tokens cleared from localStorage despite server error');
    }
  },
  // Get current customer profile
  async getCurrentUser(): Promise<AuthResponse> {
    try {
      console.log('Checking authentication status...');
      console.log('Document cookies:', document.cookie);
      // Log all cookies for debugging
      const cookies = document.cookie.split(';').map(c => c.trim());
      console.log('Parsed cookies:', cookies);
      // Check for tokens in both cookies and localStorage
      const accessTokenCookie = cookies.find(c => c.startsWith('access_token='));
      const refreshTokenCookie = cookies.find(c => c.startsWith('refresh_token='));
      const authTokenCookie = cookies.find(c => c.startsWith('auth_token='));
      const localToken = localStorage.getItem('auth_token');
      console.log('access_token cookie exists:', !!accessTokenCookie);
      console.log('refresh_token cookie exists:', !!refreshTokenCookie);
      console.log('auth_token cookie exists:', !!authTokenCookie);
      console.log('localStorage token exists:', !!localToken);
      // If there's no token in localStorage but we have cookie tokens, we'll still try the request
      // The cookies will be sent automatically due to withCredentials: true
      // For debugging, we'll include any token we have in the Authorization header
      // Though with httpOnly cookies, the browser will automatically include them
      let explicitToken = null;
      if (accessTokenCookie) {
        explicitToken = accessTokenCookie.split('=')[1];
        console.log('Using access_token cookie for explicit Authorization header');
      } else if (authTokenCookie) {
        explicitToken = authTokenCookie.split('=')[1];
        console.log('Using auth_token cookie for explicit Authorization header');
      } else if (localToken) {
        explicitToken = localToken;
        console.log('Using localStorage token for explicit Authorization header');
      }
      // Make the request, letting cookies be sent automatically
      // Only add explicit Authorization header if we have a token to use
      const requestConfig: any = { withCredentials: true };
      if (explicitToken) {
        requestConfig.headers = {
          Authorization: `Bearer ${explicitToken}`
        };
      }
      console.log('Making /me request with config:', requestConfig);
      const response = await api.get('/me', requestConfig);
      console.log('Current user retrieved successfully:', response.data);
      return {
        success: true,
        user: response.data.user
      };
    } catch (error) {
      console.error('Get current customer error:', error);
      if (axios.isAxiosError(error) && error.response) {
        if (error.response.status === 401) {
          console.log('Authentication failed (401), clearing tokens');
          localStorage.removeItem('auth_token');
          document.cookie = 'auth_token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT';
          document.cookie = 'access_token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT';
        }
        return error.response.data as AuthResponse;
      }
      return {
        success: false,
        message: 'Failed to retrieve user profile'
      };
    }
  },
  // Refresh the authentication token
  async refreshToken(): Promise<boolean> {
    try {
      const refreshToken = localStorage.getItem('refresh_token');
      if (!refreshToken) {
        console.log('No refresh token available');
        return false;
      }
      console.log('Attempting to refresh access token...');
      const response = await api.post<AuthResponse>('/refresh-token', { refreshToken }, {
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        timeout: 10000 // 10 seconds timeout
      });
      const { token, refreshToken: newRefreshToken } = response.data;
      if (token) {
        localStorage.setItem('auth_token', token);
        console.log('Access token refreshed successfully');
        // Update refresh token if a new one was provided
        if (newRefreshToken) {
          localStorage.setItem('refresh_token', newRefreshToken);
          console.log('Refresh token updated');
        }
        return true;
      }
      console.log('No new token received in refresh response');
      return false;
    } catch (error) {
      console.error('Refresh token error:', error);
      // Clear invalid tokens on error
      if (error.response?.status === 401) {
        console.log('Refresh token invalid or expired, clearing tokens');
        localStorage.removeItem('auth_token');
        localStorage.removeItem('refresh_token');
      }
      return false;
    }
  },
  // Check authentication status
  async checkAuthStatus(): Promise<boolean> {
    try {
      const token = getEffectiveToken();
      if (!token) {
        console.log('No token available, user is not authenticated');
        return false;
      }
      const response = await api.get('/me');
      return response.data.success === true;
    } catch (error) {
      console.error('Auth status check error:', error);
      if (axios.isAxiosError(error) && error.response) {
        if (error.response.status === 401) {
          localStorage.removeItem('auth_token');
        }
      }
      return false;
    }
  },
  // Get Google OAuth URL for redirect
  getGoogleAuthUrl(): string {
    // Store current table ID before redirecting
    const tableId = localStorage.getItem('currentTableId') || 
                   localStorage.getItem('tableId') || 
                   localStorage.getItem('table_id');
    if (tableId) {
      // Store in sessionStorage to survive the redirect
      sessionStorage.setItem('tableId', tableId);
      console.log('Stored table ID in session storage before Google login:', tableId);
      // Add table ID to the redirect URL as a query parameter
      return `${API_BASE_URL}/google?table=${tableId}`;
    }
    return `${API_BASE_URL}/google`;
  }
};
export default customerAuthService;
</file>

<file path="src/config/constants.ts">
// API Base URL
// Get API URL from environment variables, default to production URL
const envApiUrl = import.meta.env.VITE_API_BASE_URL;
// Ensure API_BASE_URL is the true root (e.g., http://localhost:3001)
let processedApiUrl = envApiUrl || 'https://api.inseat.achievengine.com';
if (processedApiUrl.endsWith('/api')) {
  processedApiUrl = processedApiUrl.slice(0, -4); // Remove last /api
} else if (processedApiUrl.endsWith('/api/')) { // also handle trailing slash
  processedApiUrl = processedApiUrl.slice(0, -5); // Remove last /api/
}
export const API_BASE_URL = processedApiUrl;
// Log the API URL being used
console.log('Processed API base URL for constants:', API_BASE_URL);
// Auth API URL
export const AUTH_API_URL = `${API_BASE_URL}/api/auth`;
// Customer API URL
export const CUSTOMER_API_URL = `${API_BASE_URL}/api/customer`;
// Order API URL
export const ORDER_API_URL = `${API_BASE_URL}/api/orders`;
// Menu API URL
export const MENU_API_URL = `${API_BASE_URL}/api/menu`;
// Table API URL
export const TABLE_API_URL = `${API_BASE_URL}/api/tables`;
// Other constants
export const DEFAULT_CURRENCY = 'USD';
export const DEFAULT_LANGUAGE = 'en';
export const DEFAULT_PAGINATION_LIMIT = 10;
</file>

<file path="src/pages/ScanTable.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { verifyTableStatus } from '@/api/menuService';
import { 
  Alert, 
  AlertTitle, 
  AlertDescription 
} from '@/components/ui/alert';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Loader2, QrCode, AlertTriangle, X, ScanLine } from 'lucide-react';
import jsQR from 'jsqr';
import { cn } from '@/lib/utils';
const ScanTable: React.FC = () => {
  const navigate = useNavigate();
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [cameraPermission, setCameraPermission] = useState<boolean | null>(null);
  const [cameraStream, setCameraStream] = useState<MediaStream | null>(null);
  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [scanInterval, setScanInterval] = useState<number | null>(null);
  // Start camera for QR scanning
  const startCamera = async () => {
    try {
      setError(null);
      // Check if browser supports getUserMedia
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error('Your browser does not support camera access');
      }
      // Request camera permission
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment' } // Use back camera on mobile devices
      });
      setCameraPermission(true);
      setCameraStream(stream);
      // Set video source
      if (videoRef.current) {
        videoRef.current.srcObject = stream;
        // Wait for loadedmetadata event before playing to avoid interrupt errors
        videoRef.current.onloadedmetadata = () => {
          videoRef.current?.play().catch(err => {
            console.error('Error playing video:', err);
          });
        };
      }
      // Start scanning for QR codes
      const interval = window.setInterval(() => {
        scanQRCode();
      }, 500) as unknown as number;
      setScanInterval(interval);
    } catch (err) {
      console.error('Camera access error:', err);
      setCameraPermission(false);
      setError('Could not access camera. Please check permissions.');
    }
  };
  // Stop camera and clean up
  const stopCamera = () => {
    if (scanInterval) {
      clearInterval(scanInterval);
      setScanInterval(null);
    }
    if (cameraStream) {
      cameraStream.getTracks().forEach(track => track.stop());
      setCameraStream(null);
    }
    if (videoRef.current) {
      videoRef.current.srcObject = null;
    }
  };
  // Clean up on component unmount
  useEffect(() => {
    return () => {
      stopCamera();
    };
  }, []);
  // Start camera on component mount
  useEffect(() => {
    startCamera();
  }, []);
  // Scan video frame for QR code
  const scanQRCode = async () => {
    if (!videoRef.current || !canvasRef.current || !cameraStream) return;
    const video = videoRef.current;
    const canvas = canvasRef.current;
    const context = canvas.getContext('2d');
    if (!context || video.videoWidth === 0 || video.videoHeight === 0) return;
    // Add debugging
    console.log('Scanning QR code, video dimensions:', video.videoWidth, 'x', video.videoHeight);
    // Set canvas dimensions to match video
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    // Draw current video frame to canvas
    context.drawImage(video, 0, 0, canvas.width, canvas.height);
    try {
      // Get image data for QR code detection
      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
      // Use jsQR to detect QR code
      const code = jsQR(
        imageData.data,
        imageData.width,
        imageData.height,
        {
          inversionAttempts: "dontInvert",
        }
      );
      // If QR code is detected
      if (code) {
        // Extract table ID from the QR code data
        // This assumes the QR code contains a URL like "https://example.com/?table=123"
        // or just the table ID directly
        let tableId = code.data;
        // Try to extract table ID from URL if the QR code contains a URL
        try {
          const url = new URL(code.data);
          const params = new URLSearchParams(url.search);
          const urlTableId = params.get('table');
          if (urlTableId) {
            tableId = urlTableId;
          }
        } catch (e) {
          // Not a URL, use the raw data as the table ID
        }
        if (tableId) {
          handleQRCodeDetected(tableId);
        }
      }
    } catch (err) {
      console.error('QR Code scanning error:', err);
    }
  };
  // Handle detected QR code
  const handleQRCodeDetected = async (tableId: string) => {
    if (!tableId || loading) return;
    setLoading(true);
    stopCamera();
    try {
      const verification = await verifyTableStatus(tableId);
      if (verification.exists && verification.isAvailable) {
        // Store the tableId in the URL and navigate to the menu
        // This ensures the TableContext can pick it up from the URL
        navigate(`/?table=${tableId}`);
      } else {
        setError(verification.exists ? 
          'This table is currently not available.' : 
          'Invalid table ID from QR code.');
        setLoading(false);
        // Restart camera if there was an error
        startCamera();
      }
    } catch (err) {
      console.error('Error verifying scanned table:', err);
      setError('Failed to verify the scanned table. Please try again.');
      setLoading(false);
      // Restart camera if there was an error
      startCamera();
    }
  };
  return (
    <div className="min-h-screen bg-[#16141F] text-white flex flex-col items-center justify-center">
      {/* Navbar */}
      <div className="fixed top-0 left-0 right-0 flex justify-between items-center p-4 bg-[#1F1D2B] border-b border-[#2D303E] z-10">
        <div className="text-xl font-bold text-white">INSEAT</div>
        <Button
          variant="ghost"
          size="icon"
          className="rounded-full hover:bg-[#262837]"
          aria-label="Account"
          onClick={() => navigate('/account')}
        >
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="h-6 w-6 text-white">
            <path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"></path>
            <circle cx="12" cy="7" r="4"></circle>
          </svg>
        </Button>
      </div>
      <Card className="w-full max-w-md bg-[#262837] border-[#2D303E] text-white">
        {/* Welcome header */}
        <div className="text-center py-6">
          <h1 className="text-2xl font-bold mb-2">Welcome to InSeat</h1>
          <p className="text-muted-foreground">Scan your table's QR code to get started</p>
        </div>
        <CardContent>
          {error && (
            <Alert variant="destructive" className="mb-4">
              <AlertTriangle className="h-4 w-4" />
              <AlertTitle>Error</AlertTitle>
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          <div className="space-y-4">
            <div className="relative overflow-hidden rounded-lg bg-black aspect-square">
              {cameraPermission === false ? (
                <div className="absolute inset-0 flex flex-col items-center justify-center p-4 bg-gray-900">
                  <AlertTriangle className="h-10 w-10 text-yellow-500 mb-2" />
                  <p className="text-center text-white">
                    Camera access denied. Please enable camera permissions.
                  </p>
                  <Button 
                    variant="outline" 
                    className="mt-4"
                    onClick={() => startCamera()}
                  >
                    Try Again
                  </Button>
                </div>
              ) : (
                <>
                  <video 
                    ref={videoRef} 
                    className="absolute inset-0 h-full w-full object-cover"
                    playsInline 
                    muted
                  />
                  <div className="absolute inset-0 flex items-center justify-center">
                    <div className="w-3/4 h-3/4 border-2 border-white/50 rounded-lg" />
                  </div>
                  <canvas 
                    ref={canvasRef} 
                    className="hidden"
                  />
                </>
              )}
            </div>
            <p className="text-center text-sm text-muted-foreground">
              Position the QR code in the center of the frame
            </p>
            {loading && (
              <div className="flex justify-center">
                <Loader2 className="h-8 w-8 animate-spin text-purple-600" />
              </div>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
};
export default ScanTable;
</file>

<file path="src/constants.ts">
// API Configuration
// Get API URL from environment variables with fallback to production URL
const envApiUrl = import.meta.env.VITE_API_BASE_URL;
export const API_BASE_URL = envApiUrl;
// Log the API URL being used for debugging
console.log('Using API base URL from main constants:', API_BASE_URL);
// Other application constants
export const APP_NAME = 'InSeat Menu';
export const DEFAULT_LOCALE = 'en-US';
export const CURRENCY_FORMAT = 'USD';
// Local storage keys
export const STORAGE_KEYS = {
  TABLE_INFO: 'tableInfo',
  AUTH_TOKEN: 'auth_token',
  USER_INFO: 'user_info',
  FAVORITES: 'favorites',
  CART: 'cart'
};
// Animation durations
export const ANIMATION = {
  FAST: 200,
  NORMAL: 300,
  SLOW: 500
};
// Routes
export const ROUTES = {
  HOME: '/',
  MENU: '/menu',
  CATEGORY: '/category',
  ITEM: '/menu',
  SCAN: '/scan',
  CART: '/cart',
  CHECKOUT: '/checkout',
  ORDERS: '/my-orders',
  CALL_WAITER: '/call-waiter',
  BILL: '/bill'
};
</file>

<file path="src/components/CartDrawer.tsx">
import React, { useState, useEffect } from 'react';
import { API_BASE_URL } from '@/constants';
import { useCart } from '@/context/CartContext';
import { useOrders } from '@/context/OrdersContext';
import { useAuth } from '@/hooks/useAuth';
import { useTableInfo } from '@/context/TableContext';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Trash2, Plus, Minus, X, ArrowRight, Loader2 } from 'lucide-react';
import { toast } from 'sonner';
import { cn } from '@/lib/utils';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Sheet, SheetContent, SheetHeader, SheetTitle } from '@/components/ui/sheet';
import { createOrder, OrderResponseData } from '@/api/orderService';
import { useNavigate } from 'react-router-dom';
import type { Order } from '@/types';
// Order type enum to match API
enum OrderType {
  DINE_IN = 'DINE_IN',
  TAKEOUT = 'TAKEOUT'
}
// Order status enum to match API
enum OrderStatus {
  PENDING = 'PENDING',
  PREPARING = 'PREPARING',
  READY = 'READY',
  DELIVERED = 'DELIVERED',
  COMPLETED = 'COMPLETED',
  CANCELLED = 'CANCELLED'
}
// Payment status enum to match API
enum PaymentStatus {
  PENDING = 'PENDING',
  PROCESSING = 'PROCESSING',
  PAID = 'PAID',
  FAILED = 'FAILED',
  REFUNDED = 'REFUNDED'
}
interface CartItem {
  id: string;
  menuItemId?: string;
  name: string;
  price: number;
  quantity: number;
  specialInstructions?: string;
  modifiers?: Array<{ id: string, name: string, price: number }>;
  image?: string;
}
interface OrderData {
  restaurantId: string;
  tableId: string;
  items: Array<{
    menuItem: string;
    name: string;
    quantity: number;
    price: number;
    subtotal: number;
    specialInstructions: string;
    modifiers?: Array<{ name: string, price: number }>;
  }>;
  subtotal: number;
  tax: number;
  tip: number;
  total: number;
  orderType: OrderType;
  specialInstructions: string;
  serviceFee: number;
  status: OrderStatus;
  paymentStatus: PaymentStatus;
  orderNumber: string;
}
interface CartDrawerProps {
  isOpen: boolean;
  onClose: () => void;
}
const CartDrawer: React.FC<CartDrawerProps> = ({ isOpen, onClose }) => {
  const { cartItems, removeFromCart: removeItem, updateQuantity, clearCart, cartTotal: subtotal } = useCart();
  const { tableId, restaurantName } = useTableInfo();
  const { isAuthenticated, token } = useAuth();
  const { addOrder } = useOrders();
  const navigate = useNavigate();
  const [stage, setStage] = useState<'cart' | 'checkout'>('cart');
  const [specialInstructions, setSpecialInstructions] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState('');
  const [orderType, setOrderType] = useState<OrderType>(OrderType.DINE_IN);
  // Tax and fees calculations
  const taxRate = 0.08;
  const serviceFeeRate = 0.05;
  const tax = subtotal * taxRate;
  const serviceFee = subtotal * serviceFeeRate;
  const tipAmount = 0;
  const total = subtotal + tax + serviceFee + tipAmount;
  useEffect(() => {
    if (!isOpen) {
      setTimeout(() => {
        setStage('cart');
        setIsProcessing(false);
      }, 300);
    }
  }, [isOpen]);
  const processOrder = async () => {
    try {
      const localRestaurantId = restaurantName === 'InSeat'
        ? '65f456b06c9dfd001b6b1234'
        : tableId.split('-')[0];
      const formattedItems = cartItems.map(item => ({
        menuItem: String(item.menuItemId || item.id),
        name: item.name,
        quantity: item.quantity,
        price: item.price,
        subtotal: item.price * item.quantity,
        specialInstructions: item.specialInstructions || specialInstructions || '',
        modifiers: item.modifiers
      }));
      const constructedOrderData: OrderData = {
        restaurantId: localRestaurantId,
        tableId,
        items: formattedItems,
        subtotal,
        tax,
        tip: tipAmount,
        total,
        orderType,
        specialInstructions: specialInstructions || '',
        serviceFee,
        status: OrderStatus.PENDING,
        paymentStatus: PaymentStatus.PENDING,
        orderNumber: `ORD-${Date.now()}-${Math.floor(Math.random() * 1000)}`
      };
      const result = await new Promise<OrderResponseData>((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        const orderApiUrl = import.meta.env.VITE_ORDER_API_URL || 'http://localhost:3001/api/orders';
        xhr.open('POST', orderApiUrl, true);
        xhr.withCredentials = true;
        xhr.setRequestHeader('Content-Type', 'application/json');
        if (token) {
          xhr.setRequestHeader('Authorization', `Bearer ${token}`);
        }
        xhr.onload = function() {
          try {
            if (xhr.status >= 200 && xhr.status < 300) {
              const parsedResponse = JSON.parse(xhr.responseText);
              if (parsedResponse._id) {
                resolve(parsedResponse);
              } else if (parsedResponse.success) {
                resolve(parsedResponse.data);
              } else {
                reject(new Error(parsedResponse.error?.message || 'Order creation failed'));
              }
            } else {
              reject(new Error(`HTTP error ${xhr.status}: ${xhr.statusText}`));
            }
          } catch (error) {
            console.error('Error processing response:', error);
            reject(error);
          }
        };
        xhr.onerror = function() {
          reject(new Error('Network error occurred'));
        };
        xhr.send(JSON.stringify(constructedOrderData));
      });
      // If we still don't have a token, make a regular auth check
      if (!token) {
        console.log('Attempting regular auth check as fallback...');
        const apiBaseUrl = import.meta.env.VITE_AUTH_API_URL || 'http://localhost:3001/api/auth';
        const authResponse = await fetch(`${apiBaseUrl}/me`, {
          method: 'GET',
          credentials: 'include'
        });
        if (authResponse.ok) {
          const authData = await authResponse.json();
          console.log('Auth check successful:', authData);
          if (authData.token) {
            // Set cookie instead of localStorage
            document.cookie = `auth_token=${authData.token}; path=/; max-age=86400; SameSite=Lax`;
          }
        } else {
          console.error('Authentication check failed:', await authResponse.text());
          // Don't throw here, we'll try to continue with the order anyway
        }
      }
      console.log('Using token for order placement:', token ? 'Token available' : 'No token available');
      // If we have a token, make sure it's saved to cookies for future requests
      if (token) {
        // Check if token is already in cookies
        const cookies = document.cookie.split(';');
        const tokenCookie = cookies.find(cookie => cookie.trim().startsWith('auth_token='));
        if (!tokenCookie) {
          document.cookie = `auth_token=${token}; path=/; max-age=86400; SameSite=Lax`;
          console.log('Saved token to cookies');
        }
      }
      // Check authentication status before attempting to create order
      if (!isAuthenticated) {
        // Store cart state for retrieval after login
        localStorage.setItem('pendingCart', JSON.stringify({
          items: cartItems,
          tableId,
          restaurantId: localRestaurantId
        }));
        // Redirect to login with return URL
        toast.error('Please log in to place an order');
        onClose(); // Close the cart drawer
        navigate(`/login?returnTo=/table/${tableId}`);
        return null;
      }
      // Use the enhanced createOrder function from orderService
      const orderResult = await createOrder(cartItems, tableId, localRestaurantId, constructedOrderData, navigate);
      if (!orderResult) {
        console.log('Order creation returned null - authentication failed and user redirected');
        return null;
      }
      console.log('Order placed successfully:', orderResult);
      toast.success('Order placed successfully!');
      // Transform OrderResponseData to Order type for the context
      const orderForContext: Order = {
        id: result._id,
        orderNumber: result.orderNumber,
        items: result.items.map(apiItem => ({
          id: apiItem.menuItem,
          menuItemId: apiItem.menuItem,
          name: apiItem.name,
          price: apiItem.price,
          quantity: apiItem.quantity,
          specialInstructions: apiItem.specialInstructions,
          modifiers: apiItem.modifiers?.map(mod => ({ id: mod.name, name: mod.name, price: mod.price })) || []
        })),
        subtotal: result.subtotal,
        tax: result.tax,
        serviceFee: result.serviceFee,
        tip: result.tip,
        total: result.total,
        status: result.status,
        paymentStatus: result.paymentStatus,
        timestamp: new Date(result.createdAt),
        tableId: result.tableId,
        specialInstructions: result.specialInstructions
      };
      addOrder(orderForContext);
      localStorage.setItem('pending_order_id', result._id);
      clearCart();
      onClose();
      toast.success('Order placed successfully!');
      setTimeout(() => {
        navigate(`/my-orders?table=${tableId}`);
      }, 1000);
    } catch (error) {
      console.error('Error in order creation process:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to create your order');
      setIsProcessing(false);
      setError(error instanceof Error ? error.message : 'Failed to create your order');
      throw error;
    }
  };
  const handlePlaceOrder = async (): Promise<void> => {
    try {
      if (cartItems.length === 0) {
        toast.error('Your cart is empty. Please add items to place an order.');
        return;
      }
      if (!tableId) {
        toast.error("Table information is missing. Please scan a table QR code first.");
        onClose();
        navigate('/scan');
        return;
      }
      setIsProcessing(true);
      await processOrder();
    } catch (error) {
      console.error('Error placing order:', error);
      setIsProcessing(false);
      toast.error(error instanceof Error ? error.message : 'Failed to place order');
      setError(error instanceof Error ? error.message : 'Failed to place order');
    }
  };
  const handleCheckout = () => {
    if (cartItems.length === 0) {
      toast.error("Your cart is empty");
      return;
    }
    setStage('checkout');
  };
  const handleClose = () => {
    if (isProcessing) {
      if (window.confirm("Your order is still being processed. Are you sure you want to close?")) {
        onClose();
      }
    } else {
      onClose();
    }
  };
  let content;
  if (stage === 'checkout') {
    content = (
      <div className="flex flex-col h-full">
        <SheetHeader className="p-4 border-b border-[#2D303E]">
          <div className="flex items-center justify-between">
            <SheetTitle className="text-xl font-semibold">Checkout</SheetTitle>
            <Button
              variant="ghost"
              size="icon"
              onClick={handleClose}
              disabled={isProcessing}
            >
              <X className="h-5 w-5" />
            </Button>
          </div>
        </SheetHeader>
        <ScrollArea className="flex-1">
          <div className="p-4 space-y-6">
            <div className="space-y-2">
              <h3 className="font-medium">Order Type</h3>
              <div className="flex gap-2">
                <Button
                  variant={orderType === OrderType.DINE_IN ? "default" : "outline"}
                  size="sm"
                  className={cn(
                    orderType === OrderType.DINE_IN 
                      ? "bg-delft-blue hover:bg-delft-blue/90" 
                      : ""
                  )}
                  onClick={() => setOrderType(OrderType.DINE_IN)}
                  disabled={isProcessing}
                >
                  Dine In
                </Button>
                <Button
                  variant={orderType === OrderType.TAKEOUT ? "default" : "outline"}
                  size="sm"
                  className={cn(
                    orderType === OrderType.TAKEOUT 
                      ? "bg-delft-blue hover:bg-delft-blue/90" 
                      : ""
                  )}
                  onClick={() => setOrderType(OrderType.TAKEOUT)}
                  disabled={isProcessing}
                >
                  Takeout
                </Button>
              </div>
            </div>
            <div className="space-y-2">
              <div className="flex justify-between items-center">
                <h3 className="font-medium">Order Items</h3>
                <Button
                  variant="link"
                  size="sm"
                  className="h-auto p-0 text-delft-blue"
                  onClick={() => setStage('cart')}
                  disabled={isProcessing}
                >
                  Edit
                </Button>
              </div>
              <div className="space-y-2">
                {cartItems.map((item) => (
                  <div key={item.id} className="flex justify-between text-sm">
                    <div className="flex">
                      <span className="font-medium">{item.quantity}x</span>
                      <span className="ml-2">{item.name}</span>
                    </div>
                    <span>${(item.price * item.quantity).toFixed(2)}</span>
                  </div>
                ))}
              </div>
            </div>
            <div className="space-y-2">
              <h3 className="font-medium">Special Instructions</h3>
              <Textarea 
                placeholder="Add any special instructions for your order..."
                value={specialInstructions}
                onChange={(e) => setSpecialInstructions(e.target.value)}
                className="resize-none"
              />
            </div>
          </div>
        </ScrollArea>
        <div className="border-t border-[#2D303E] p-4 space-y-4">
          <div className="space-y-2">
            <div className="flex justify-between">
              <span className="text-muted-foreground">Subtotal</span>
              <span>${subtotal.toFixed(2)}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">Tax ({(taxRate * 100).toFixed(0)}%)</span>
              <span>${tax.toFixed(2)}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">Service Fee ({(serviceFeeRate * 100).toFixed(0)}%)</span>
              <span>${serviceFee.toFixed(2)}</span>
            </div>
            {tipAmount > 0 && (
              <div className="flex justify-between">
                <span className="text-muted-foreground">Tip</span>
                <span>${tipAmount.toFixed(2)}</span>
              </div>
            )}
            <div className="flex justify-between font-medium text-lg pt-2 border-t border-[#2D303E]">
              <span>Total</span>
              <span>${total.toFixed(2)}</span>
            </div>
          </div>
          <Button 
            onClick={handlePlaceOrder}
            className="w-full bg-delft-blue hover:bg-delft-blue/90 text-white"
            disabled={isProcessing}
          >
            {isProcessing ? (
              <div className="flex items-center">
                <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Processing...
              </div>
            ) : (
              <>
                Place Order
                <ArrowRight className="ml-2 h-4 w-4" />
              </>
            )}
          </Button>
        </div>
      </div>
    );
  } else {
    content = (
      <div className="flex flex-col h-full">
        <SheetHeader className="p-4 border-b border-[#2D303E]">
          <div className="flex items-center justify-between">
            <SheetTitle className="text-xl font-semibold">Your Cart</SheetTitle>
            <Button
              variant="ghost"
              size="icon"
              onClick={handleClose}
            >
              <X className="h-5 w-5" />
            </Button>
          </div>
        </SheetHeader>
        <ScrollArea className="flex-1 p-4">
          {cartItems.length === 0 ? (
            <div className="flex flex-col items-center justify-center h-full text-center">
              <p className="text-muted-foreground mb-4">Your cart is empty</p>
              <Button onClick={handleClose} variant="outline">
                Continue Shopping
              </Button>
            </div>
          ) : (
            <div className="space-y-4">
              {cartItems.map((item) => (
                <div
                  key={item.id}
                  className="flex gap-3 p-3 rounded-lg bg-[#1F1D2B] border border-[#2D303E]"
                >
                  {item.image && (
                    <img
                      src={item.image}
                      alt={item.name}
                      className="w-20 h-20 object-cover rounded-md"
                      onError={(e) => {
                        const target = e.target as HTMLImageElement;
                        target.src = 'https://source.unsplash.com/featured/?food';
                      }}
                    />
                  )}
                  <div className="flex-1">
                    <div className="flex justify-between">
                      <h3 className="font-medium">{item.name}</h3>
                      <Button
                        variant="ghost"
                        size="icon"
                        className="h-6 w-6 -mr-1 -mt-1 text-muted-foreground"
                        onClick={() => removeItem(item.id)}
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </div>
                    <p className="text-sm text-delft-blue mt-1">${item.price.toFixed(2)}</p>
                    {item.modifiers && item.modifiers.length > 0 && (
                      <div className="mt-1 text-xs text-muted-foreground">
                        {item.modifiers.map((mod, index) => (
                          <div key={index} className="flex justify-between">
                            <span>{mod.name}</span>
                            {mod.price > 0 && (
                              <span>+${mod.price.toFixed(2)}</span>
                            )}
                          </div>
                        ))}
                      </div>
                    )}
                    {item.specialInstructions && (
                      <div className="mt-1 text-xs italic text-muted-foreground">
                        {item.specialInstructions}
                      </div>
                    )}
                    <div className="flex items-center justify-between mt-2">
                      <div className="flex items-center gap-2">
                        <Button
                          variant="outline"
                          size="icon"
                          className="h-7 w-7"
                          onClick={() => updateQuantity(item.id, item.quantity - 1)}
                          disabled={item.quantity <= 1}
                        >
                          <Minus className="h-3 w-3" />
                        </Button>
                        <span className="w-5 text-center text-sm">{item.quantity}</span>
                        <Button
                          variant="outline"
                          size="icon"
                          className="h-7 w-7"
                          onClick={() => updateQuantity(item.id, item.quantity + 1)}
                        >
                          <Plus className="h-3 w-3" />
                        </Button>
                      </div>
                      <span className="font-medium">
                        ${(item.price * item.quantity).toFixed(2)}
                      </span>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}
        </ScrollArea>
        {cartItems.length > 0 && (
          <div className="border-t border-[#2D303E] p-4 space-y-3">
            <div className="flex justify-between font-medium">
              <span>Subtotal</span>
              <span>${subtotal.toFixed(2)}</span>
            </div>
            <Button
              className="w-full bg-delft-blue hover:bg-delft-blue/90 text-white"
              onClick={handleCheckout}
            >
              Continue to Checkout
              <ArrowRight className="ml-2 h-4 w-4" />
            </Button>
          </div>
        )}
      </div>
    );
  }
  return (
    <Sheet open={isOpen} onOpenChange={handleClose}>
      <SheetContent 
        side="right" 
        className="w-full sm:max-w-md border-l border-[#2D303E] bg-[#16141F] p-0 max-h-screen"
      >
        {content}
      </SheetContent>
    </Sheet>
  );
};
export default CartDrawer;
</file>

<file path="src/api/authService.ts">
import axios from 'axios';
// Define base API URL - should come from environment variables in production
const API_BASE_URL = import.meta.env.VITE_AUTH_API_URL || 'https://api.inseat.achievengine.com/api/auth';
// Extract the base URL without any /api/auth path if present
const BASE_URL = API_BASE_URL.includes('/api/auth') 
  ? API_BASE_URL.split('/api/auth')[0] 
  : API_BASE_URL;
// Define the auth API endpoint
const AUTH_API_URL = `${BASE_URL}/api/auth`;
console.log('API base URL:', API_BASE_URL);
console.log('Extracted base URL:', BASE_URL);
console.log('Auth API URL:', AUTH_API_URL);
// Types
export interface LoginCredentials {
  email: string;
  password: string;
}
export interface RegisterData {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
}
export interface AuthResponse {
  success: boolean;
  user?: {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    role: string;
    loyaltyPoints?: number;
  };
  token?: string;
  accessToken?: string;
  jwt?: string;
  message?: string; // Add message property for error responses
}
// Helper function to get token from localStorage
export const getEffectiveToken = (): string | null => {
  try {
    // Check localStorage first
    const localToken = localStorage.getItem('auth_token');
    if (localToken) {
      console.log('Found token in localStorage');
      return localToken;
    }
    // If using JWT cookies (access_token), we don't extract it here
    // because withCredentials will send it automatically
    // But we log this for debugging
    console.log('No token in localStorage, will rely on cookies if available');
    // The actual token will be sent automatically with fetch/axios requests
    // if credentials: 'include' is set
    // Return an indicator that tokens might be in HttpOnly cookies
    // We'll need to rely on the API calls with credentials: 'include'
    if (document.cookie.includes('auth_token') || document.cookie.includes('access_token')) {
      console.log('Found auth_token or access_token in cookie string (might be HttpOnly)');
      return 'http-only-cookie-present';
    }
    console.log('No token indicators found in cookies or localStorage');
    return null;
  } catch (error) {
    console.error('Error in getEffectiveToken:', error);
    return null;
  }
};
// getEffectiveToken is already exported above
// Axios instance with credentials (for cookies)
const api = axios.create({
  baseURL: AUTH_API_URL,
  withCredentials: true, // This is required for cookies to be sent with requests
  headers: {
    'Content-Type': 'application/json',
    'X-Requested-With': 'XMLHttpRequest'
  },
});
// Set up request interceptor to add auth token to all requests
api.interceptors.request.use(
  (config) => {
    // Check cookies for debugging
    const cookies = document.cookie.split(';').map(c => c.trim());
    const hasAccessToken = cookies.some(c => c.startsWith('access_token='));
    const hasRefreshToken = cookies.some(c => c.startsWith('refresh_token='));
    console.log('Request interceptor - Cookies status:');
    console.log('- Has access_token cookie:', hasAccessToken);
    console.log('- Has refresh_token cookie:', hasRefreshToken);
    // Get token from localStorage if available
    const token = getEffectiveToken();
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
      console.log('âœ… Added token from localStorage to request headers');
    } else if (hasAccessToken) {
      console.log('âœ… No localStorage token, but access_token cookie exists');
      // No need to extract the cookie value, it will be sent automatically
      // due to withCredentials: true
    } else {
      console.log('âš ï¸ No authentication token available');
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);
const authService = {
  // Register a new user
  async register(userData: RegisterData): Promise<AuthResponse> {
    try {
      const response = await api.post('/register', userData);
      return response.data;
    } catch (error) {
      if (axios.isAxiosError(error) && error.response) {
        throw new Error(error.response.data.message || 'Registration failed');
      }
      throw new Error('Unable to connect to authentication service');
    }
  },
  // Login with email and password
  async login(credentials: LoginCredentials): Promise<AuthResponse> {
    try {
      console.log('Attempting login with credentials:', { email: credentials.email });
      const response = await api.post('/login', credentials, {
        headers: {
          'Content-Type': 'application/json',
          'X-Requested-With': 'XMLHttpRequest'
        }
      });
      console.log('Login response received:', {
        success: response.data.success,
        hasUser: !!response.data.user,
        hasToken: !!(response.data.token || response.data.accessToken || response.data.jwt)
      });
      if (response.data.success && response.data.user) {
        // Check for token in different possible locations
        let token = response.data.token || response.data.accessToken || response.data.jwt;
        if (token) {
          console.log('Token found in login response, length:', token.length);
          // Store token in localStorage only
          localStorage.setItem('auth_token', token);
          console.log('Token stored in localStorage');
          // Also store user data in localStorage
          localStorage.setItem('user', JSON.stringify(response.data.user));
          // Verify the token was stored correctly
          const storedToken = localStorage.getItem('auth_token');
          if (storedToken !== token) {
            console.error('Token storage verification failed');
            throw new Error('Failed to store authentication token');
          }
          console.log('Login successful, token stored');
        } else {
          console.warn('No token found in login response, checking for token endpoint');
          try {
            // Try to get a fresh token using the session
            const tokenResponse = await api.get('/token');
            if (tokenResponse.data && tokenResponse.data.token) {
              const newToken = tokenResponse.data.token;
              console.log('Retrieved fresh token from /token');
              // Store the new token in localStorage only
              localStorage.setItem('auth_token', newToken);
              console.log('Updated token in localStorage');
              // Update the response with the new token
              response.data.token = newToken;
            } else {
              console.warn('No token received from /token endpoint');
              // Continue without a token if the server doesn't provide one
            }
          } catch (tokenError) {
            console.error('Failed to retrieve token from /token:', tokenError);
            // Don't fail the login if we can't get a token - the session might still be valid
          }
        }
        return response.data;
      } else {
        const errorMessage = response.data?.message || 'Login failed';
        console.error('Login failed:', errorMessage);
        throw new Error(errorMessage);
      }
    } catch (error) {
      console.error('Login error:', error);
      // Clear any partial authentication state
      localStorage.removeItem('auth_token');
      localStorage.removeItem('user');
      if (axios.isAxiosError(error)) {
        if (error.response) {
          // Server responded with an error status
          const errorMessage = error.response.data?.message || 'Login failed';
          throw new Error(errorMessage);
        } else if (error.request) {
          // Request was made but no response received
          throw new Error('Unable to connect to the authentication server. Please check your connection.');
        }
      }
      // Generic error for any other case
      throw new Error('An unexpected error occurred during login');
    }
  },
  // Logout user
  async logout(): Promise<void> {
    try {
      await api.post('/logout');
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      // Always clear local storage
      localStorage.removeItem('auth_token');
      localStorage.removeItem('user');
      // Clear cookies by setting them to expire in the past
      document.cookie = 'auth_token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT; SameSite=Lax';
      document.cookie = 'access_token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT; SameSite=Lax';
      document.cookie = 'refresh_token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT; SameSite=Lax';
      console.log('Cleared authentication data from localStorage and cookies');
    }
  },
  // Get current user profile
  async getCurrentUser(): Promise<AuthResponse> {
    try {
      const token = getEffectiveToken();
      console.log('Fetching current user with token:', token ? 'Token exists' : 'No token');
      console.log('Auth API URL:', AUTH_API_URL);
      // Use only the /me endpoint with the correct base URL
      console.log('Attempting to fetch user from /me endpoint');
      // Log all cookies for debugging
      console.log('Document cookies:', document.cookie);
      // Make the request
      const response = await api.get('/me');
      console.log('User data response from /me:', response.data);
      if (response.data) {
        // If we get a token in the response, save it
        if (response.data.token) {
          localStorage.setItem('auth_token', response.data.token);
          console.log('Updated token from user data:', response.data.token.substring(0, 10) + '...');
        } else if (response.data.accessToken) {
          // Some APIs return accessToken instead of token
          localStorage.setItem('auth_token', response.data.accessToken);
          console.log('Updated token from accessToken:', response.data.accessToken.substring(0, 10) + '...');
        }
        // Extract token from response data or use existing token
        const effectiveToken = response.data.token || response.data.accessToken || token;
        // Transform the response to the expected format
        if (typeof response.data.success !== 'undefined') {
          // Already in the expected format
          return response.data;
        } else if (response.data.user) {
          // Some APIs nest the user data under a 'user' property
          return {
            success: true,
            user: response.data.user,
            token: effectiveToken
          };
        } else if (response.data.id || response.data._id) {
          // Direct user object, wrap it in the expected format
          return { 
            success: true, 
            user: response.data,
            token: effectiveToken
          };
        }
      }
      // No usable data
      return {
        success: false,
        message: 'No valid user data returned from /me endpoint'
      };
    } catch (error) {
      console.error('Get current user error:', error);
      // Try to get user from localStorage as fallback
      try {
        const savedUser = localStorage.getItem('user');
        if (savedUser) {
          const userData = JSON.parse(savedUser);
          console.log('Using cached user data as fallback');
          return {
            success: true,
            user: userData,
            token: getEffectiveToken()
          };
        }
      } catch (e) {
        console.error('Error reading user from localStorage:', e);
      }
      return {
        success: false,
        message: error instanceof Error ? error.message : 'Failed to get user data'
      };
    }
  },
  // Refresh token
  async refreshToken(): Promise<boolean> {
    try {
      const response = await api.post('/refresh-token');
      if (response.data.token) {
        localStorage.setItem('auth_token', response.data.token);
        console.log('Token refreshed and updated');
        return true;
      } else if (response.data.accessToken) {
        localStorage.setItem('auth_token', response.data.accessToken);
        console.log('Token refreshed and updated (accessToken)');
        return true;
      }
      return false;
    } catch (error) {
      console.error('Token refresh error:', error);
      return false;
    }
  },
  // Check if token is expired
  isTokenExpired(token: string | null): boolean {
    if (!token) return true;
    try {
      // Decode JWT to get expiration
      const payload = JSON.parse(atob(token.split('.')[1]));
      const expiry = payload.exp * 1000; // Convert to milliseconds
      return Date.now() >= expiry;
    } catch (e) {
      console.error('Error checking token expiration:', e);
      return true; // Assume expired on error
    }
  },
  // Get token with automatic refresh if needed
  async getValidToken(): Promise<string | null> {
    let token = getEffectiveToken();
    // If no token, try to get from cookies
    if (!token) {
      const cookies = document.cookie.split(';');
      const tokenCookie = cookies.find(cookie => 
        cookie.trim().startsWith('auth_token=') || 
        cookie.trim().startsWith('access_token=')
      );
      if (tokenCookie) {
        token = tokenCookie.split('=')[1].trim();
        localStorage.setItem('auth_token', token);
      }
    }
    // If still no token, return null
    if (!token) {
      return null;
    }
    // Check if token is expired
    if (this.isTokenExpired(token)) {
      console.log('Token expired, attempting to refresh...');
      const refreshed = await this.refreshToken();
      if (refreshed) {
        return getEffectiveToken();
      }
      return null;
    }
    return token;
  },
  // Get the effective token (exposed for components)
  getToken(): string | null {
    return getEffectiveToken();
  },
  // Get user profile from the server
  async getUserProfile(): Promise<AuthResponse> {
    try {
      console.log('Fetching user profile from server...');
      // Make sure we have a valid token first
      const token = await this.getValidToken();
      if (!token) {
        console.warn('No valid token available for getUserProfile');
        return {
          success: false,
          message: 'No valid authentication token available'
        };
      }
      // Only use the /me endpoint with the correct base URL
      console.log('Trying /me endpoint');
      const response = await api.get('/me', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      console.log('User profile response from /me:', response.data);
      // Check response structure and adapt accordingly
      if (response.data) {
        // If we get a token in the response, save it
        if (response.data.token) {
          localStorage.setItem('auth_token', response.data.token);
          console.log('Updated token from profile data:', response.data.token.substring(0, 10) + '...');
        } else if (response.data.accessToken) {
          localStorage.setItem('auth_token', response.data.accessToken);
          console.log('Updated token from profile accessToken:', response.data.accessToken.substring(0, 10) + '...');
        }
        // Transform the response to the expected format
        if (typeof response.data.success !== 'undefined') {
          // Already in the expected format
          return response.data;
        } else if (response.data.user) {
          // Some APIs nest the user data under a 'user' property
          return {
            success: true,
            user: response.data.user,
            token: response.data.token || response.data.accessToken || token
          };
        } else if (response.data.id || response.data._id) {
          // Direct user object, wrap it in the expected format
          return {
            success: true,
            user: response.data,
            token: response.data.token || response.data.accessToken || token
          };
        }
      }
      // No usable data
      return {
        success: false,
        message: 'No valid user data returned from /me endpoint'
      };
    } catch (error) {
      console.error('Get user profile error:', error);
      // Try to use stored user data as fallback
      try {
        const storedUser = localStorage.getItem('user');
        if (storedUser) {
          return {
            success: true,
            user: JSON.parse(storedUser),
            token: getEffectiveToken()
          };
        }
      } catch (e) {
        console.error('Error reading stored user:', e);
      }
      return {
        success: false,
        message: error instanceof Error ? error.message : 'Failed to get user profile'
      };
    }
  },
  // Check authentication status
  async checkAuthStatus(): Promise<boolean> {
    try {
      // Try the dedicated check endpoint
      console.log('Checking authentication status...');
      const response = await api.get('/check');
      console.log('Auth check response:', response.data);
      // If response has isAuthenticated property, use it
      if (typeof response.data.isAuthenticated === 'boolean') {
        return response.data.isAuthenticated;
      }
      // If response has success property, use it
      if (typeof response.data.success === 'boolean') {
        return response.data.success;
      }
      // Otherwise assume success if we get a 200 response
      return true;
    } catch (error) {
      console.error('Auth check error:', error);
      // If token exists but server check failed, might be temporary issue
      const token = getEffectiveToken();
      if (token && !this.isTokenExpired(token)) {
        console.log('Server check failed but valid token exists');
        return true;
      }
      return false;
    }
  },
  // Guest login
  async guestLogin(tableId?: string): Promise<AuthResponse> {
    try {
      console.log('Attempting guest login', tableId ? `for table ${tableId}` : 'without table ID');
      // Use the guest token endpoint instead of guest-login
      const response = await api.post('/guest-token', tableId ? { tableId } : {});
      console.log('Guest login response:', response.data);
      if (response.data.success && response.data.token) {
        // Store token in localStorage
        localStorage.setItem('auth_token', response.data.token);
        // Store user info if available
        if (response.data.user) {
          localStorage.setItem('user', JSON.stringify(response.data.user));
        }
        return response.data;
      } else {
        throw new Error(response.data.message || 'Guest login failed');
      }
    } catch (error) {
      console.error('Guest login error:', error);
      // Clear any partial auth state
      localStorage.removeItem('auth_token');
      localStorage.removeItem('user');
      if (axios.isAxiosError(error) && error.response) {
        throw new Error(error.response.data.message || 'Guest login failed');
      }
      throw new Error('Unable to connect to the authentication service');
    }
  },
  // Get Google OAuth URL for redirect
  getGoogleAuthUrl(): string {
    // Return the Google OAuth URL from the backend
    // The backend should have a route that redirects to Google's OAuth page
    console.log('Getting Google Auth URL, AUTH_API_URL is:', AUTH_API_URL);
    // Correctly format the URL without duplication
    return `${AUTH_API_URL}/google`;
  }
};
export default authService;
</file>

</files>
